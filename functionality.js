/* ============================================
   Layer - Inbox View (Modern Card Layout)
   ============================================ */

// Track if dashboard AI greeting has been shown this session
let dashboardAIShown = false;

function renderInboxView() {
  const projects = loadProjects();
  const calendarEvents = loadCalendarEvents();
  const issues = loadIssues();
  const docs = loadDocs();

  // Normalize date helper (fixes comparison issues)
  function normalizeDate(dateStr) {
    if (!dateStr) return null;
    const date = new Date(dateStr);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayStr = today.toISOString().split('T')[0];

  const oneWeekFromNow = new Date(today);
  oneWeekFromNow.setDate(today.getDate() + 7);

  const upcomingEvents = calendarEvents
    .filter(event => {
      if (!event.date) return false;
      const eventDate = normalizeDate(event.date);
      return eventDate >= today && eventDate <= oneWeekFromNow;
    })
    .sort((a, b) => new Date(a.date) - new Date(b.date));

  const todayTasks = calendarEvents.filter(e => e.date === todayStr);
  const recentActivity = getRecentActivity(projects);

  // Calculate stats
  const completedTasks = calendarEvents.filter(e => e.completed).length;
  const totalTasks = calendarEvents.length;
  const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
  const openIssues = issues.filter(i => i.status !== 'done').length;
  const activeProjects = projects.length;

  // Generate AI greeting message
  const aiMessage = generateAIGreeting(todayTasks, upcomingEvents, projects);

  // Calculate daily productivity (last 7 days)
  const productivityData = [];
  for (let i = 6; i >= 0; i--) {
    const d = new Date(today);
    d.setDate(today.getDate() - i);
    const dateStr = d.toISOString().split('T')[0];
    const count = calendarEvents.filter(e => e.date === dateStr && e.completed).length;
    productivityData.push({ day: d.toLocaleDateString('en-US', { weekday: 'short' }), count });
  }
  const maxCount = Math.max(...productivityData.map(d => d.count), 1);

  let content = `
    <div class="dashboard-layout">
      <!-- Main Dashboard Content -->
      <div class="dashboard-main">
        <div class="inbox-container" style="padding: 32px 24px;">
          <!-- Dashboard Header with Edit Toggle -->
          <div class="dashboard-header-row">
            <h2 class="view-title" style="margin-bottom: 0; font-size: 28px; font-weight: 700;">Dashboard</h2>
            <div class="dashboard-header-actions">
              <button class="dashboard-ai-sidebar-toggle" id="dashboardAiSidebarToggle" onclick="toggleDashboardAiSidebar()" title="Toggle AI Sidebar">
                <svg class="icon collapse-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                  <path d="M15 18l-6-6 6-6" />
                </svg>
                <svg class="icon expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                  <path d="M9 18l6-6-6-6" />
                </svg>
                <span class="toggle-text">Hide AI</span>
              </button>
              <button class="dashboard-edit-toggle" id="dashboardEditToggle" onclick="toggleDashboardEditMode()" title="Customize widget layout">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                  <rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/>
                  <rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/>
                </svg>
                <span>Edit Layout</span>
              </button>
            </div>
          </div>
          
          <!-- Enhanced Dashboard Widgets Grid -->
          <div class="dashboard-widgets-grid" id="dashboardWidgetsGrid">
            <!-- Stats Widget -->
            <div class="dashboard-widget" data-widget-id="overview">
              <div class="widget-header">
                <span class="widget-title">
                  <svg class="widget-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 12h-4l-3 9L9 3l-3 9H2"/>
                  </svg>
                  Overview
                </span>
              </div>
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
                <div style="text-align: center;">
                  <div class="widget-stat-value">${activeProjects}</div>
                  <div class="widget-stat-label">Projects</div>
                </div>
                <div style="text-align: center;">
                  <div class="widget-stat-value">${openIssues}</div>
                  <div class="widget-stat-label">Open Issues</div>
                </div>
                <div style="text-align: center;">
                  <div class="widget-stat-value">${docs.length}</div>
                  <div class="widget-stat-label">Documents</div>
                </div>
              </div>
            </div>
            
            <!-- Progress Widget - Flippable with Backlog -->
            <div class="dashboard-widget task-completion-widget" data-widget-id="task-completion" id="taskCompletionWidget" onclick="flipTaskCompletionWidget()">
              <div class="widget-flip-container">
                <!-- Front Side -->
                <div class="widget-flip-front">
                  <div class="widget-header">
                    <span class="widget-title">
                      <svg class="widget-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M12 6v6l4 2"/>
                      </svg>
                      Task Completion
                    </span>
                    <span style="font-size: 24px; font-weight: 700; color: var(--foreground);">${completionRate}%</span>
                  </div>
                  <div class="widget-progress-bar">
                    <div class="widget-progress-fill" style="width: ${completionRate}%;"></div>
                  </div>
                  <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: var(--muted-foreground);">
                    <span>${completedTasks} completed</span>
                    <span>${totalTasks - completedTasks} remaining</span>
                  </div>
                  <div class="widget-flip-hint">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;">
                      <path d="M17 1l4 4-4 4"/>
                      <path d="M3 11V9a4 4 0 014-4h14"/>
                    </svg>
                    Click to view backlog
                  </div>
                </div>
                <!-- Back Side - Backlog Tasks -->
                <div class="widget-flip-back">
                  <div class="widget-header">
                    <span class="widget-title">
                      <svg class="widget-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2"/>
                        <rect x="9" y="3" width="6" height="4" rx="1"/>
                      </svg>
                      Backlog
                    </span>
                    <span class="widget-back-close" onclick="event.stopPropagation(); flipTaskCompletionWidget()">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;"><path d="M18 6L6 18M6 6l12 12"/></svg>
                    </span>
                  </div>
                  <div class="widget-backlog-list" id="widgetBacklogList">
                    ${renderWidgetBacklogTasks()}
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Quick Actions Widget -->
            <div class="dashboard-widget" data-widget-id="quick-actions">
              <div class="widget-header">
                <span class="widget-title">
                  <svg class="widget-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
                  </svg>
                  Quick Actions
                </span>
              </div>
              <div class="quick-actions-grid">
                <button class="quick-action-btn" onclick="openDocEditor()">
                  <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <style>
                      @keyframes lineExpand {
                        0% {
                          stroke-dashoffset: 8;
                          transform: scaleX(0);
                          transform-origin: left;
                        }
                        100% {
                          stroke-dashoffset: 0;
                          transform: scaleX(1);
                        }
                      }
                      
                      @keyframes linePulse {
                        0%, 100% {
                          opacity: 1;
                          stroke-width: 2;
                        }
                        50% {
                          opacity: 0.6;
                          stroke-width: 2.5;
                        }
                      }
                      
                      .quick-action-btn:hover .doc-line {
                        animation: lineExpand 0.4s ease-out, linePulse 0.5s ease-in-out;
                        stroke-dasharray: 8;
                      }
                      
                      .quick-action-btn:hover .doc-line:nth-child(4) {
                        animation-delay: 0.15s;
                      }
                    </style>
                    
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line class="doc-line" x1="16" y1="13" x2="8" y2="13"></line>
                    <line class="doc-line" x1="16" y1="17" x2="8" y2="17"></line>
                  </svg>
                  New Doc
                </button>
                <button class="quick-action-btn" onclick="openCreateIssueModal()">
                  <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <style>
                      @keyframes circlePulse {
                        0%, 100% {
                          transform: scale(1);
                        }
                        50% {
                          transform: scale(1.1);
                        }
                      }
                      
                      @keyframes plusExpand {
                        0% {
                          transform: scale(0);
                          opacity: 0;
                        }
                        50% {
                          transform: scale(1.2);
                        }
                        100% {
                          transform: scale(1);
                          opacity: 1;
                        }
                      }
                      
                      @keyframes rotate {
                        0% {
                          transform: rotate(0deg);
                        }
                        100% {
                          transform: rotate(90deg);
                        }
                      }
                      
                      .quick-action-btn:hover .plus-circle {
                        animation: circlePulse 0.4s ease-in-out;
                        transform-origin: center;
                      }
                      
                      .quick-action-btn:hover .plus-lines {
                        animation: plusExpand 0.4s ease-out, rotate 0.4s ease-in-out;
                        transform-origin: center;
                      }
                    </style>
                    
                    <circle class="plus-circle" cx="12" cy="12" r="10"></circle>
                    <path class="plus-lines" d="M12 8v8M8 12h8"></path>
                  </svg>
                  New Issue
                </button>
                <button class="quick-action-btn" onclick="currentView = 'activity'; renderCurrentView();">
                  <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <style>
                      @keyframes folderOpen {
                        0%, 100% {
                          transform: translateY(0) scaleY(1);
                        }
                        50% {
                          transform: translateY(-3px) scaleY(1.05);
                        }
                      }
                      
                      @keyframes tabWiggle {
                        0%, 100% {
                          transform: translateY(0) rotate(0deg);
                        }
                        25% {
                          transform: translateY(-2px) rotate(-2deg);
                        }
                        75% {
                          transform: translateY(-2px) rotate(2deg);
                        }
                      }
                      
                      @keyframes pathDraw {
                        0% {
                          stroke-dashoffset: 100;
                        }
                        100% {
                          stroke-dashoffset: 0;
                        }
                      }
                      
                      .quick-action-btn:hover .folder-path {
                        animation: folderOpen 0.4s ease-in-out, pathDraw 0.5s ease-out;
                        stroke-dasharray: 100;
                        transform-origin: bottom center;
                      }
                    </style>
                    
                    <path class="folder-path" d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                  </svg>
                  Projects
                </button>
                <button class="quick-action-btn" onclick="currentView = 'schedule'; renderCurrentView();">
                  <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <style>
                      @keyframes calendarPop {
                        0%, 100% {
                          transform: scale(1);
                        }
                        50% {
                          transform: scale(1.08);
                        }
                      }
                      
                      @keyframes slideDown {
                        0% {
                          transform: translateY(-2px);
                          opacity: 0.5;
                        }
                        100% {
                          transform: translateY(0);
                          opacity: 1;
                        }
                      }
                      
                      .quick-action-btn:hover .icon {
                        animation: calendarPop 0.3s ease-in-out;
                      }
                      
                      .quick-action-btn:hover .icon .divider {
                        animation: slideDown 0.3s ease-out;
                      }
                    </style>
                    
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="16" y1="2" x2="16" y2="6"></line>
                    <line x1="8" y1="2" x2="8" y2="6"></line>
                    <line class="divider" x1="3" y1="10" x2="21" y2="10"></line>
                  </svg>
                  Calendar
                </button>
              </div>
            </div>
            
            <!-- Shared Docs and Sheets Widget -->
            <div class="dashboard-widget" data-widget-id="shared-content">
              <div class="widget-header">
                <span class="widget-title">
                  <svg class="widget-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                    <circle cx="12" cy="12" r="3"/>
                  </svg>
                  Shared with Me
                </span>
                <button class="widget-action-btn" onclick="refreshSharedContent()" title="Refresh">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                    <path d="M23 4v6h-6M1 20v-6h6"/>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                  </svg>
                </button>
              </div>
              <div class="shared-gradient-bar"></div>
              <div id="sharedContentWidget">
                <div style="text-align: center; padding: 20px; color: var(--muted-foreground); font-size: 13px;">
                  <div style="margin-bottom: 8px;">Loading shared content...</div>
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;animation:spin 1s linear infinite;">
                    <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
                  </svg>
                </div>
              </div>
            </div>
            
            <!-- Productivity Chart -->
            <div class="dashboard-widget" data-widget-id="weekly-activity">
              <div class="widget-header">
                <span class="widget-title">
                  <svg class="widget-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="12" y1="20" x2="12" y2="10"/><line x1="18" y1="20" x2="18" y2="4"/><line x1="6" y1="20" x2="6" y2="16"/>
                  </svg>
                  Weekly Activity
                </span>
              </div>
              <div class="productivity-chart">
                ${productivityData.map(d => `
                  <div class="chart-bar ${d.count === 0 ? 'muted' : ''}" style="height: ${Math.max(10, (d.count / maxCount) * 100)}%;" title="${d.day}: ${d.count} tasks"></div>
                `).join('')}
              </div>
              <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 10px; color: var(--muted-foreground);">
                ${productivityData.map(d => `<span>${d.day}</span>`).join('')}
              </div>
            </div>
            
            <!-- Streak Widget -->
            <div class="dashboard-widget" data-widget-id="streak">
              <div class="widget-header">
                <span class="widget-title">
                  <svg class="widget-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                  </svg>
                  Your Streak
                </span>
              </div>
              <div class="streak-display">
                <span class="streak-flame">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:24px;height:24px;color:hsl(24, 90%, 60%);">
                    <path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"/>
                  </svg>
                </span>
                <div class="streak-info">
                  <div class="streak-count">${calculateStreak(calendarEvents)} days</div>
                  <div class="streak-label">Keep it up!</div>
                </div>
              </div>
            </div>
            
            <!-- Today's Focus Goals -->
            <div class="dashboard-widget" data-widget-id="todays-focus">
              <div class="widget-header">
                <span class="widget-title">
                  <svg class="widget-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/>
                  </svg>
                  Today's Focus
                </span>
              </div>
              <div class="goals-list">
                ${todayTasks.length > 0 ? todayTasks.slice(0, 3).map((task, i) => `
                  <div class="goal-item">
                    <div class="goal-checkbox ${task.completed ? 'completed' : ''}" onclick="toggleDashboardGoal(${task.id})"></div>
                    <span class="goal-text ${task.completed ? 'completed' : ''}">${task.title}</span>
                  </div>
                `).join('') : `
                  <div style="text-align: center; padding: 16px; color: var(--muted-foreground); font-size: 13px;">
                    No tasks for today. Add some from the Schedule!
                  </div>
                `}
              </div>
            </div>
          </div>
          
          <!-- Feature 2: Space Widgets -->
          ${renderSpaceWidgets()}
        `;

  // === Upcoming Tasks - Card Grid Layout ===
  if (upcomingEvents.length > 0) {
    content += `
      <div style="margin-bottom: 48px;">
        <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 20px; color: var(--foreground);">Upcoming This Week</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 16px;">
          ${upcomingEvents.slice(0, 6).map(event => {
      const eventDate = normalizeDate(event.date);
      const isToday = eventDate.getTime() === today.getTime();
      const isTomorrow = eventDate.getTime() === new Date(today.getTime() + 86400000).getTime();
      const dayLabel = isToday ? 'Today' : isTomorrow ? 'Tomorrow' : eventDate.toLocaleDateString('en-US', { weekday: 'long' });
      const dateLabel = formatDate(event.date);
      const timeStr = event.time ? `<span style="color: var(--muted-foreground); margin-left: 8px;">• ${event.time}</span>` : '';
      const color = getEventColor(event.color || 'blue');

      return `
              <div class="card" style="padding: 20px; cursor: pointer; transition: all 0.2s; border: 1px solid var(--border);"
                   onclick="currentView = 'schedule'; setExpandedTask(${event.id}); renderCurrentView();">
                <div style="display: flex; align-items: center; margin-bottom: 12px;">
                  <div style="width: 12px; height: 12px; border-radius: 50%; background-color: ${color}; margin-right: 12px; flex-shrink: 0;"></div>
                  <span style="font-size: 13px; font-weight: 500; color: var(--muted-foreground); text-transform: uppercase; letter-spacing: 0.5px;">
                    ${dayLabel} • ${dateLabel}
                  </span>
                </div>
                <h4 style="font-size: 16px; font-weight: 600; margin: 0 0 8px; color: var(--foreground);">
                  ${event.title}
                </h4>
                <div style="font-size: 14px; color: var(--muted-foreground);">
                  ${timeStr}
                </div>
              </div>
            `;
    }).join('')}
        </div>
      </div>
    `;
  }

  // === Recent Project Activity - Simple Timeline ===
  if (recentActivity.length > 0) {
    content += `
      <div>
        <h3 style="font-size: 18px; font-weight: 600; margin: 48px 0 20px; color: var(--foreground);">Recent Activity</h3>
        <div style="border-left: 2px solid var(--border); padding-left: 24px;">
          ${recentActivity.slice(0, 8).map(item => `
            <div style="position: relative; padding-bottom: 20px;">
              <div style="position: absolute; left: -32px; top: 6px; width: 12px; height: 12px; border-radius: 50%; background: var(--primary); border: 3px solid var(--background);"></div>
              <div style="font-size: 14px; color: var(--foreground); margin-bottom: 4px;">${item.message}</div>
              <div style="font-size: 13px; color: var(--muted-foreground);">${formatTimeAgo(item.time)}</div>
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  content += `
        </div>
      </div>
      
      <!-- Summary of Today Sidebar (Right) -->
      <aside class="dashboard-ai-sidebar">
        <div class="ai-sidebar-header">
          <div class="ai-header-top">
            <div class="ai-sparkle-container">
              <svg class="icon ai-icon-glasses" viewBox="0 0 24 24" fill="none" stroke="url(#aiSidebarGradient)" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px;">
                <defs>
                  <linearGradient id="aiSidebarGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#6366f1">
                      <animate attributeName="stop-color" values="#6366f1;#8b5cf6;#3b82f6;#06b6d4;#6366f1" dur="6s" repeatCount="indefinite"/>
                    </stop>
                    <stop offset="50%" stop-color="#a855f7">
                      <animate attributeName="stop-color" values="#a855f7;#ec4899;#8b5cf6;#3b82f6;#a855f7" dur="6s" repeatCount="indefinite"/>
                    </stop>
                    <stop offset="100%" stop-color="#3b82f6">
                      <animate attributeName="stop-color" values="#3b82f6;#06b6d4;#6366f1;#8b5cf6;#3b82f6" dur="6s" repeatCount="indefinite"/>
                    </stop>
                  </linearGradient>
                </defs>
                <path d="M12 3L14.5 9L21 11.5L14.5 14L12 20L9.5 14L3 11.5L9.5 9L12 3Z" />
              </svg>
            </div>
            <span class="ai-title">Layer Intelligence</span>
          </div>
          <span class="ai-subtitle">Summary of Today • ${new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</span>
        </div>
        
        <div class="ai-content-area">
          <div class="ai-summary-card">
            <div class="ai-message" id="aiGreetingMessage" data-full-message="${aiMessage.replace(/"/g, '&quot;')}">
              <span class="ai-typing-text"></span>
              <span class="ai-cursor"></span>
            </div>
          </div>
        </div>

      </aside>
    </div>
  `;

  // Start typing animation after render
  setTimeout(() => {
    if (!dashboardAIShown) {
      startAITypingAnimation();
      dashboardAIShown = true;
    } else {
      // Show message immediately if already shown
      const msgEl = document.getElementById('aiGreetingMessage');
      if (msgEl) {
        const text = msgEl.dataset.fullMessage;
        const typingEl = msgEl.querySelector('.ai-typing-text');
        const cursorEl = msgEl.querySelector('.ai-cursor');
        if (typingEl) typingEl.textContent = text;
        if (cursorEl) cursorEl.style.display = 'none';
      }
    }

    // Initialize shared content widget
    initializeSharedContentWidget();
  }, 100);

  return content;
}

// Calculate streak days
function calculateStreak(events) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  let streak = 0;

  for (let i = 0; i < 365; i++) {
    const checkDate = new Date(today);
    checkDate.setDate(today.getDate() - i);
    const dateStr = checkDate.toISOString().split('T')[0];
    const hasCompleted = events.some(e => e.date === dateStr && e.completed);

    if (i === 0 && !hasCompleted) {
      // Today doesn't count against streak if not completed yet
      continue;
    }

    if (hasCompleted) {
      streak++;
    } else if (i > 0) {
      break;
    }
  }

  return streak;
}

// Toggle dashboard goal completion
async function toggleDashboardGoal(taskId) {
  const events = loadCalendarEvents();
  const idx = events.findIndex(e => e.id === taskId);
  if (idx !== -1) {
    const newCompleted = !events[idx].completed;
    // Use async update if authenticated
    await updateCalendarEventAsync(taskId, { completed: newCompleted });
    renderCurrentView();
  }
}

function generateAIGreeting(todayTasks, upcomingEvents, projects) {
  const hour = new Date().getHours();
  let greeting = 'Hello';
  if (hour < 12) greeting = 'Good morning';
  else if (hour < 18) greeting = 'Good afternoon';
  else greeting = 'Good evening';

  let message = `${greeting}. I've prepared your daily intelligence summary.\n\n`;

  // Today's Tasks
  message += `[Tasks] Focus for today:\n`;
  if (todayTasks.length === 0) {
    message += `Your schedule is clear for today. It's a perfect opportunity for deep work or planning.\n\n`;
  } else {
    todayTasks.slice(0, 4).forEach(task => {
      const timeStr = task.time ? ` at ${task.time}` : '';
      message += `• ${task.title}${timeStr}\n`;
    });
    if (todayTasks.length > 4) {
      message += `• ...and ${todayTasks.length - 4} other items\n`;
    }
    message += `\n`;
  }

  // Upcoming This Week
  const futureTasks = upcomingEvents.filter(e => e.date !== new Date().toISOString().split('T')[0]);
  message += `[Calendar] Coming up this week:\n`;
  if (futureTasks.length === 0) {
    message += `No immediate deadlines ahead. Stay proactive with your current projects.\n\n`;
  } else {
    futureTasks.slice(0, 3).forEach(task => {
      const eventDate = new Date(task.date);
      const dayLabel = eventDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
      message += `• ${task.title} — ${dayLabel}\n`;
    });
    message += `\n`;
  }

  // Projects Overview
  message += `[Projects] Current momentum:\n`;
  if (projects.length === 0) {
    message += `No active projects detected. Start one to track your milestones.\n\n`;
  } else {
    message += `You are currently managing ${projects.length} active project${projects.length > 1 ? 's' : ''}.\n\n`;
  }

  // Priority Tips
  message += `[Tip] Insight:\n`;
  if (todayTasks.length > 3) {
    message += `With a busy day ahead, focus on your high-impact tasks first to maintain momentum.`;
  } else if (todayTasks.length === 0 && futureTasks.length > 0) {
    message += `A quiet start to the day. Use this time to prepare for your upcoming milestones.`;
  } else {
    message += `Maintain focus and tackle your goals one step at a time. Quality over quantity today.`;
  }

  return message;
}

function startAITypingAnimation() {
  const msgEl = document.getElementById('aiGreetingMessage');
  if (!msgEl) return;

  const fullText = msgEl.dataset.fullMessage;
  const typingEl = msgEl.querySelector('.ai-typing-text');
  const cursorEl = msgEl.querySelector('.ai-cursor');

  if (!typingEl || !fullText) return;

  let charIndex = 0;
  const typingSpeed = 10; // Slightly faster for premium feel

  function typeChar() {
    if (charIndex < fullText.length) {
      let currentText = fullText.substring(0, charIndex + 1);

      // Handle formatting markers during typing or after?
      // For now, let's type the raw text and replace markers at the end
      typingEl.textContent = currentText;
      charIndex++;
      setTimeout(typeChar, typingSpeed);
    } else {
      // Done typing, process markers into beautiful tags
      let finalHTML = typingEl.textContent
        .replace(/\[Tasks\]/g, '<span class="ai-insight-tag">Today\'s Tasks</span>')
        .replace(/\[Calendar\]/g, '<span class="ai-insight-tag">Upcoming</span>')
        .replace(/\[Projects\]/g, '<span class="ai-insight-tag">Active Projects</span>')
        .replace(/\[Tip\]/g, '<span class="ai-insight-tag">Focus Tip</span>');

      typingEl.innerHTML = finalHTML;

      // Hide cursor after a moment
      setTimeout(() => {
        if (cursorEl) cursorEl.style.display = 'none';
      }, 800);
    }
  }

  typeChar();
}

function getEventColor(color) {
  const colors = {
    blue: 'hsl(217, 91%, 60%)',
    green: 'hsl(142, 71%, 45%)',
    purple: 'hsl(271, 91%, 65%)',
    orange: 'hsl(24, 90%, 60%)',
    red: 'hsl(0, 84%, 60%)'
  };
  return colors[color] || colors.blue;
}

// Helper function to get linked info display for events (project, assignment, space)
function getEventLinkedInfo(ev) {
  const links = [];

  // Add location first if exists
  if (ev.location) {
    links.push(`<span class="event-link-badge location-link" title="Location: ${ev.location}">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:10px;height:10px;">
        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
        <circle cx="12" cy="10" r="3"/>
      </svg>
      ${ev.location.length > 12 ? ev.location.substring(0, 10) + '...' : ev.location}
    </span>`);
  }

  if (ev.projectId) {
    const projects = loadProjects();
    // Use == for type coercion to handle string vs number IDs
    const project = projects.find(p => p.id == ev.projectId);
    if (project) {
      links.push(`<span class="event-link-badge project-link" title="Project: ${project.name}">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:10px;height:10px;">
          <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
        </svg>
        ${project.name.length > 10 ? project.name.substring(0, 8) + '...' : project.name}
      </span>`);
    }
  }

  if (ev.assignmentId) {
    const assignments = loadAssignments();
    // Use == for type coercion to handle string vs number IDs
    const assignment = assignments.find(a => a.id == ev.assignmentId);
    if (assignment) {
      links.push(`<span class="event-link-badge assignment-link" title="Assignment: ${assignment.title}">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:10px;height:10px;">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
          <polyline points="14 2 14 8 20 8"/>
        </svg>
        ${assignment.title.length > 10 ? assignment.title.substring(0, 8) + '...' : assignment.title}
      </span>`);
    }
  }

  if (ev.spaceId) {
    const spaces = typeof loadSpaces === 'function' ? loadSpaces() : [];
    // Use == for type coercion to handle string vs number IDs
    const space = spaces.find(s => s.id == ev.spaceId);
    if (space) {
      links.push(`<span class="event-link-badge space-link" title="Space: ${space.name}" style="--space-color: ${space.color || '#8b5cf6'};">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:10px;height:10px;">
          <rect x="3" y="3" width="18" height="18" rx="2"/>
          <path d="M3 9h18M9 21V9"/>
        </svg>
        ${space.name.length > 10 ? space.name.substring(0, 8) + '...' : space.name}
      </span>`);
    }
  }

  if (links.length === 0) return '';
  return `<div class="event-links-row">${links.join('')}</div>`;
}

// Generate options for project dropdown
function generateProjectOptions(selectedId = null) {
  const projects = loadProjects();
  let options = '<option value="">No project</option>';
  projects.forEach(p => {
    // Use == for type coercion to handle string vs number IDs
    const selected = p.id == selectedId ? 'selected' : '';
    options += `<option value="${p.id}" ${selected}>${p.name}</option>`;
  });
  return options;
}

// Generate options for assignment dropdown
function generateAssignmentOptions(selectedId = null) {
  const assignments = loadAssignments();
  let options = '<option value="">No assignment</option>';
  assignments.forEach(a => {
    // Use == for type coercion to handle string vs number IDs
    const selected = a.id == selectedId ? 'selected' : '';
    options += `<option value="${a.id}" ${selected}>${a.title}</option>`;
  });
  return options;
}

// Generate options for space dropdown
function generateSpaceOptions(selectedId = null) {
  const spaces = typeof loadSpaces === 'function' ? loadSpaces() : [];
  let options = '<option value="">No space</option>';
  spaces.forEach(s => {
    // Use == for type coercion to handle string vs number IDs
    const selected = s.id == selectedId ? 'selected' : '';
    options += `<option value="${s.id}" ${selected}>${s.name}</option>`;
  });
  return options;
}

// Toggle event links collapsible section
function toggleEventLinksSection() {
  const section = document.getElementById('eventLinksSection');
  const header = section?.previousElementSibling;
  if (section) {
    section.classList.toggle('collapsed');
    header?.classList.toggle('collapsed');
  }
}




/* ============================================
   Layer - My Issues View (with Delete Support)
   ============================================ */

function renderMyIssuesView(filter = 'all', searchQuery = '') {
  let issues = loadIssues();

  // Apply filter
  if (filter === 'open') {
    issues = issues.filter(issue => issue.status === 'todo');
  } else if (filter === 'in-progress') {
    issues = issues.filter(issue => issue.status === 'in-progress');
  } else if (filter === 'done') {
    issues = issues.filter(issue => issue.status === 'done');
  }

  // Apply search
  if (searchQuery) {
    const query = searchQuery.toLowerCase();
    issues = issues.filter(issue =>
      issue.title.toLowerCase().includes(query) ||
      (issue.description && issue.description.toLowerCase().includes(query))
    );
  }

  const filters = [
    { id: 'all', label: 'All' },
    { id: 'open', label: 'Open' },
    { id: 'in-progress', label: 'In Progress' },
    { id: 'done', label: 'Done' },
  ];

  // Helper for status styling
  const getStatusClass = (status) => {
    const map = { 'todo': 'status-todo', 'in-progress': 'status-inprogress', 'review': 'status-review', 'done': 'status-done' };
    return map[status] || 'status-todo';
  };

  // Helper for capitalization
  const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1).replace('-', ' ') : '';

  // Helper for priority badges
  const getPriorityBadge = (priority) => {
    const p = priority || 'medium';
    return `<span class="priority-badge ${p}">${capitalize(p)}</span>`;
  };

  // List Header
  const listHeader = `
    <div class="issues-list-header">
      <div class="col-id">ID</div>
      <div class="col-status">Status</div>
      <div class="col-title">Title</div>
      <div class="col-priority">Priority</div>
      <div class="col-date">Date</div>
      <div class="col-actions"></div>
    </div>
  `;

  // List Items
  const listItems = issues.map((issue, index) => `
    <div class="issue-list-item" onclick="openIssueDetailModal(${index})">
      <div class="col-id">#${issue.id}</div>
      <div class="col-status">
        <span class="status-dot ${getStatusClass(issue.status)}"></span>
        <span class="status-label">${capitalize(issue.status)}</span>
      </div>
      <div class="col-title">
        <span class="issue-title-text">${issue.title}</span>
      </div>
      <div class="col-priority">
        ${getPriorityBadge(issue.priority)}
      </div>
      <div class="col-date">
        ${new Date(issue.updated).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
      </div>
      <div class="col-actions">
        <button class="action-btn-icon" onclick="event.stopPropagation(); handleDeleteIssue(${index})" title="Delete">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18"></path><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
        </button>
      </div>
    </div>
  `).join('');

  // Main Render
  const inlineForm = renderInlineCreateIssueForm();

  if (issues.length === 0) {
    return `
      <div class="issues-container-modern">
        <!-- Minimal Toolbar -->
        <div class="issues-toolbar">
          <div class="issues-toolbar-left">
             <h2 class="view-title">Issues</h2>
             <div class="issues-count-badge">${issues.length}</div>
          </div>
          <div class="issues-toolbar-right">
             <div class="search-bar-minimal">
               <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
               <input type="text" placeholder="Filter..." value="${searchQuery}" oninput="renderMyIssuesView('${filter}', this.value)">
             </div>
             <div class="filter-group-minimal">
               ${filters.map(f => `
                 <button class="filter-btn-minimal ${filter === f.id ? 'active' : ''}" onclick="renderMyIssuesView('${f.id}', '${searchQuery}')">${f.label}</button>
               `).join('')}
             </div>
             <button class="btn-primary-small" onclick="toggleCreateIssueForm()">
               <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
               New Issue
             </button>
          </div>
        </div>

        <!-- Empty State with Embedded Form -->
        <div class="empty-state-minimal">
           <div id="emptyStateContent">
             <div class="empty-icon">
               <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><circle cx="12" cy="12" r="10"/><path d="M16 12l-4-4-4 4"/><path d="M12 16V8"/></svg>
             </div>
             <h3>No issues found</h3>
             <p>Get started by creating a new issue.</p>
             <button class="btn-text" onclick="toggleCreateIssueForm()">Create Issue</button>
           </div>
           ${inlineForm}
        </div>
      </div>
    `;
  }

  return `
    <div class="issues-container-modern">
      <!-- Minimal Toolbar -->
      <div class="issues-toolbar">
        <div class="issues-toolbar-left">
           <h2 class="view-title">Issues</h2>
           <div class="issues-count-badge">${issues.length}</div>
        </div>
        <div class="issues-toolbar-right">
           <div class="search-bar-minimal">
             <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
             <input type="text" placeholder="Filter..." value="${searchQuery}" oninput="renderMyIssuesView('${filter}', this.value)">
           </div>
           <div class="filter-group-minimal">
             ${filters.map(f => `
               <button class="filter-btn-minimal ${filter === f.id ? 'active' : ''}" onclick="renderMyIssuesView('${f.id}', '${searchQuery}')">${f.label}</button>
             `).join('')}
           </div>
           <button class="btn-primary-small" onclick="toggleCreateIssueForm()">
             <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
             New Issue
           </button>
        </div>
      </div>

      <!-- Inline Create Form (Hidden by default) -->
      ${inlineForm}

      <div class="issues-list-wrapper">
        ${listHeader}
        <div class="issues-list-body">
          ${listItems}
        </div>
      </div>
    </div>
  `;
  
  // Restore sidebar state
  restorePdSidebarState();
}

// New helper functions for inline form
function renderInlineCreateIssueForm() {
  return `
    <div id="inlineCreateIssueFormContainer" class="inline-issue-card" style="display: none;">
      <form id="inlineCreateIssueForm" onsubmit="handleInlineCreateIssueSubmit(event)">
        <div class="inline-card-header">
          <div class="inline-card-badge">New Issue</div>
          <button type="button" class="btn-close-minimal" onclick="toggleCreateIssueForm()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
          </button>
        </div>
        <div class="inline-card-body">
          <input type="text" name="title" class="inline-card-title-input" placeholder="What needs to be done?" required autocomplete="off">
          <textarea name="description" class="inline-card-desc-input" placeholder="Add a description..." rows="2"></textarea>
        </div>
        <div class="inline-card-footer">
          <div class="inline-card-tools">
            <div class="select-pill-wrapper">
              <span class="select-icon priority"></span>
              <select name="priority" class="select-pill" aria-label="Priority">
                <option value="low">Low</option>
                <option value="medium" selected>Medium</option>
                <option value="high">High</option>
              </select>
            </div>
            <div class="select-pill-wrapper">
              <span class="select-icon status"></span>
              <select name="status" class="select-pill" aria-label="Status">
                <option value="todo" selected>To Do</option>
                <option value="in-progress">In Progress</option>
                <option value="review">Review</option>
                <option value="done">Done</option>
              </select>
            </div>
          </div>
          <div class="inline-card-actions">
            <button type="button" class="btn-text-cancel" onclick="toggleCreateIssueForm()">Cancel</button>
            <button type="submit" class="btn-primary-create">Create Issue</button>
          </div>
        </div>
      </form>
    </div>
  `;

  if (window.LayerDB?.getDmChecklist) {
    (async () => {
      try {
        const record = await window.LayerDB.getDmChecklist(dmChecklistId);
        if (record && Array.isArray(record.items)) {
          const all = loadDmChecklists();
          all[String(dmChecklistId)] = record.items;
          try {
            localStorage.setItem(DM_CHECKLISTS_KEY, JSON.stringify(all));
          } catch (e) { }
          const latestQuery = document.getElementById('teamDmChecklistSearch')?.value || query || '';
          renderDmChecklistTab(dmChecklistId, latestQuery);
        }
      } catch (e) {
        console.error('Failed to load DM checklist from DB:', e);
      }
    })();
  }
}

window.renderDmChecklistTab = renderDmChecklistTab;
window.addDmChecklistItem = addDmChecklistItem;
window.toggleDmChecklistItem = toggleDmChecklistItem;
window.deleteDmChecklistItem = deleteDmChecklistItem;

const DM_CHECKLISTS_KEY = 'layerDmChecklists';
let currentDmChecklistSubscription = null;
let currentDmChecklistSubscriptionId = null;

function ensureDmChecklistDbSync(dmChecklistId) {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) return;

  // Subscribe once per checklist id
  if (currentDmChecklistSubscriptionId !== dmChecklistId) {
    if (currentDmChecklistSubscription && window.LayerDB?.unsubscribeFromDmChecklist) {
      try {
        window.LayerDB.unsubscribeFromDmChecklist(currentDmChecklistSubscription);
      } catch (e) { }
      currentDmChecklistSubscription = null;
    }
    currentDmChecklistSubscriptionId = dmChecklistId;

    if (window.LayerDB?.subscribeToDmChecklist) {
      currentDmChecklistSubscription = window.LayerDB.subscribeToDmChecklist(dmChecklistId, (payload) => {
        const { new: newRecord } = payload || {};
        if (newRecord && Array.isArray(newRecord.items)) {
          try {
            const all = loadDmChecklists();
            all[String(dmChecklistId)] = newRecord.items;
            localStorage.setItem(DM_CHECKLISTS_KEY, JSON.stringify(all));
          } catch (e) { }
          renderDmChecklistTab(dmChecklistId, document.getElementById('teamDmChecklistSearch')?.value || '');
        }
      });
    }
  }

  // Load latest items from DB once (will update cache + re-render)
  if (window.LayerDB?.getDmChecklist) {
    window.LayerDB.getDmChecklist(dmChecklistId).then((record) => {
      if (record && Array.isArray(record.items)) {
        const all = loadDmChecklists();
        all[String(dmChecklistId)] = record.items;
        try {
          localStorage.setItem(DM_CHECKLISTS_KEY, JSON.stringify(all));
        } catch (e) { }
        renderDmChecklistTab(dmChecklistId, document.getElementById('teamDmChecklistSearch')?.value || '');
      }
    }).catch((e) => {
      console.error('Failed to load DM checklist from DB:', e);
    });
  }
}

function isDMChannelId(channelId) {
  return !!channelId && channelId.toLowerCase().startsWith('dm-');
}

function getDmParticipantIdsFromChannelId(channelId) {
  if (!isDMChannelId(channelId)) return [];
  const channelWithoutPrefix = channelId.substring('dm-'.length);
  const uuidRegex = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi;
  const uuidMatches = channelWithoutPrefix.match(uuidRegex);
  return uuidMatches ? uuidMatches.map(id => id.toLowerCase()) : [];
}

function getDmChecklistId(channelId) {
  const ids = getDmParticipantIdsFromChannelId(channelId);
  if (ids.length < 1) return null;
  const sorted = [...new Set(ids)].sort();
  return `dm:${sorted.join(':')}`;
}

function getDmChecklistParticipantUUIDs(channelId) {
  const ids = getDmParticipantIdsFromChannelId(channelId);
  const uniqueSorted = [...new Set(ids)].sort();
  return uniqueSorted;
}

function loadDmChecklists() {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return {};
  }
  try {
    return JSON.parse(localStorage.getItem(DM_CHECKLISTS_KEY)) || {};
  } catch {
    return {};
  }
}

function getDmChecklistItems(dmChecklistId) {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return [];
  }
  const all = loadDmChecklists();
  return all[String(dmChecklistId)] || [];
}

async function saveDmChecklistItems(dmChecklistId, items) {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to save checklists', 'error');
    return;
  }
  const all = loadDmChecklists();
  all[String(dmChecklistId)] = items;
  try {
    localStorage.setItem(DM_CHECKLISTS_KEY, JSON.stringify(all));
  } catch (e) {
    console.error('Failed to save DM checklists:', e);
    showToast('Failed to save checklist', 'error');
  }

  try {
    if (window.LayerDB?.upsertDmChecklist) {
      const participantUUIDs = getDmChecklistParticipantUUIDs(teamCurrentChannel);
      if (participantUUIDs.length > 0) {
        await window.LayerDB.upsertDmChecklist(dmChecklistId, participantUUIDs, items);
      }
    }
  } catch (error) {
    console.error('Failed to sync DM checklist to database:', error);
  }
}

async function addDmChecklistItem(dmChecklistId, text) {
  if (!text || !text.trim()) return;
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to add checklist items', 'error');
    return;
  }

  const items = getDmChecklistItems(dmChecklistId);
  items.push({
    id: Date.now(),
    text: text.trim(),
    completed: false,
    createdAt: new Date().toISOString()
  });

  await saveDmChecklistItems(dmChecklistId, items);
  renderDmChecklistTab(dmChecklistId);
}

async function toggleDmChecklistItem(dmChecklistId, itemId) {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to update checklist items', 'error');
    return;
  }

  const items = getDmChecklistItems(dmChecklistId);
  const item = items.find(i => i.id === itemId);
  if (!item) return;
  item.completed = !item.completed;

  if (item.completed) {
    const currentUser = window.LayerDB.getCurrentUser();
    item.checked_by = {
      id: currentUser?.id,
      name: currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0] || 'You',
      avatar_url: currentUser?.user_metadata?.avatar_url,
      checked_at: new Date().toISOString()
    };
  } else {
    delete item.checked_by;
  }

  await saveDmChecklistItems(dmChecklistId, items);
  renderDmChecklistTab(dmChecklistId);
}

async function deleteDmChecklistItem(dmChecklistId, itemId) {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to update checklist items', 'error');
    return;
  }

  const items = getDmChecklistItems(dmChecklistId).filter(i => i.id !== itemId);
  await saveDmChecklistItems(dmChecklistId, items);
  renderDmChecklistTab(dmChecklistId);
}

function renderTeamListTabContent() {
  const channel = teamChannels.find(c => c.id === teamCurrentChannel) ||
    teamDirectMessages.find(d => d.id === teamCurrentChannel);
  const isDM = channel?.type === 'dm' || isDMChannelId(teamCurrentChannel);

  if (!isDM) {
    return `
      <div class="team-chat-content">
        <div class="team-list-tab-placeholder">
          <div class="team-list-tab-placeholder-title">Lists</div>
          <div class="team-list-tab-placeholder-subtitle">Select a direct message to manage a shared checklist.</div>
        </div>
      </div>
    `;
  }

  const dmChecklistId = getDmChecklistId(teamCurrentChannel);
  if (!dmChecklistId) {
    return `
      <div class="team-chat-content">
        <div class="team-list-tab-placeholder">
          <div class="team-list-tab-placeholder-title">Checklist</div>
          <div class="team-list-tab-placeholder-subtitle">Unable to determine DM participants for this conversation.</div>
        </div>
      </div>
    `;
  }

  setTimeout(() => {
    renderDmChecklistTab(dmChecklistId);
    ensureDmChecklistDbSync(dmChecklistId);
  }, 0);

  return `
    <div class="team-chat-content">
      <div class="team-dm-checklist" id="teamDmChecklistRoot" data-dm-checklist-id="${dmChecklistId}">
        <div class="team-dm-checklist-skeleton">
          <div class="team-dm-checklist-skeleton-header"></div>
          <div class="team-dm-checklist-skeleton-row"></div>
          <div class="team-dm-checklist-skeleton-row"></div>
          <div class="team-dm-checklist-skeleton-row"></div>
        </div>
      </div>
    </div>
  `;
}

function renderDmChecklistTab(dmChecklistId, query = '') {
  const root = document.getElementById('teamDmChecklistRoot');
  if (!root) return;

  const channel = teamChannels.find(c => c.id === teamCurrentChannel) ||
    teamDirectMessages.find(d => d.id === teamCurrentChannel);
  const channelName = channel ? channel.name : 'Direct Message';
  const items = getDmChecklistItems(dmChecklistId);

  // Note: DB subscription + initial load are handled by ensureDmChecklistDbSync(dmChecklistId)

  const normalizedQuery = (query || '').trim().toLowerCase();
  const filteredItems = normalizedQuery
    ? items.filter(i => (i.text || '').toLowerCase().includes(normalizedQuery))
    : items;

  const completedCount = items.filter(i => i.completed).length;
  const totalCount = items.length;
  const progressPercent = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;

  const dmChecklistIdEscaped = String(dmChecklistId).replace(/'/g, "\\'");

  root.innerHTML = `
    <div class="team-dm-checklist-header">
      <div class="team-dm-checklist-header-left">
        <div class="team-dm-checklist-title">Checklist</div>
        <div class="team-dm-checklist-subtitle">Shared with ${channelName}</div>
      </div>
      <div class="team-dm-checklist-header-right">
        <div class="team-dm-checklist-chip">${completedCount}/${totalCount} done</div>
      </div>
    </div>

    <div class="team-dm-checklist-toolbar">
      <div class="team-dm-checklist-search">
        <input type="text" id="teamDmChecklistSearch" placeholder="Search tasks..." value="${(query || '').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;')}" oninput="renderDmChecklistTab('${dmChecklistIdEscaped}', this.value)" />
      </div>
      <div class="team-dm-checklist-progress" aria-label="Progress">
        <div class="team-dm-checklist-progress-bar">
          <div class="team-dm-checklist-progress-fill" style="width:${progressPercent}%;"></div>
        </div>
        <div class="team-dm-checklist-progress-text">${progressPercent}%</div>
      </div>
    </div>

    <div class="team-dm-checklist-body">
      ${filteredItems.length > 0 ? `
        <div>
          ${filteredItems.map(item => {
    const itemId = item.id;
    const completed = item.completed;
    const checked_by = item.checked_by;
    const checkedByAvatar = checked_by?.avatar_url;
    const checkedByName = checked_by?.name || 'Someone';
    const checkedByInitial = checkedByName.charAt(0).toUpperCase();

    return `
      <div class="team-dm-checklist-item ${completed ? 'completed' : ''}" data-item-id="${itemId}">
        <div class="team-dm-checklist-checkbox" onclick="toggleDmChecklistItem('${dmChecklistIdEscaped}', ${itemId})">
          ${completed ? `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>` : ''}
        </div>
        <div class="team-dm-checklist-item-text">${item.text}</div>
        ${completed && checked_by ? `
          <div class="team-dm-checklist-checked-by" title="Checked by ${checkedByName}">
            ${checkedByAvatar
              ? `<img src="${checkedByAvatar}" alt="${checkedByName}" class="team-dm-checklist-checked-avatar" />`
              : `<div class="team-dm-checklist-checked-avatar-fallback">${checkedByInitial}</div>`
            }
          </div>
        ` : ''}
        <div class="team-dm-checklist-delete" onclick="deleteDmChecklistItem('${dmChecklistIdEscaped}', ${itemId})">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 6L6 18M6 6l12 12" />
          </svg>
        </div>
      </div>
    `;
  }).join('')}
        </div>
      ` : `
        <div class="team-dm-checklist-empty">
          <div class="team-dm-checklist-empty-title">No tasks</div>
          <div class="team-dm-checklist-empty-subtitle">Add a task to start tracking work with ${channelName}.</div>
        </div>
      `}
    </div>

    <div class="team-dm-checklist-footer">
      <input type="text" class="team-dm-checklist-add" placeholder="Add a task and press Enter" onkeypress="if(event.key==='Enter'){addDmChecklistItem('${dmChecklistIdEscaped}', this.value); this.value='';}" />
    </div>
  `;
}

function toggleCreateIssueForm() {
  const container = document.getElementById('inlineCreateIssueFormContainer');
  const emptyStateContent = document.getElementById('emptyStateContent');

  if (container) {
    const isHidden = container.style.display === 'none';
    container.style.display = isHidden ? 'block' : 'none';
    
    if (emptyStateContent) {
      emptyStateContent.style.display = isHidden ? 'none' : 'block';
    }

    if (isHidden) {
      const input = container.querySelector('input[name="title"]');
      if (input) setTimeout(() => input.focus(), 50);
      
      // If we are in empty state, maybe scroll to form?
      container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }
}

async function handleInlineCreateIssueSubmit(event) {
  event.preventDefault();
  const form = event.target;
  const formData = new FormData(form);

  const title = formData.get('title');
  const description = formData.get('description');
  const priority = formData.get('priority');
  const status = formData.get('status');

  if (title.trim()) {
    try {
      await addIssue({
        title: title.trim(),
        description: description.trim(),
        priority,
        status,
        assignee: 'Zeyad Maher'
      });
      form.reset();
      // Keep it hidden or open? User might want to create multiple. 
      // "Rectangle container under the button" - usually collapses on success.
      toggleCreateIssueForm();
      renderCurrentView();
    } catch (e) {
      console.error('Failed to create issue:', e);
      if (typeof showToast === 'function') {
        showToast('Failed to create issue', 'error');
      }
    }
  }
}

function openIssueDetailModal(index) {
  const issues = loadIssues();
  const issue = issues[index];
  if (!issue) return;

  const content = `
    <div class="issue-detail-modal">
      <div class="issue-detail-header">
        <span class="issue-detail-id">${issue.id}</span>
        <span class="badge ${getStatusBadgeClass(issue.status)}">${capitalizeStatus(issue.status)}</span>
      </div>
      <h3 class="issue-detail-title">${issue.title}</h3>
      ${issue.description ? `<p class="issue-detail-description">${issue.description}</p>` : '<p class="issue-detail-description muted">No description provided</p>'}
      <div class="issue-detail-meta">
        <div class="issue-meta-item">
          <span class="issue-meta-label">Priority</span>
          <span class="badge ${getPriorityBadgeClass(issue.priority)}">${issue.priority ? issue.priority.charAt(0).toUpperCase() + issue.priority.slice(1) : 'None'}</span>
        </div>
        <div class="issue-meta-item">
          <span class="issue-meta-label">Assignee</span>
          <span class="issue-meta-value">${issue.assignee || 'Unassigned'}</span>
        </div>
        <div class="issue-meta-item">
          <span class="issue-meta-label">Last Updated</span>
          <span class="issue-meta-value">${issue.updated}</span>
        </div>
      </div>
      <div class="issue-detail-actions">
        <button class="btn btn-secondary" onclick="closeModal()">Close</button>
        <button class="btn btn-primary" onclick="closeModal(); openEditIssueModal(${index})">Edit Issue</button>
      </div>
    </div>
  `;

  openModal('Issue Details', content);
}

function openEditIssueModal(index) {
  const issues = loadIssues();
  const issue = issues[index];
  if (!issue) return;

  const content = `
    <form id="editIssueForm" onsubmit="handleEditIssueSubmit(event, ${index})">
      <div class="form-group">
        <label class="form-label">Title <span class="required">*</span></label>
        <input type="text" name="title" class="form-input" value="${issue.title}" required>
      </div>
      <div class="form-group">
        <label class="form-label">Description</label>
        <textarea name="description" class="form-textarea">${issue.description || ''}</textarea>
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
        <div class="form-group">
          <label class="form-label">Priority</label>
          <select name="priority" class="form-select">
            <option value="low" ${issue.priority === 'low' ? 'selected' : ''}>Low</option>
            <option value="medium" ${issue.priority === 'medium' ? 'selected' : ''}>Medium</option>
            <option value="high" ${issue.priority === 'high' ? 'selected' : ''}>High</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">Status</label>
          <select name="status" class="form-select">
            <option value="todo" ${issue.status === 'todo' ? 'selected' : ''}>To Do</option>
            <option value="in-progress" ${issue.status === 'in-progress' ? 'selected' : ''}>In Progress</option>
            <option value="review" ${issue.status === 'review' ? 'selected' : ''}>Review</option>
            <option value="done" ${issue.status === 'done' ? 'selected' : ''}>Done</option>
          </select>
        </div>
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Save Changes</button>
      </div>
    </form>
  `;

  openModal('Edit Issue', content);
}

function handleEditIssueSubmit(event, index) {
  event.preventDefault();
  const form = event.target;
  const formData = new FormData(form);

  const issues = loadIssues();
  if (issues[index]) {
    issues[index] = {
      ...issues[index],
      title: formData.get('title').trim(),
      description: formData.get('description').trim(),
      priority: formData.get('priority'),
      status: formData.get('status'),
      updated: new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })
    };
    saveIssues(issues);
    closeModal();
    renderCurrentView();
  }
}

// ========================
// Delete Issue Handler
// ========================
function handleDeleteIssue(index) {
  const issues = loadIssues();
  const issue = issues[index];

  if (!issue) return;

  const confirmHTML = `
    <div style="padding: 24px; text-align: center;">
      <h3 style="margin: 0 0 16px; font-size: 18px; font-weight: 600; color: var(--foreground);">Delete Issue?</h3>
      <p style="margin: 0 0 24px; color: var(--muted-foreground); font-size: 14px; line-height: 1.5;">
        Are you sure you want to permanently delete this issue?<br><br>
        <strong>${issue.title}</strong><br>
        <code style="font-size: 13px; background: var(--surface); padding: 4px 8px; border-radius: 4px;">${issue.id}</code>
      </p>
      <div style="display: flex; gap: 12px; justify-content: center;">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-destructive" onclick="confirmDeleteIssue(${index})">Delete Issue</button>
      </div>
    </div>
  `;

  openModal('Delete Issue', confirmHTML);
}

async function confirmDeleteIssue(index) {
  try {
    await deleteIssue(index);
    closeModal();
    renderCurrentView();
  } catch (e) {
    console.error('Failed to delete issue:', e);
    if (typeof showNotification === 'function') {
      showNotification('Failed to delete issue', 'error');
    }
  }
}

// ========================
// Existing Functions (unchanged)
// ========================
function renderCreateIssueModalContent() {
  return `
    <form id="createIssueForm" onsubmit="handleCreateIssueSubmit(event)">
      <div class="form-group">
        <label class="form-label">Title <span class="required">*</span></label>
        <input type="text" name="title" class="form-input" placeholder="e.g. Add user profile picture upload" required>
      </div>
      
      <div class="form-group">
        <label class="form-label">Description</label>
        <textarea name="description" class="form-textarea" placeholder="Describe the issue, steps to reproduce, expected behavior..."></textarea>
      </div>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
        <div class="form-group">
          <label class="form-label">Priority</label>
          <select name="priority" class="form-select">
            <option value="low">Low</option>
            <option value="medium" selected>Medium</option>
            <option value="high">High</option>
          </select>
        </div>
        
        <div class="form-group">
          <label class="form-label">Status</label>
          <select name="status" class="form-select">
            <option value="todo" selected>To Do</option>
            <option value="in-progress">In Progress</option>
            <option value="review">Review</option>
            <option value="done">Done</option>
          </select>
        </div>
      </div>
      
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Create Issue</button>
      </div>
    </form>
  `;
}

function openCreateIssueModal() {
  openModal('Create New Issue', renderCreateIssueModalContent());
}

async function handleCreateIssueSubmit(event) {
  event.preventDefault();
  const form = event.target;
  const formData = new FormData(form);

  const title = formData.get('title');
  const description = formData.get('description');
  const priority = formData.get('priority');
  const status = formData.get('status');

  if (title.trim()) {
    try {
      await addIssue({
        title: title.trim(),
        description: description.trim(),
        priority,
        status,
        assignee: 'Zeyad Maher'
      });
      closeModal();
      renderCurrentView();
    } catch (e) {
      console.error('Failed to create issue:', e);
      if (typeof showToast === 'function') {
        showToast('Failed to create issue', 'error');
      } else if (typeof showNotification === 'function') {
        showNotification('Failed to create issue', 'error');
      }
    }
  }
}

function setupIssueFilterListeners() {
  const filterTabs = document.querySelectorAll('.filter-tab');
  filterTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      currentFilter = tab.dataset.filter;
      renderCurrentView();
    });
  });
}



/* ============================================
   Layer - Backlog View (Professional Layout with Features)
   ============================================ */

// Backlog feature removed (view and handlers)



/* ============================================
   Layer - PROFESSIONAL Google Calendar Clone
   Advanced Schedule System with Full Features
   ============================================ */

let currentCalendarMonth = new Date();
const EVENTS_KEY = 'layerCalendarEvents';
const EXPANDED_KEY = 'layerCalendarExpandedTask';
const CALENDAR_SETTINGS_KEY = 'layerCalendarSettings';

// Enhanced Event Categories (Google Calendar style)
const EVENT_CATEGORIES = [
  { id: 'default', name: 'Default', color: '#3b82f6', icon: 'calendar' },
  { id: 'work', name: 'Work', color: '#ef4444', icon: 'briefcase' },
  { id: 'personal', name: 'Personal', color: '#22c55e', icon: 'user' },
  { id: 'meeting', name: 'Meeting', color: '#8b5cf6', icon: 'users' },
  { id: 'deadline', name: 'Deadline', color: '#f59e0b', icon: 'flag' },
  { id: 'reminder', name: 'Reminder', color: '#06b6d4', icon: 'bell' },
  { id: 'birthday', name: 'Birthday', color: '#ec4899', icon: 'cake' },
  { id: 'holiday', name: 'Holiday', color: '#10b981', icon: 'sun' },
  { id: 'focus', name: 'Focus Time', color: '#6366f1', icon: 'zap' },
  { id: 'travel', name: 'Travel', color: '#14b8a6', icon: 'plane' }
];

// Reminder presets (minutes before)
const REMINDER_PRESETS = [
  { value: 0, label: 'At time of event' },
  { value: 5, label: '5 minutes before' },
  { value: 10, label: '10 minutes before' },
  { value: 15, label: '15 minutes before' },
  { value: 30, label: '30 minutes before' },
  { value: 60, label: '1 hour before' },
  { value: 120, label: '2 hours before' },
  { value: 1440, label: '1 day before' },
  { value: 2880, label: '2 days before' },
  { value: 10080, label: '1 week before' }
];

// Recurrence patterns
const RECURRENCE_PATTERNS = [
  { value: 'none', label: 'Does not repeat' },
  { value: 'daily', label: 'Daily' },
  { value: 'weekly', label: 'Weekly' },
  { value: 'biweekly', label: 'Every 2 weeks' },
  { value: 'monthly', label: 'Monthly' },
  { value: 'yearly', label: 'Yearly' },
  { value: 'weekdays', label: 'Every weekday (Mon-Fri)' },
  { value: 'custom', label: 'Custom...' }
];

// Calendar Settings
let calendarSettings = loadCalendarSettings();

function loadCalendarSettings() {
  try {
    return JSON.parse(localStorage.getItem(CALENDAR_SETTINGS_KEY)) || {
      weekStartsOn: 1, // 0 = Sunday, 1 = Monday
      defaultView: 'week',
      showWeekNumbers: false,
      timeFormat: '12h',
      defaultEventDuration: 60,
      showDeclinedEvents: false,
      enableNotifications: true,
      workingHours: { start: '09:00', end: '17:00' },
      defaultReminder: 30
    };
  } catch { return {}; }
}

function saveCalendarSettings(settings) {
  calendarSettings = settings;
  localStorage.setItem(CALENDAR_SETTINGS_KEY, JSON.stringify(settings));
}

// Calendar events - use cached localStorage data
// Data is synced from Supabase on login
function loadCalendarEvents() {
  try { return JSON.parse(localStorage.getItem(EVENTS_KEY)) || []; }
  catch { return []; }
}

function saveCalendarEvents(events) {
  localStorage.setItem(EVENTS_KEY, JSON.stringify(events));
}

// Initialize calendar events from DB on page load
async function initCalendarEventsFromDB() {
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      const events = await window.LayerDB.loadCalendarEvents();
      saveCalendarEvents(events);
      return events;
    } catch (error) {
      console.error('Failed to load calendar events from database:', error);
    }
  }
  return loadCalendarEvents();
}

// Async function to save a single event to DB and update cache
async function saveCalendarEventAsync(eventData) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create events', 'error');
    return loadCalendarEvents();
  }

  try {
    await window.LayerDB.saveCalendarEvent(eventData);
    // Reload from DB and update cache
    const events = await window.LayerDB.loadCalendarEvents();
    saveCalendarEvents(events);
    return events;
  } catch (error) {
    console.error('Failed to save calendar event to database:', error);
    showToast('Failed to save event', 'error');
    return loadCalendarEvents();
  }
}

// Async function to update event in DB - optimistic update for instant UI response
async function updateCalendarEventAsync(eventId, updates) {
  // OPTIMISTIC UPDATE: Apply changes to localStorage immediately for instant UI
  const events = loadCalendarEvents();
  const index = events.findIndex(e => e.id === eventId || e.id == eventId);
  if (index !== -1) {
    events[index] = { ...events[index], ...updates };
    saveCalendarEvents(events);
  }

  // Sync with database in background (non-blocking)
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    window.LayerDB.updateCalendarEvent(eventId, updates)
      .then(dbEvents => {
        // Optionally sync back if needed
        if (dbEvents) saveCalendarEvents(dbEvents);
      })
      .catch(error => {
        console.error('Failed to update calendar event in database:', error);
        // Optimistic update already applied, so UI remains responsive
      });
  }

  return events;
}

// Async function to delete event from DB
async function deleteCalendarEventAsync(eventId) {
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      const events = await window.LayerDB.deleteCalendarEvent(eventId);
      saveCalendarEvents(events);
      return events;
    } catch (error) {
      console.error('Failed to delete calendar event from database:', error);
    }
  }
  // Fallback to localStorage
  const events = loadCalendarEvents();
  const index = events.findIndex(e => e.id === eventId || e.id == eventId);
  if (index !== -1) {
    events.splice(index, 1);
    saveCalendarEvents(events);
  }
  return events;
}

// Async function to delete all recurring events
async function deleteRecurringEventsAsync(recurringId) {
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      const events = await window.LayerDB.deleteRecurringEvents(recurringId);
      saveCalendarEvents(events);
      return events;
    } catch (error) {
      console.error('Failed to delete recurring events from database:', error);
    }
  }
  // Fallback to localStorage
  const events = loadCalendarEvents();
  const filtered = events.filter(e => e.recurringId !== recurringId);
  saveCalendarEvents(filtered);
  return filtered;
}

// Load calendar events from Supabase on auth
async function syncCalendarEventsFromDB() {
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      const events = await window.LayerDB.loadCalendarEvents();
      saveCalendarEvents(events);
      return events;
    } catch (error) {
      console.error('Failed to load calendar events from database:', error);
    }
  }
  return loadCalendarEvents();
}

// Generate unique event ID
function generateEventId() {
  return `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// Create enhanced event object
function createEnhancedEvent(data) {
  return {
    id: generateEventId(),
    title: data.title || 'Untitled Event',
    description: data.description || '',
    date: data.date,
    endDate: data.endDate || data.date,
    time: data.time || null,
    endTime: data.endTime || null,
    isAllDay: data.isAllDay || false,
    category: data.category || 'default',
    color: data.color || EVENT_CATEGORIES[0].color,
    location: data.location || '',
    attendees: data.attendees || [],
    reminders: data.reminders || [calendarSettings.defaultReminder || 30],
    recurrence: data.recurrence || 'none',
    recurrenceEnd: data.recurrenceEnd || null,
    isRecurring: data.isRecurring || false,
    recurringId: data.recurringId || null,
    status: data.status || 'confirmed', // confirmed, tentative, cancelled
    visibility: data.visibility || 'default', // default, public, private
    notes: data.notes || '',
    attachments: data.attachments || [],
    created: new Date().toISOString(),
    updated: new Date().toISOString(),
    // Google Calendar-like fields
    conferenceLink: data.conferenceLink || '',
    guestsCanModify: data.guestsCanModify || false,
    guestsCanSeeOtherGuests: data.guestsCanSeeOtherGuests || true,
    projectId: data.projectId || null,
    spaceId: data.spaceId || null
  };
}

function loadExpandedTaskId() {
  try {
    const raw = localStorage.getItem(EXPANDED_KEY);
    if (!raw) return null;
    const id = Number(raw);
    return Number.isFinite(id) ? id : null;
  } catch {
    return null;
  }
}

function saveExpandedTaskId(id) {
  if (id === null) {
    localStorage.removeItem(EXPANDED_KEY);
  } else {
    localStorage.setItem(EXPANDED_KEY, id.toString());
  }
}

function setExpandedTask(eventId) {
  const current = loadExpandedTaskId();
  const newId = (current === eventId) ? null : eventId;
  saveExpandedTaskId(newId);
  // Preserve scroll when toggling task expansion
  renderCurrentView(true);
}

function deleteTask(eventId) {
  openDeleteTaskModal(eventId);
}

function openDeleteTaskModal(eventId) {
  const events = loadCalendarEvents();
  // Use == for type coercion (eventId may be string or number)
  const task = events.find(e => e.id == eventId);
  if (!task) return;

  // Non-recurring: show inline confirmation
  if (!task.isRecurring || !task.recurringId) {
    showInlineDeleteConfirmation(eventId, task);
    return;
  }

  const content = `
    <div style="padding: 20px; text-align: center;">
      <h3 style="margin: 0 0 10px; font-size: 18px; font-weight: 600; color: var(--foreground);">Delete recurring task?</h3>
      <p style="margin: 0 0 18px; color: var(--muted-foreground); font-size: 14px; line-height: 1.5;">
        <strong>${task.title}</strong><br/>
        This task repeats weekly. What do you want to delete?
      </p>
      <div class="form-actions" style="justify-content: center;">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-secondary" onclick="confirmDeleteTaskOccurrence(${eventId})">Only this date</button>
        <button class="btn btn-destructive" onclick="confirmDeleteTaskSeries(${task.recurringId})">All weekly repeats</button>
      </div>
    </div>
  `;

  openModal('Delete task', content);
}

function showInlineDeleteConfirmation(eventId, task) {
  // First, hide the context menu if it's open
  hideTaskContextMenu();
  
  // Find the task element that triggered the delete
  const taskElement = document.querySelector(`[onclick*="openEditTaskModal('${eventId}')"]:not(button), [data-event-id="${eventId}"]`);
  
  // If not found, try agenda event card
  let targetElement = taskElement || document.querySelector(`.agenda-event-card[onclick*="openEditTaskModal('${eventId}')"]`);
  
  // If still not found, try to find by context menu trigger
  if (!targetElement) {
    // Try to find the closest event card from the context menu
    const contextMenu = document.getElementById('taskContextMenu');
    if (contextMenu) {
      // Find the element that was right-clicked
      // This is harder to track, so we'll create a temporary overlay
      createFloatingConfirmation(eventId, task);
      return;
    }
  }
  
  if (targetElement) {
    // Create confirmation container
    const confirmContainer = document.createElement('div');
    confirmContainer.className = 'inline-delete-confirmation';
    confirmContainer.style.cssText = `
      position: absolute;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      font-size: 14px;
      color: var(--foreground);
      min-width: 200px;
    `;
    
    confirmContainer.innerHTML = `
      <div style="margin-bottom: 12px;">Delete this task permanently?</div>
      <div style="display: flex; gap: 8px;">
        <button class="btn btn-sm btn-secondary" style="flex: 1; padding: 6px 12px; font-size: 12px;" onclick="cancelInlineDeleteConfirmation(this)">Cancel</button>
        <button class="btn btn-sm btn-destructive" style="flex: 1; padding: 6px 12px; font-size: 12px;" onclick="confirmInlineDelete('${eventId}', this)">Delete</button>
      </div>
    `;
    
    // Position the confirmation near the task
    const rect = targetElement.getBoundingClientRect();
    document.body.appendChild(confirmContainer);
    
    // Position to the right of the task element
    const top = rect.top + window.scrollY;
    const left = rect.right + 5 + window.scrollX;
    
    confirmContainer.style.top = top + 'px';
    confirmContainer.style.left = left + 'px';
    
    // Store reference to original element
    confirmContainer.setAttribute('data-original-element', targetElement.outerHTML.substring(0, 50));
  } else {
    // Fallback: create floating confirmation
    createFloatingConfirmation(eventId, task);
  }
}

function createFloatingConfirmation(eventId, task) {
  // Create a semi-transparent overlay
  const overlay = document.createElement('div');
  overlay.id = 'delete-confirmation-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0,0,0,0.5);
    z-index: 999;
    display: flex;
    justify-content: center;
    align-items: center;
  `;
  
  // Create confirmation container
  const confirmContainer = document.createElement('div');
  confirmContainer.className = 'inline-delete-confirmation';
  confirmContainer.style.cssText = `
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    z-index: 1000;
    font-size: 15px;
    color: var(--foreground);
    min-width: 280px;
    max-width: 400px;
  `;
  
  confirmContainer.innerHTML = `
    <div style="margin-bottom: 16px;"><strong>Delete this task permanently?</strong></div>
    <div style="margin-bottom: 20px; color: var(--muted-foreground); font-size: 14px;">"${task.title}"</div>
    <div style="display: flex; gap: 12px;">
      <button class="btn btn-secondary" style="flex: 1;" onclick="cancelInlineDeleteConfirmation(this)">Cancel</button>
      <button class="btn btn-destructive" style="flex: 1;" onclick="confirmInlineDelete('${eventId}', this)">Delete</button>
    </div>
  `;
  
  overlay.appendChild(confirmContainer);
  document.body.appendChild(overlay);
  
  // Close on click outside
  overlay.addEventListener('click', function(e) {
    if (e.target === overlay) {
      cancelInlineDeleteConfirmation();
    }
  });
}

function cancelInlineDeleteConfirmation(element) {
  // Remove confirmation container and overlay
  const containers = document.querySelectorAll('.inline-delete-confirmation, #delete-confirmation-overlay');
  containers.forEach(container => container.remove());
}

async function confirmInlineDelete(eventId, element) {
  // Remove confirmation first to avoid UI conflicts
  cancelInlineDeleteConfirmation();
  
  // Perform the actual deletion
  await deleteSingleCalendarEvent(eventId);
  
  // Refresh the view after deletion is complete
  renderCurrentView(true);
}

async function deleteSingleCalendarEvent(eventId) {
  // Use async delete if authenticated
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    await deleteCalendarEventAsync(eventId);
  } else {
    let events = loadCalendarEvents();
    // Use != for type coercion (eventId may be string or number)
    events = events.filter(e => e.id != eventId);
    saveCalendarEvents(events);
  }

  if (loadExpandedTaskId() === eventId) {
    saveExpandedTaskId(null);
  }
}

async function confirmDeleteTaskOccurrence(eventId) {
  await deleteSingleCalendarEvent(eventId);
  closeModal();
  // Preserve scroll when deleting occurrence
  renderCurrentView(true);
}

async function confirmDeleteTaskSeries(recurringId) {
  // Remove the recurring rule
  let rules = loadRecurringTasks();
  rules = rules.filter(r => r.id !== recurringId);
  saveRecurringTasks(rules);

  // Remove all generated instances - use async if authenticated
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    await deleteRecurringEventsAsync(recurringId);
  } else {
    let events = loadCalendarEvents();
    events = events.filter(e => e.recurringId !== recurringId);
    saveCalendarEvents(events);
  }

  // Collapse any expanded task (safe + simple)
  saveExpandedTaskId(null);

  closeModal();
  // Preserve scroll when deleting series
  renderCurrentView(true);
}

// NEW: Edit task modal
function openEditTaskModal(eventId) {
  const events = loadCalendarEvents();
  // Use == for type coercion (eventId may be string or number)
  const task = events.find(e => e.id == eventId);
  if (!task) return;

  const startTime = task.time || '';
  const endTime = task.endTime || '';
  const duration = calculateDuration(startTime, endTime);
  const locationValue = task.location || '';
  const dateValue = task.date || new Date().toISOString().split('T')[0];

  const content = `
    <div class="event-dropdown-form" id="eventDropdownForm">
      <div class="modal-content">
        <form id="editEventForm">
      <div class="form-group">
        <label>Title <span class="required">*</span></label>
        <input type="text" name="title" class="form-input" value="${task.title}" required>
      </div>
      
      <div class="form-group">
        <label>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;">
            <rect x="3" y="4" width="18" height="18" rx="2"/>
            <path d="M16 2v4M8 2v4M3 10h18"/>
          </svg>
          Date <span class="required">*</span>
        </label>
        <input type="date" name="date" class="form-input" value="${dateValue}" required>
      </div>
      
      <div class="form-group">
        <label>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;">
            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
            <circle cx="12" cy="10" r="3"/>
          </svg>
          Location
        </label>
        <input type="text" name="location" class="form-input" value="${locationValue}" placeholder="Add location...">
      </div>
      
      <div class="time-picker-group">
        <div class="time-picker-group-header">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
          </svg>
          Time
        </div>
        
        <div class="time-picker-row">
          <span class="time-picker-label">From</span>
          <div class="time-picker-select-wrapper">
            <select id="eventStartTime" name="startTime" class="time-picker-select" onchange="setDefaultEndTime()">
              <option value="">No time</option>
              ${generateTimeOptions(startTime)}
            </select>
          </div>
          <span class="time-picker-divider">→</span>
          <div class="time-picker-select-wrapper">
            <select id="eventEndTime" name="endTime" class="time-picker-select" onchange="updateDurationHint()">
              <option value="">No time</option>
              ${generateTimeOptions(endTime)}
            </select>
          </div>
        </div>
        
        <div class="time-duration-hint" id="durationHint">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
          </svg>
          <span>${duration ? `Duration: ${duration}` : 'Select time'}</span>
        </div>
        
        <div class="quick-duration-btns">
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(30)">30 min</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(60)">1 hour</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(90)">1.5 hours</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(120)">2 hours</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(180)">3 hours</button>
        </div>
      </div>
      
      <div class="form-group">
        <label>Color</label>
        <select name="color" class="form-select">
          <option value="blue" ${task.color === 'blue' ? 'selected' : ''}>Blue</option>
          <option value="green" ${task.color === 'green' ? 'selected' : ''}>Green</option>
          <option value="purple" ${task.color === 'purple' ? 'selected' : ''}>Purple</option>
          <option value="orange" ${task.color === 'orange' ? 'selected' : ''}>Orange</option>
          <option value="red" ${task.color === 'red' ? 'selected' : ''}>Red</option>
        </select>
      </div>
      
      <!-- Link to Project, Assignment, or Space -->
      <div class="form-group-collapsible">
        <div class="form-collapsible-header collapsed" onclick="toggleEventLinksSection()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
          </svg>
          <span>Link to Project / Assignment / Space</span>
          <svg class="form-collapsible-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
            <path d="M6 9l6 6 6-6"/>
          </svg>
        </div>
        <div class="form-collapsible-content collapsed" id="eventLinksSection">
          <div class="form-row-triple">
            <div class="form-group-inline">
              <label>Project</label>
              <select name="projectId" class="form-select form-select-sm">
                ${generateProjectOptions(task.projectId)}
              </select>
            </div>
            <div class="form-group-inline">
              <label>Assignment</label>
              <select name="assignmentId" class="form-select form-select-sm">
                ${generateAssignmentOptions(task.assignmentId)}
              </select>
            </div>
            <div class="form-group-inline">
              <label>Space</label>
              <select name="spaceId" class="form-select form-select-sm">
                ${generateSpaceOptions(task.spaceId)}
              </select>
            </div>
          </div>
        </div>
      </div>
      
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeEventDropdown()">Cancel</button>
        <button type="submit" class="btn btn-primary">Save Changes</button>
      </div>
    </form>
      </div>
    </div>
  `;

  // Add dropdown to body
  document.body.insertAdjacentHTML('beforeend', content);

  // Position the dropdown in the center of the screen
  const dropdown = document.getElementById('eventDropdownForm');
  if (dropdown) {
    dropdown.style.position = 'fixed';
    dropdown.style.left = '50%';
    dropdown.style.top = '50%';
    dropdown.style.transform = 'translate(-50%, -50%)';
    dropdown.style.zIndex = '10000';
  }

  // Add click listener to close dropdown when clicking outside
  setTimeout(() => {
    document.addEventListener('click', handleDropdownClickOutside);
  }, 10);

  // Attach event listener after modal is opened
  setTimeout(() => {
    const form = document.getElementById('editEventForm');
    if (form) {
      form.addEventListener('submit', (e) => handleEditEventSubmit(e, eventId));
    }
  }, 0);
}

async function handleEditEventSubmit(e, eventId) {
  e.preventDefault();
  e.stopPropagation();

  const form = e.target;
  const data = new FormData(form);

  const title = data.get('title')?.trim();
  const date = data.get('date');
  const startTime = data.get('startTime');
  const endTime = data.get('endTime');
  const color = data.get('color') || 'blue';
  const location = data.get('location')?.trim() || null;

  // Handle project/assignment/space IDs - convert empty strings to null
  const projectIdValue = data.get('projectId');
  const projectId = projectIdValue && projectIdValue !== '' ? projectIdValue : null;

  const assignmentIdValue = data.get('assignmentId');
  const assignmentId = assignmentIdValue && assignmentIdValue !== '' ? assignmentIdValue : null;

  const spaceIdValue = data.get('spaceId');
  const spaceId = spaceIdValue && spaceIdValue !== '' ? spaceIdValue : null;

  if (!title || !date) return;

  const updates = {
    title,
    date,
    time: startTime || null,
    endTime: endTime || null,
    color,
    location,
    projectId,
    assignmentId,
    spaceId
  };

  // Use async update if authenticated
  await updateCalendarEventAsync(eventId, updates);

  closeModal();
  // Preserve scroll when editing task
  renderCurrentView(true);
}


// Recurring Tasks Storage
const RECURRING_KEY = 'layerRecurringTasks';

function loadRecurringTasks() {
  try { return JSON.parse(localStorage.getItem(RECURRING_KEY)) || []; }
  catch { return []; }
}

function saveRecurringTasks(tasks) {
  localStorage.setItem(RECURRING_KEY, JSON.stringify(tasks));
}

function addRecurringTask(taskData) {
  const tasks = loadRecurringTasks();
  tasks.push({ id: Date.now(), ...taskData });
  saveRecurringTasks(tasks);
  applyRecurringTasks();
  renderCurrentView();
}

async function deleteRecurringTask(id) {
  let tasks = loadRecurringTasks();
  tasks = tasks.filter(t => t.id !== id);
  saveRecurringTasks(tasks);

  // Also purge generated instances from the calendar - use async if authenticated
  await deleteRecurringEventsAsync(id);

  // If an instance was expanded, collapse it
  saveExpandedTaskId(null);

  renderCurrentView();
}

function applyRecurringTasks() {
  const recurring = loadRecurringTasks();
  let events = loadCalendarEvents();
  const today = new Date();

  // Generate events for next 60 days
  for (let i = 0; i < 60; i++) {
    const date = new Date(today);
    date.setDate(today.getDate() + i);
    const dayOfWeek = date.getDay();
    const dateStr = date.toISOString().split('T')[0];

    recurring.forEach(task => {
      if (task.days && task.days.includes(dayOfWeek)) {
        // Check if event already exists for this date and recurringId
        const exists = events.some(e =>
          e.recurringId === task.id &&
          e.date === dateStr &&
          e.isRecurring === true
        );
        if (!exists) {
          // Calculate end time if start time exists (default 1 hour duration)
          let endTime = null;
          if (task.time) {
            const [h, m] = task.time.split(':').map(Number);
            const endH = (h + 1) % 24;
            endTime = `${String(endH).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
          }

          events.push({
            id: Date.now() + i + Math.floor(Math.random() * 1000000),
            title: task.title,
            date: dateStr,
            time: task.time || null,
            endTime: endTime,
            color: task.color || 'blue',
            isRecurring: true,
            recurringId: task.id,
            location: task.location || null
          });
        }
      }
    });
  }
  saveCalendarEvents(events);
}

function openAddRecurringModal() {
  const content = `
    <form id="recurringForm" onsubmit="handleAddRecurringSubmit(event)">
      <div class="form-group">
        <label class="form-label">Task Title <span class="required">*</span></label>
        <input type="text" name="title" class="form-input" required placeholder="Daily standup, Weekly review...">
      </div>
      <div class="form-group">
        <label class="form-label">Time (optional)</label>
        <input type="time" name="time" class="form-input">
      </div>
      <div class="form-group">
        <label class="form-label">Repeat on</label>
        <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
          ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, i) => `
            <label class="recurring-day-label" style="
              display: flex; align-items: center; gap: 6px; padding: 8px 12px;
              background: var(--surface); border: 1px solid var(--border);
              border-radius: 8px; cursor: pointer; transition: all 0.2s;
            ">
              <input type="checkbox" name="days" value="${i}" style="accent-color: var(--primary);">
              <span style="font-size: 13px; font-weight: 500;">${day}</span>
            </label>
          `).join('')}
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Color</label>
        <select name="color" class="form-select">
          <option value="blue">Blue</option>
          <option value="green">Green</option>
          <option value="purple">Purple</option>
          <option value="orange">Orange</option>
          <option value="red">Red</option>
        </select>
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Add Recurring Task</button>
      </div>
    </form>
  `;
  openModal('Add Recurring Task', content);
}

function handleAddRecurringSubmit(e) {
  e.preventDefault();
  const form = e.target;
  const data = new FormData(form);
  const title = data.get('title')?.trim();
  const time = data.get('time');
  const color = data.get('color');
  const days = data.getAll('days').map(d => parseInt(d));

  if (!title || days.length === 0) {
    alert('Please enter a title and select at least one day');
    return;
  }

  addRecurringTask({ title, time: time || null, color, days });
  closeModal();
}

/* ============================================
   Layer - ADVANCED Schedule / Calendar View
   Professional Week View with Time Slots, Mini Calendar,
   Categories, Filters, and Advanced Features
   ============================================ */

// Schedule View State - Extended with Agenda and Year views
let scheduleViewMode = 'week'; // 'day', 'week', 'month', 'agenda', 'year'
let scheduleCurrentDate = new Date();
let scheduleSelectedDate = new Date();
let scheduleFilters = {
  mySchedule: ['daily-standup', 'weekly-review', 'team-meeting', 'lunch-break', 'client-meeting', 'other'],
  searchQuery: '',
  showCancelled: false
};
let scheduleMyScheduleCollapsed = false;
let calendarQuickAddOpen = false;
let calendarKeyboardShortcutsEnabled = true;

// My Schedule presets
const MY_SCHEDULE_PRESETS = [
  { id: 'daily-standup', name: 'Daily Standup', checked: true },
  { id: 'weekly-review', name: 'Weekly Review', checked: true },
  { id: 'team-meeting', name: 'Team Meeting', checked: true },
  { id: 'lunch-break', name: 'Lunch Break', checked: true },
  { id: 'client-meeting', name: 'Client Meeting', checked: true },
  { id: 'other', name: 'Other', checked: true }
];

// Time slots for week view (6 AM to 6 AM - full 24 hours)
const TIME_SLOTS = [];
for (let i = 0; i < 24; i++) {
  const h = (i + 6) % 24; // Start at 6 AM, wrap around
  const hour12 = h === 0 ? 12 : (h > 12 ? h - 12 : h);
  const ampm = h >= 12 ? 'PM' : 'AM';
  TIME_SLOTS.push({ hour: h, label: `${hour12.toString().padStart(2, '0')} ${ampm}` });
}

// ============================================


// ============================================
// Quick Add Bar (Google Calendar style)
// ============================================
function openCalendarQuickAdd() {
  calendarQuickAddOpen = true;
  renderCurrentView();
  setTimeout(() => {
    const input = document.getElementById('quickAddInput');
    if (input) input.focus();
  }, 100);
}

function closeCalendarQuickAdd() {
  calendarQuickAddOpen = false;
  renderCurrentView();
}

async function handleQuickAddSubmit(e) {
  e.preventDefault();
  const input = document.getElementById('quickAddInput');
  if (!input) return;

  const text = input.value.trim();
  if (!text) return;

  // Parse natural language input (e.g., "Meeting tomorrow at 3pm")
  const parsedEvent = parseNaturalLanguageEvent(text);

  const newEvent = createEnhancedEvent(parsedEvent);

  // Use async save if authenticated
  await saveCalendarEventAsync(newEvent);

  closeCalendarQuickAdd();
  showToast(`Event "${parsedEvent.title}" created`);
  renderCurrentView();
}

// Natural language event parser
function parseNaturalLanguageEvent(text) {
  const today = new Date();
  let title = text;
  let date = today.toISOString().split('T')[0];
  let time = null;
  let endTime = null;

  // Parse "tomorrow"
  if (/\btomorrow\b/i.test(text)) {
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    date = tomorrow.toISOString().split('T')[0];
    title = title.replace(/\btomorrow\b/i, '').trim();
  }

  // Parse "next week"
  if (/\bnext week\b/i.test(text)) {
    const nextWeek = new Date(today);
    nextWeek.setDate(nextWeek.getDate() + 7);
    date = nextWeek.toISOString().split('T')[0];
    title = title.replace(/\bnext week\b/i, '').trim();
  }

  // Parse day names
  const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
  const dayMatch = text.match(new RegExp(`\\b(${dayNames.join('|')})\\b`, 'i'));
  if (dayMatch) {
    const targetDay = dayNames.indexOf(dayMatch[1].toLowerCase());
    const currentDay = today.getDay();
    let daysUntil = targetDay - currentDay;
    if (daysUntil <= 0) daysUntil += 7;
    const targetDate = new Date(today);
    targetDate.setDate(targetDate.getDate() + daysUntil);
    date = targetDate.toISOString().split('T')[0];
    title = title.replace(new RegExp(`\\b${dayMatch[1]}\\b`, 'i'), '').trim();
  }

  // Parse time (e.g., "at 3pm", "3:30 pm", "15:00")
  const timeMatch = text.match(/\bat\s*(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/i) ||
    text.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)/i);
  if (timeMatch) {
    let hours = parseInt(timeMatch[1]);
    const minutes = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
    const period = timeMatch[3]?.toLowerCase();

    if (period === 'pm' && hours < 12) hours += 12;
    if (period === 'am' && hours === 12) hours = 0;

    time = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    endTime = `${String((hours + 1) % 24).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;

    title = title.replace(timeMatch[0], '').trim();
  }

  // Parse duration (e.g., "for 2 hours")
  const durationMatch = text.match(/\bfor\s+(\d+(?:\.\d+)?)\s*(hour|hr|hours|hrs|minute|min|minutes|mins)/i);
  if (durationMatch && time) {
    const amount = parseFloat(durationMatch[1]);
    const unit = durationMatch[2].toLowerCase();
    let durationMinutes = unit.startsWith('hour') || unit.startsWith('hr') ? amount * 60 : amount;

    const [startH, startM] = time.split(':').map(Number);
    const totalMinutes = startH * 60 + startM + durationMinutes;
    const endH = Math.floor(totalMinutes / 60) % 24;
    const endM = totalMinutes % 60;
    endTime = `${String(endH).padStart(2, '0')}:${String(endM).padStart(2, '0')}`;

    title = title.replace(durationMatch[0], '').trim();
  }

  // Clean up title
  title = title.replace(/\s+at\s*$/i, '').replace(/\s+/g, ' ').trim();
  if (!title) title = 'New Event';

  return { title, date, time, endTime };
}

// Drag-to-create state
let dragCreateState = {
  isDragging: false,
  startY: 0,
  currentY: 0,
  columnDate: null,
  columnElement: null,
  previewElement: null
};

// Convert Y position to time (based on 80px per hour, starting at 6 AM, full 24 hours)
function yPositionToTime(clientY, columnElement) {
  // Get the column element's bounding rect (viewport-relative, already accounts for scroll)
  const columnRect = columnElement.getBoundingClientRect();

  // Calculate Y position relative to column - no need to add scrollTop
  // because getBoundingClientRect() already gives us the actual viewport position
  const relativeY = clientY - columnRect.top;

  // Clamp relativeY to valid range (0 to 24 hours * 80px = 1920px)
  const clampedY = Math.max(0, Math.min(1920, relativeY));

  // Snap to 15-minute intervals (20px = 15 minutes)
  const snappedY = Math.round(clampedY / 20) * 20;

  // Calculate total minutes from 6 AM (6 AM is at Y=0)
  const totalMinutesFrom6AM = (snappedY / 80) * 60;

  // Convert to actual time (6 AM = 0 minutes offset)
  let totalMinutes = (6 * 60) + totalMinutesFrom6AM;

  // Handle wrap around to next day (after midnight)
  if (totalMinutes >= 24 * 60) {
    totalMinutes = totalMinutes % (24 * 60);
  }

  // Clamp to valid day range (0:00 to 23:45)
  totalMinutes = Math.max(0, Math.min(23 * 60 + 45, totalMinutes));

  const hours = Math.floor(totalMinutes / 60);
  const minutes = Math.round(totalMinutes % 60);

  // Ensure minutes snap to 15-minute intervals
  const snappedMinutes = Math.round(minutes / 15) * 15;
  const finalMinutes = snappedMinutes >= 60 ? 0 : snappedMinutes;
  const finalHours = snappedMinutes >= 60 ? (hours + 1) % 24 : hours;

  return `${String(finalHours).padStart(2, '0')}:${String(finalMinutes).padStart(2, '0')}`;
}

// Convert time to Y position (6 AM = 0, 7 AM = 80, ..., 5 AM next day = 1840)
function timeToYPosition(time) {
  if (!time) return 0;
  const [h, m] = time.split(':').map(Number);
  // Calculate slot index: hours before 6 are treated as next day (add 24)
  let slotIndex = h - 6;
  if (slotIndex < 0) slotIndex += 24; // Wrap around for hours 0-5 (after midnight)
  return (slotIndex * 80) + (m / 60 * 80);
}

// Handle drag start on calendar column
function handleCalendarDragStart(e, dateStr) {
  // Don't start drag if clicking on an event
  if (e.target.closest('.week-event-card')) return;

  // Require authentication to create events
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create events', 'error');
    if (typeof openAuthModal === 'function') openAuthModal();
    return;
  }

  e.preventDefault();
  const column = e.currentTarget;

  dragCreateState = {
    isDragging: true,
    startX: e.clientX,
    startY: e.clientY,
    currentX: e.clientX,
    currentY: e.clientY,
    columnDate: dateStr,
    columnElement: column,
    previewElement: null
  };

  // Create preview element
  const preview = document.createElement('div');
  preview.className = 'drag-create-preview';
  preview.innerHTML = '<div class="drag-preview-content"><span class="drag-preview-time"></span><span class="drag-preview-label">New Event</span></div>';
  column.appendChild(preview);
  dragCreateState.previewElement = preview;

  // Position preview
  updateDragPreview(e.clientY);

  // Add document listeners
  document.addEventListener('mousemove', handleCalendarDragMove);
  document.addEventListener('mouseup', handleCalendarDragEnd);
}

// Handle drag move
function handleCalendarDragMove(e) {
  if (!dragCreateState.isDragging) return;

  e.preventDefault();
  dragCreateState.currentX = e.clientX;
  dragCreateState.currentY = e.clientY;
  updateDragPreview(e.clientY);
}

// Update drag preview position and size
function updateDragPreview(currentY) {
  const { startY, columnElement, previewElement } = dragCreateState;
  if (!previewElement || !columnElement) return;

  // getBoundingClientRect() already accounts for scroll position
  const rect = columnElement.getBoundingClientRect();

  // Calculate positions relative to column - no scrollTop needed
  const startRelative = startY - rect.top;
  const currentRelative = currentY - rect.top;

  // Determine top and height
  const top = Math.min(startRelative, currentRelative);
  const bottom = Math.max(startRelative, currentRelative);
  const height = Math.max(40, bottom - top); // Minimum 40px height

  // Snap to 15-minute intervals (20px)
  const snappedTop = Math.round(top / 20) * 20;
  const snappedHeight = Math.max(40, Math.round(height / 20) * 20);

  previewElement.style.top = `${Math.max(0, snappedTop)}px`;
  previewElement.style.height = `${snappedHeight}px`;

  // Calculate time range for display
  const startTime = yPositionToTime(Math.min(startY, currentY), columnElement);
  const endTime = yPositionToTime(Math.max(startY, currentY), columnElement);

  // Add 30 min minimum for end time if same as start
  let adjustedEndTime = endTime;
  if (startTime === endTime) {
    const [h, m] = endTime.split(':').map(Number);
    const newM = m + 30;
    if (newM >= 60) {
      adjustedEndTime = `${String(h + 1).padStart(2, '0')}:${String(newM - 60).padStart(2, '0')}`;
    } else {
      adjustedEndTime = `${String(h).padStart(2, '0')}:${String(newM).padStart(2, '0')}`;
    }
  }

  // Update preview text
  const timeLabel = previewElement.querySelector('.drag-preview-time');
  if (timeLabel) {
    timeLabel.textContent = `${formatTime12h(startTime)} - ${formatTime12h(adjustedEndTime)}`;
  }

  // Store times for modal
  dragCreateState.startTime = startTime;
  dragCreateState.endTime = adjustedEndTime;
}

// Handle drag end
function handleCalendarDragEnd(e) {
  if (!dragCreateState.isDragging) return;

  document.removeEventListener('mousemove', handleCalendarDragMove);
  document.removeEventListener('mouseup', handleCalendarDragEnd);

  const { columnDate, startTime, endTime, previewElement, startY, currentY, startX, currentX } = dragCreateState;

  // Check if this was a real drag (moved at least 20px) or just a click
  const dragDistance = Math.abs(currentY - startY);

  if (dragDistance > 20 && columnDate && startTime) {
    // Open create dropdown with pre-filled times at cursor position
    // Pass the preview element to keep it visible
    openCreateEventDropdown(e.clientX, e.clientY, columnDate, startTime, endTime || startTime, previewElement);
    // Don't remove preview element here - it will be removed when dropdown is closed
    return;
  }

  // Remove preview for clicks or short drags
  if (previewElement) {
    previewElement.remove();
  }

  // Reset state
  dragCreateState = {
    isDragging: false,
    startX: 0,
    startY: 0,
    currentX: 0,
    currentY: 0,
    columnDate: null,
    columnElement: null,
    previewElement: null
  };
}

// Open create dropdown at cursor position
function openCreateEventDropdown(x, y, date, startTime, endTime, previewElement = null) {
  // Require authentication to create events
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create events', 'error');
    if (typeof openAuthModal === 'function') openAuthModal();
    return;
  }

  // Remove any existing dropdown
  const existingDropdown = document.getElementById('eventDropdownForm');
  if (existingDropdown) {
    existingDropdown.remove();
  }

  const duration = calculateDuration(startTime, endTime);

  const content = `
    <div class="event-dropdown-form" id="eventDropdownForm">
      <div class="modal-content">
        <form id="createEventForm" onsubmit="handleCreateEventSubmit(event, '${date}'); closeEventDropdown(); return false;">
          <div class="form-group">
            <label>Title <span class="required">*</span></label>
            <input type="text" name="title" class="form-input" required placeholder="Meeting / Deadline / Task..." autofocus>
          </div>
          
          <div class="time-picker-group">
            <div class="time-picker-group-header">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
              </svg>
              Time
            </div>
            
            <div class="time-picker-row">
              <span class="time-picker-label">From</span>
              <div class="time-picker-select-wrapper">
                <select id="eventStartTime" name="startTime" class="time-picker-select" onchange="setDefaultEndTime()">
                  <option value="">No time</option>
                  ${generateTimeOptions(startTime)}
                </select>
              </div>
              <span class="time-picker-divider">→</span>
              <div class="time-picker-select-wrapper">
                <select id="eventEndTime" name="endTime" class="time-picker-select" onchange="updateDurationHint()">
                  <option value="">No time</option>
                  ${generateTimeOptions(endTime)}
                </select>
              </div>
            </div>
            
            <div class="time-duration-hint" id="durationHint">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
              </svg>
              <span>${duration ? `Duration: ${duration}` : 'Select time'}</span>
            </div>
            
            <div class="quick-duration-btns">
              <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(30)">30 min</button>
              <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(60)">1 hour</button>
              <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(90)">1.5 hours</button>
              <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(120)">2 hours</button>
              <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(180)">3 hours</button>
            </div>
          </div>
          
          <div class="form-group">
            <label>Color</label>
            <select name="color" class="form-select">
              <option value="blue">Blue</option>
              <option value="green">Green</option>
              <option value="purple">Purple</option>
              <option value="orange">Orange</option>
              <option value="red">Red</option>
            </select>
          </div>
          
          <!-- Repeat Section -->
          <div class="form-group-collapsible">
            <div class="form-collapsible-header" onclick="toggleRepeatSection()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                <path d="M17 1l4 4-4 4"/>
                <path d="M3 11V9a4 4 0 0 1 4-4h14"/>
                <path d="M7 23l-4-4 4-4"/>
                <path d="M21 13v2a4 4 0 0 1-4 4H3"/>
              </svg>
              <span>Repeat</span>
              <span class="repeat-summary-badge" id="repeatSummaryBadge" style="display:none;"></span>
              <svg class="form-collapsible-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                <path d="M6 9l6 6 6-6"/>
              </svg>
            </div>
            <div class="form-collapsible-content" id="repeatSection">
              <div class="repeat-options-grid">
                <div class="form-group-inline">
                  <label>Frequency</label>
                  <select name="repeatType" class="form-select form-select-sm" onchange="handleRepeatTypeChange(this.value, '${date}')">
                    <option value="none">Does not repeat</option>
                    <option value="daily">Daily</option>
                    <option value="weekly">Weekly on ${new Date(date).toLocaleDateString('en-US', { weekday: 'long' })}</option>
                    <option value="weekdays">Every weekday (Mon-Fri)</option>
                    <option value="biweekly">Bi-weekly</option>
                    <option value="monthly">Monthly on day ${new Date(date).getDate()}</option>
                    <option value="custom">Custom...</option>
                  </select>
                </div>
              </div>
              
              <!-- Custom Days Selection (hidden by default) -->
              <div class="repeat-custom-days" id="repeatCustomDays" style="display:none;">
                <label class="form-label" style="font-size:12px; margin-bottom:8px;">Repeat on</label>
                <div class="repeat-days-grid">
                  ${['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, i) => `
                    <label class="repeat-day-chip ${i === new Date(date).getDay() ? 'selected' : ''}">
                      <input type="checkbox" name="repeatDays" value="${i}" ${i === new Date(date).getDay() ? 'checked' : ''} onchange="updateRepeatDayChip(this)">
                      <span>${day}</span>
                    </label>
                  `).join('')}
                </div>
              </div>
              
              <!-- End Repeat Options (hidden when none) -->
              <div class="repeat-end-options" id="repeatEndOptions" style="display:none;">
                <div class="form-group-inline" style="margin-top:12px;">
                  <label>Ends</label>
                  <select name="repeatEndType" class="form-select form-select-sm" onchange="handleRepeatEndTypeChange(this.value)">
                    <option value="never">Never</option>
                    <option value="after">After occurrences</option>
                    <option value="on">On date</option>
                  </select>
                </div>
                
                <div class="repeat-end-after" id="repeatEndAfter" style="display:none; margin-top:8px;">
                  <div style="display:flex; align-items:center; gap:8px;">
                    <input type="number" name="repeatCount" class="form-input form-input-sm" value="10" min="1" max="365" style="width:70px;">
                    <span style="color:var(--muted-foreground); font-size:13px;">occurrences</span>
                  </div>
                </div>
                
                <div class="repeat-end-on" id="repeatEndOn" style="display:none; margin-top:8px;">
                  <input type="date" name="repeatEndDate" class="form-input form-input-sm" value="${getDefaultRepeatEndDate(date)}">
                </div>
              </div>
            </div>
          </div>
          
          <div class="form-actions">
            <button type="button" class="btn btn-secondary" onclick="closeEventDropdown()">Cancel</button>
            <button type="submit" class="btn btn-primary">Create</button>
          </div>
        </form>
      </div>
    </div>
  `;

  // Add dropdown to body
  document.body.insertAdjacentHTML('beforeend', content);

  // Position the dropdown near the cursor
  const dropdown = document.getElementById('eventDropdownForm');
  
  // Store preview element reference for later cleanup
  window.currentEventPreviewElement = previewElement;
  
  // Calculate position to avoid going off-screen
  const rect = dropdown.getBoundingClientRect();
  let posX = x + 10; // Small offset from cursor
  let posY = y + 10; // Small offset from cursor

  // Adjust if it goes off the right edge
  if (posX + rect.width > window.innerWidth) {
    posX = window.innerWidth - rect.width - 10;
  }
  
  // Adjust if it goes off the bottom edge
  if (posY + rect.height > window.innerHeight) {
    posY = y - rect.height - 10; // Position above cursor if needed
  }
  
  // Ensure it doesn't go off the left edge
  if (posX < 10) {
    posX = 10;
  }
  
  // Ensure it doesn't go off the top edge
  if (posY < 10) {
    posY = 10;
  }
  
  dropdown.style.left = `${posX}px`;
  dropdown.style.top = `${posY}px`;

  // Add click listener to close dropdown when clicking outside
  setTimeout(() => {
    document.addEventListener('click', handleDropdownClickOutside);
  }, 10);
}

// Function to close the event dropdown
function closeEventDropdown() {
  const dropdown = document.getElementById('eventDropdownForm');
  if (dropdown) {
    dropdown.remove();
  }
  
  // Remove the preview element if it exists
  if (window.currentEventPreviewElement) {
    window.currentEventPreviewElement.remove();
    window.currentEventPreviewElement = null;
  }
  
  // Remove the click listener
  document.removeEventListener('click', handleDropdownClickOutside);
  
  // Reset drag state
  dragCreateState = {
    isDragging: false,
    startX: 0,
    startY: 0,
    currentX: 0,
    currentY: 0,
    columnDate: null,
    columnElement: null,
    previewElement: null
  };
}

// Handler to close dropdown when clicking outside
function handleDropdownClickOutside(e) {
  const dropdown = document.getElementById('eventDropdownForm');
  if (dropdown && !dropdown.contains(e.target)) {
    closeEventDropdown();
  }
}

// Legacy function kept for compatibility (will be deprecated)
function openCreateEventModalWithTime(date, startTime, endTime) {
  // Require authentication to create events
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create events', 'error');
    if (typeof openAuthModal === 'function') openAuthModal();
    return;
  }

  const duration = calculateDuration(startTime, endTime);

  const content = `
    <form id="createEventForm" onsubmit="handleCreateEventSubmit(event, '${date}')">
      <div class="form-group">
        <label>Title <span class="required">*</span></label>
        <input type="text" name="title" class="form-input" required placeholder="Meeting / Deadline / Task..." autofocus>
      </div>
      
      <div class="time-picker-group">
        <div class="time-picker-group-header">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
          </svg>
          Time
        </div>
        
        <div class="time-picker-row">
          <span class="time-picker-label">From</span>
          <div class="time-picker-select-wrapper">
            <select id="eventStartTime" name="startTime" class="time-picker-select" onchange="setDefaultEndTime()">
              <option value="">No time</option>
              ${generateTimeOptions(startTime)}
            </select>
          </div>
          <span class="time-picker-divider">→</span>
          <div class="time-picker-select-wrapper">
            <select id="eventEndTime" name="endTime" class="time-picker-select" onchange="updateDurationHint()">
              <option value="">No time</option>
              ${generateTimeOptions(endTime)}
            </select>
          </div>
        </div>
        
        <div class="time-duration-hint" id="durationHint">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
          </svg>
          <span>${duration ? `Duration: ${duration}` : 'Select time'}</span>
        </div>
        
        <div class="quick-duration-btns">
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(30)">30 min</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(60)">1 hour</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(90)">1.5 hours</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(120)">2 hours</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(180)">3 hours</button>
        </div>
      </div>
      
      <div class="form-group">
        <label>Color</label>
        <select name="color" class="form-select">
          <option value="blue">Blue</option>
          <option value="green">Green</option>
          <option value="purple">Purple</option>
          <option value="orange">Orange</option>
          <option value="red">Red</option>
        </select>
      </div>
      
      <!-- Repeat Section -->
      <div class="form-group-collapsible">
        <div class="form-collapsible-header" onclick="toggleRepeatSection()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <path d="M17 1l4 4-4 4"/>
            <path d="M3 11V9a4 4 0 0 1 4-4h14"/>
            <path d="M7 23l-4-4 4-4"/>
            <path d="M21 13v2a4 4 0 0 1-4 4H3"/>
          </svg>
          <span>Repeat</span>
          <span class="repeat-summary-badge" id="repeatSummaryBadge" style="display:none;"></span>
          <svg class="form-collapsible-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
            <path d="M6 9l6 6 6-6"/>
          </svg>
        </div>
        <div class="form-collapsible-content" id="repeatSection">
          <div class="repeat-options-grid">
            <div class="form-group-inline">
              <label>Frequency</label>
              <select name="repeatType" class="form-select form-select-sm" onchange="handleRepeatTypeChange(this.value, '${date}')">
                <option value="none">Does not repeat</option>
                <option value="daily">Daily</option>
                <option value="weekly">Weekly on ${new Date(date).toLocaleDateString('en-US', { weekday: 'long' })}</option>
                <option value="weekdays">Every weekday (Mon-Fri)</option>
                <option value="biweekly">Bi-weekly</option>
                <option value="monthly">Monthly on day ${new Date(date).getDate()}</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
          </div>
          
          <!-- Custom Days Selection (hidden by default) -->
          <div class="repeat-custom-days" id="repeatCustomDays" style="display:none;">
            <label class="form-label" style="font-size:12px; margin-bottom:8px;">Repeat on</label>
            <div class="repeat-days-grid">
              ${['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, i) => `
                <label class="repeat-day-chip ${i === new Date(date).getDay() ? 'selected' : ''}">
                  <input type="checkbox" name="repeatDays" value="${i}" ${i === new Date(date).getDay() ? 'checked' : ''} onchange="updateRepeatDayChip(this)">
                  <span>${day}</span>
                </label>
              `).join('')}
            </div>
          </div>
          
          <!-- End Repeat Options (hidden when none) -->
          <div class="repeat-end-options" id="repeatEndOptions" style="display:none;">
            <div class="form-group-inline" style="margin-top:12px;">
              <label>Ends</label>
              <select name="repeatEndType" class="form-select form-select-sm" onchange="handleRepeatEndTypeChange(this.value)">
                <option value="never">Never</option>
                <option value="after">After occurrences</option>
                <option value="on">On date</option>
              </select>
            </div>
            
            <div class="repeat-end-after" id="repeatEndAfter" style="display:none; margin-top:8px;">
              <div style="display:flex; align-items:center; gap:8px;">
                <input type="number" name="repeatCount" class="form-input form-input-sm" value="10" min="1" max="365" style="width:70px;">
                <span style="color:var(--muted-foreground); font-size:13px;">occurrences</span>
              </div>
            </div>
            
            <div class="repeat-end-on" id="repeatEndOn" style="display:none; margin-top:8px;">
              <input type="date" name="repeatEndDate" class="form-input form-input-sm" value="${getDefaultRepeatEndDate(date)}">
            </div>
          </div>
        </div>
      </div>
      
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Create</button>
      </div>
    </form>
  `;
  openModal('New Task / Event', content);
}

// Get week dates starting from a given date
function getWeekDates(date) {
  const start = new Date(date);
  const day = start.getDay();
  const diff = start.getDate() - day + (day === 0 ? -6 : 1); // Adjust for Monday start
  start.setDate(diff);

  const dates = [];
  for (let i = 0; i < 7; i++) {
    const d = new Date(start);
    d.setDate(start.getDate() + i);
    dates.push(d);
  }
  return dates;
}

// Format time to 12h format (clean format like "10 AM")
function formatTime12h(time) {
  if (!time) return '';
  const [h, m] = time.split(':').map(Number);
  const hour = h > 12 ? h - 12 : (h === 0 ? 12 : h);
  const ampm = h >= 12 ? 'PM' : 'AM';
  // Show minutes only if not :00
  if (m === 0) {
    return `${hour} ${ampm}`;
  }
  return `${hour}:${m.toString().padStart(2, '0')} ${ampm}`;
}

// Get event position and height based on time (80px per hour)
// Grid starts at 6 AM, wraps at midnight through 5:59 AM
function getEventPosition(startTime, endTime) {
  if (!startTime) return { top: 0, height: 60 };

  const [startH, startM] = startTime.split(':').map(Number);

  // Calculate slot index from 6 AM baseline (0-23 range for 24 hour display)
  // Hours 6-23 are slots 0-17, hours 0-5 are slots 18-23
  let slotIndex = startH - 6;
  if (slotIndex < 0) slotIndex += 24; // Wrap around for hours before 6 AM

  const startMinutes = slotIndex * 60 + startM;
  const top = Math.max(0, (startMinutes / 60) * 80); // 80px per hour

  let height = 60; // Default height
  if (endTime) {
    const [endH, endM] = endTime.split(':').map(Number);
    let endSlotIndex = endH - 6;
    if (endSlotIndex < 0) endSlotIndex += 24;

    const endMinutes = endSlotIndex * 60 + endM;
    let duration = endMinutes - startMinutes;

    // Handle events that span midnight
    if (duration <= 0) duration += 24 * 60;

    height = Math.max(40, (duration / 60) * 80);
  }

  return { top, height };
}

// Convert time string to minutes for comparison
function timeToMinutes(timeStr) {
  if (!timeStr) return 0;
  const [h, m] = timeStr.split(':').map(Number);
  // Adjust for 6 AM baseline
  let slotIndex = h - 6;
  if (slotIndex < 0) slotIndex += 24;
  return slotIndex * 60 + m;
}

// Check if two events overlap in time
function eventsOverlap(ev1, ev2) {
  const start1 = timeToMinutes(ev1.time || '00:00');
  const end1 = timeToMinutes(ev1.endTime || ev1.time || '00:00') || start1 + 60;
  const start2 = timeToMinutes(ev2.time || '00:00');
  const end2 = timeToMinutes(ev2.endTime || ev2.time || '00:00') || start2 + 60;

  // Events overlap if one starts before the other ends
  return start1 < end2 && start2 < end1;
}

// Calculate positions for overlapping events (Google Calendar style)
function calculateOverlapPositions(events) {
  if (!events.length) return [];

  // Sort events by start time, then by duration (longer first)
  const sorted = [...events].sort((a, b) => {
    const startDiff = timeToMinutes(a.time || '00:00') - timeToMinutes(b.time || '00:00');
    if (startDiff !== 0) return startDiff;
    // For same start time, longer events first
    const durA = timeToMinutes(a.endTime || a.time || '00:00') - timeToMinutes(a.time || '00:00');
    const durB = timeToMinutes(b.endTime || b.time || '00:00') - timeToMinutes(b.time || '00:00');
    return durB - durA;
  });

  const positioned = [];
  const columns = []; // Array of arrays, each inner array is a column

  for (const event of sorted) {
    let placed = false;

    // Try to place in existing column
    for (let colIndex = 0; colIndex < columns.length; colIndex++) {
      const column = columns[colIndex];
      const canPlace = column.every(placedEvent => !eventsOverlap(event, placedEvent));

      if (canPlace) {
        column.push(event);
        positioned.push({ event, columnIndex: colIndex });
        placed = true;
        break;
      }
    }

    // Create new column if needed
    if (!placed) {
      columns.push([event]);
      positioned.push({ event, columnIndex: columns.length - 1 });
    }
  }

  // Calculate the maximum columns needed for each event's overlap group
  // Find all events that overlap with each event and determine total columns
  return positioned.map(({ event, columnIndex }) => {
    // Find all events that overlap with this one
    const overlapping = positioned.filter(p => eventsOverlap(event, p.event));
    const maxColumns = Math.max(...overlapping.map(p => p.columnIndex)) + 1;

    const width = 100 / maxColumns;
    const left = columnIndex * width;

    return { event, left, width };
  });
}

// Get color based on category
function getCategoryColor(category) {
  const cat = EVENT_CATEGORIES.find(c => c.id === category);
  return cat ? cat.color : '#3b82f6';
}

// Parse event for category
function getEventCategory(event) {
  if (event.category) return event.category;
  const title = event.title.toLowerCase();
  if (title.includes('meeting') || title.includes('call')) return 'meeting';
  if (title.includes('lunch') || title.includes('break')) return 'health';
  if (title.includes('review') || title.includes('standup')) return 'work';
  return 'personal';
}

// Avatar function removed - no longer needed

function renderScheduleView() {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const events = loadCalendarEvents();
  const recurringTasks = loadRecurringTasks();


  const totalEvents = events.length;
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'];

  // Generate content based on view mode
  let mainContent = '';
  if (scheduleViewMode === 'week') {
    mainContent = renderWeekView(events, today);
  } else if (scheduleViewMode === 'day') {
    mainContent = renderDayView(events, today);
  } else if (scheduleViewMode === 'agenda') {
    mainContent = renderAgendaView(events, today);
  } else if (scheduleViewMode === 'year') {
    mainContent = renderYearView(events, today);
  } else {
    mainContent = renderMonthViewAdvanced(events, today);
  }

  // Prepare the schedule container with swipe functionality
  setTimeout(() => {
    initCalendarSwipe();
  }, 100);
  
  return `
    <div class="advanced-schedule-container">
      <!-- Left Sidebar -->
      <aside class="schedule-left-sidebar">
        <!-- Calendar Selector -->
        <div class="calendar-selector">
          <div class="calendar-selector-header" onclick="toggleCalendarDropdown()">
            <div class="calendar-selector-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="4" width="18" height="18" rx="2"/>
                <path d="M16 2v4M8 2v4M3 10h18"/>
              </svg>
              <span class="calendar-date-badge">${today.getDate()}</span>
            </div>
            <div class="calendar-selector-info">
              <span class="calendar-selector-title">All Calendar</span>
              <span class="calendar-selector-subtitle">Personal, Teams</span>
            </div>
            <svg class="calendar-selector-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M6 9l6 6 6-6"/>
            </svg>
          </div>
        </div>
        
        <!-- Mini Calendar -->
        <div class="mini-calendar-section">
          <div class="mini-calendar-header">
            <button class="mini-cal-nav" onclick="navigateMiniCalendar(-1)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
            </button>
            <span class="mini-cal-month">${monthNames[scheduleCurrentDate.getMonth()]}</span>
            <button class="mini-cal-nav" onclick="navigateMiniCalendar(1)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>
            </button>
          </div>
          ${renderMiniCalendar(scheduleCurrentDate, scheduleSelectedDate, today, events)}
        </div>
        
        <!-- My Schedule Filter -->
        <div class="schedule-filter-section">
          <div class="filter-section-header" onclick="toggleMyScheduleSection()">
            <span class="filter-section-title">My Schedule</span>
            <svg class="filter-section-chevron ${scheduleMyScheduleCollapsed ? 'collapsed' : ''}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M6 9l6 6 6-6"/>
            </svg>
          </div>
          <div class="filter-section-content ${scheduleMyScheduleCollapsed ? 'collapsed' : ''}">
            ${MY_SCHEDULE_PRESETS.map(preset => `
              <label class="schedule-filter-item">
                <input type="checkbox" 
                       ${scheduleFilters.mySchedule.includes(preset.id) ? 'checked' : ''} 
                       onchange="toggleScheduleFilter('${preset.id}')">
                <span class="filter-checkbox"></span>
                <span class="filter-label">${preset.name}</span>
              </label>
            `).join('')}
          </div>
        </div>
      </aside>
      
      <!-- Main Content -->
      <main class="schedule-main-content">
        <!-- Header Breadcrumb -->
        <div class="schedule-breadcrumb">
          <span class="breadcrumb-item">Calendar</span>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="breadcrumb-chevron"><path d="M9 18l6-6-6-6"/></svg>
          <span class="breadcrumb-item active">All Calendar</span>
        </div>
        
        <!-- Main Header -->
        <div class="schedule-main-header">
          <div class="schedule-header-left">
            <h1 class="schedule-main-title">Calendar</h1>
            
            <!-- Today Button -->
            <button class="today-btn" onclick="goToScheduleToday()" title="Go to today (T)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="4" width="18" height="18" rx="2"/>
                <path d="M16 2v4M8 2v4M3 10h18"/>
                <circle cx="12" cy="15" r="2" fill="currentColor"/>
              </svg>
              Today
            </button>
            
            <!-- Navigation Arrows -->
            <div class="schedule-nav-arrows">
              <button class="nav-arrow-btn" onclick="navigateSchedulePrev()" title="Previous (P)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
              </button>
              <button class="nav-arrow-btn" onclick="navigateScheduleNext()" title="Next (N)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>
              </button>
            </div>
            
            <div class="schedule-month-selector" onclick="openMonthPicker()">
              <span class="month-year-text">${monthNames[scheduleCurrentDate.getMonth()]}, ${scheduleCurrentDate.getFullYear()}</span>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="month-chevron"><path d="M6 9l6 6 6-6"/></svg>
            </div>
            
            <!-- Time Zone Display -->
            <div class="timezone-display" onclick="openTimeZoneModal()" title="Click to change timezone">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"/>
                <path d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"/>
              </svg>
              <span id="currentTimezoneLabel">${getCurrentTimezoneLabel()}</span>
            </div>
            
            <div class="schedule-event-count">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="4" width="18" height="18" rx="2"/>
                <path d="M16 2v4M8 2v4M3 10h18"/>
              </svg>
              <span>${totalEvents} event${totalEvents !== 1 ? 's' : ''}</span>
            </div>
          </div>
          <div class="schedule-header-right">
            <div class="schedule-view-toggle">
              <button class="view-toggle-btn ${scheduleViewMode === 'week' ? 'active' : ''}" onclick="setScheduleViewMode('week')" title="Week view (W)">Week</button>
              <button class="view-toggle-btn ${scheduleViewMode === 'month' ? 'active' : ''}" onclick="setScheduleViewMode('month')" title="Month view (M)">Month</button>
              <button class="view-toggle-btn ${scheduleViewMode === 'year' ? 'active' : ''}" onclick="setScheduleViewMode('year')" title="Year view (Y)">Year</button>
              <button class="view-toggle-btn ${scheduleViewMode === 'agenda' ? 'active' : ''}" onclick="setScheduleViewMode('agenda')" title="Agenda view (A)">Agenda</button>
            </div>
            <div class="schedule-header-actions">
              <button class="smart-schedule-btn" onclick="openSmartScheduleModal()" title="Find available times">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
                </svg>
              </button>
              <button class="schedule-search-btn" onclick="toggleCalendarSearch()" title="Search (/)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg>
              </button>
            </div>
            <button class="btn btn-primary schedule-add-btn" onclick="openAdvancedEventModal()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
              Add Event
            </button>
          </div>
        </div>
        
        <!-- Week/Day/Month View -->
        ${mainContent}
      </main>
    </div>
  `;
}

// Render Mini Calendar
function renderMiniCalendar(currentDate, selectedDate, today, events) {
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();
  const firstDay = new Date(year, month, 1);
  const lastDay = new Date(year, month + 1, 0);
  const startDay = firstDay.getDay();
  const daysInMonth = lastDay.getDate();

  // Get week dates for highlighting
  const weekDates = getWeekDates(selectedDate);
  const weekDateStrings = weekDates.map(d => d.toISOString().split('T')[0]);

  let html = '<div class="mini-cal-grid">';

  // Weekday headers
  ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'].forEach(day => {
    html += `<div class="mini-cal-weekday">${day}</div>`;
  });

  // Previous month padding (Monday start)
  const adjustedStart = startDay === 0 ? 6 : startDay - 1;
  for (let i = 0; i < adjustedStart; i++) {
    html += '<div class="mini-cal-day other-month"></div>';
  }

  // Current month days
  for (let d = 1; d <= daysInMonth; d++) {
    const date = new Date(year, month, d);
    const dateStr = date.toISOString().split('T')[0];
    const isToday = date.toDateString() === today.toDateString();
    const isSelected = dateStr === selectedDate.toISOString().split('T')[0];
    const isInWeek = weekDateStrings.includes(dateStr);
    const hasEvents = events.some(e => e.date === dateStr);

    let classes = 'mini-cal-day';
    if (isToday) classes += ' today';
    if (isSelected) classes += ' selected';
    if (isInWeek && scheduleViewMode === 'week') classes += ' in-week';
    if (hasEvents) classes += ' has-events';

    html += `<div class="${classes}" onclick="selectScheduleDate('${dateStr}')">${d}</div>`;
  }

  html += '</div>';
  return html;
}

// Render Week View
function renderWeekView(events, today) {
  const weekDates = getWeekDates(scheduleSelectedDate);
  const weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];

  // Get timezone offset
  const tzOffset = -(new Date().getTimezoneOffset() / 60);
  const tzLabel = `UTC ${tzOffset >= 0 ? '+' : ''}${tzOffset}`;

  let html = `
    <div class="week-view-container">
      <!-- Week Header -->
      <div class="week-header">
        <div class="week-header-tz">${tzLabel}</div>
        ${weekDates.map((date, i) => {
    const isToday = date.toDateString() === today.toDateString();
    return `
            <div class="week-header-day ${isToday ? 'today' : ''}">
              <span class="week-day-number">${date.getDate()}</span>
              <span class="week-day-name">${weekdays[i]}</span>
            </div>
          `;
  }).join('')}
      </div>
      
      <!-- Week Grid with Time Slots -->
      <div class="week-grid-scroll">
        <div class="week-grid">
          <!-- Time Labels Column -->
          <div class="time-labels-col">
            ${TIME_SLOTS.map(slot => `
              <div class="time-label">${slot.label}</div>
            `).join('')}
          </div>
          
          <!-- Day Columns -->
          ${weekDates.map((date, dayIndex) => {
    const dateStr = date.toISOString().split('T')[0];
    const dayEvents = events.filter(e => e.date === dateStr);
    const isToday = date.toDateString() === today.toDateString();

    return `
              <div class="week-day-column ${isToday ? 'today' : ''}" 
                   data-date="${dateStr}"
                   ondragover="handleColumnDragOver(event, '${dateStr}')" 
                   ondragleave="handleColumnDragLeave(event)"
                   ondrop="handleDrop(event, '${dateStr}')"
                   onmousedown="handleCalendarDragStart(event, '${dateStr}')">
                <!-- Current time indicator -->
                ${isToday ? '<div class="current-time-indicator" id="currentTimeIndicator"></div>' : ''}
                <!-- Time slot grid lines -->
                ${TIME_SLOTS.map(() => '<div class="time-slot-line"></div>').join('')}
                
                <!-- Events -->
                ${(() => {
        const positioned = calculateOverlapPositions(dayEvents);
        return positioned.map(({ event: ev, left, width }) => {
          const pos = getEventPosition(ev.time, ev.endTime);
          const color = getEventColor(ev.color || 'blue');
          const timeStr = ev.time ? formatTime12h(ev.time) : '';
          const endTimeStr = ev.endTime ? formatTime12h(ev.endTime) : '';
          const timeRange = endTimeStr ? `${timeStr} - ${endTimeStr}` : timeStr;
          const linkedInfo = getEventLinkedInfo(ev);

          return `
                      <div class="week-event-card" 
                           style="top: ${pos.top}px; height: ${pos.height}px; left: ${left}%; width: calc(${width}% - 2px); --event-color: ${color};"
                           draggable="true"
                           data-event-id="${ev.id}"
                           data-date="${dateStr}"
                           ondragstart="handleDragStart(event, '${ev.id}', '${dateStr}')"
                           onclick="event.stopPropagation(); openEditTaskModal('${ev.id}')"
                           oncontextmenu="event.preventDefault(); event.stopPropagation(); showTaskContextMenu(event, '${ev.id}')">
                        <div class="week-event-color-bar" style="background: ${color};"></div>
                        <div class="week-event-content">
                          <div class="week-event-title">${ev.title}</div>
                          <div class="week-event-time">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
                            </svg>
                            ${timeRange}
                          </div>
                          ${linkedInfo}
                        </div>
                        <div class="event-resize-handle" 
                             onmousedown="event.stopPropagation(); handleEventResizeStart(event, '${ev.id}', '${dateStr}')">
                        </div>
                      </div>
                    `;
        }).join('');
      })()}
              </div>
            `;
  }).join('')}
        </div>
      </div>
    </div>
  `;

  return html;
}

// Render Day View
function renderDayView(events, today) {
  const dateStr = scheduleSelectedDate.toISOString().split('T')[0];
  const dayEvents = events.filter(e => e.date === dateStr);
  const isToday = scheduleSelectedDate.toDateString() === today.toDateString();
  const dayName = scheduleSelectedDate.toLocaleDateString('en-US', { weekday: 'long' });

  const tzOffset = -(new Date().getTimezoneOffset() / 60);
  const tzLabel = `UTC ${tzOffset >= 0 ? '+' : ''}${tzOffset}`;

  return `
    <div class="day-view-container">
      <div class="day-view-header">
        <div class="day-view-tz">${tzLabel}</div>
        <div class="day-view-info ${isToday ? 'today' : ''}">
          <span class="day-view-number">${scheduleSelectedDate.getDate()}</span>
          <span class="day-view-name">${dayName}</span>
        </div>
      </div>
      <div class="day-view-grid-scroll">
        <div class="day-view-grid">
          <div class="time-labels-col">
            ${TIME_SLOTS.map(slot => `
              <div class="time-label">${slot.label}</div>
            `).join('')}
          </div>
          <div class="day-events-column ${isToday ? 'today' : ''}"
               data-date="${dateStr}"
               ondragover="handleColumnDragOver(event, '${dateStr}')"
               ondragleave="handleColumnDragLeave(event)"
               ondrop="handleDrop(event, '${dateStr}')"
               onmousedown="handleCalendarDragStart(event, '${dateStr}')">
            <!-- Current time indicator -->
            ${isToday ? '<div class="current-time-indicator" id="currentTimeIndicatorDay"></div>' : ''}
            ${TIME_SLOTS.map(() => '<div class="time-slot-line"></div>').join('')}
            ${(() => {
      const positioned = calculateOverlapPositions(dayEvents);
      return positioned.map(({ event: ev, left, width }) => {
        const pos = getEventPosition(ev.time, ev.endTime);
        const color = getEventColor(ev.color || 'blue');
        const timeStr = ev.time ? formatTime12h(ev.time) : '';
        const endTimeStr = ev.endTime ? formatTime12h(ev.endTime) : '';
        const timeRange = endTimeStr ? `${timeStr} - ${endTimeStr}` : timeStr;
        const linkedInfo = getEventLinkedInfo(ev);

        return `
                  <div class="week-event-card day-event-card"
                       style="top: ${pos.top}px; height: ${pos.height}px; left: ${left}%; width: calc(${width}% - 2px); --event-color: ${color};"
                       draggable="true"
                       data-event-id="${ev.id}"
                       data-date="${dateStr}"
                       ondragstart="handleDragStart(event, '${ev.id}', '${dateStr}')"
                       onclick="event.stopPropagation(); openEditTaskModal('${ev.id}')"
                       oncontextmenu="event.preventDefault(); event.stopPropagation(); showTaskContextMenu(event, '${ev.id}')">
                    <div class="week-event-color-bar" style="background: ${color};"></div>
                    <div class="week-event-content">
                      <div class="week-event-title">${ev.title}</div>
                      <div class="week-event-time">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
                        </svg>
                        ${timeRange}
                      </div>
                      ${linkedInfo}
                    </div>
                    <div class="event-resize-handle" 
                         onmousedown="event.stopPropagation(); handleEventResizeStart(event, '${ev.id}', '${dateStr}')">
                    </div>
                  </div>
                `;
      }).join('');
    })()}
          </div>
        </div>
      </div>
    </div>
  `;
}

// Render Month View (Advanced)
function renderMonthViewAdvanced(events, today) {
  const year = scheduleCurrentDate.getFullYear();
  const month = scheduleCurrentDate.getMonth();
  const firstDay = new Date(year, month, 1);
  const lastDay = new Date(year, month + 1, 0);
  const startDay = firstDay.getDay();
  const daysInMonth = lastDay.getDate();
  const adjustedStart = startDay === 0 ? 6 : startDay - 1;

  const weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

  let daysHtml = '';

  // Previous month padding
  for (let i = 0; i < adjustedStart; i++) {
    daysHtml += '<div class="month-day other-month"></div>';
  }

  // Current month days
  for (let d = 1; d <= daysInMonth; d++) {
    const date = new Date(year, month, d);
    const dateStr = date.toISOString().split('T')[0];
    const isToday = date.toDateString() === today.toDateString();
    const dayEvents = events.filter(e => e.date === dateStr).slice(0, 3);
    const moreCount = events.filter(e => e.date === dateStr).length - 3;

    daysHtml += `
      <div class="month-day ${isToday ? 'today' : ''}"
           ondragover="event.preventDefault()"
           ondrop="handleDrop(event, '${dateStr}')"
           onclick="if (!event.target.closest('.month-event')) { selectScheduleDate('${dateStr}'); setScheduleViewMode('day'); }">
        <span class="month-day-number">${d}</span>
        <div class="month-day-events">
          ${dayEvents.map(ev => {
      const color = getEventColor(ev.color || 'blue');
      return `
              <div class="month-event" style="--event-color: ${color};"
                   onclick="event.stopPropagation(); openEditTaskModal('${ev.id}')">
                <span class="month-event-dot" style="background: ${color};"></span>
                <span class="month-event-title">${ev.title.length > 12 ? ev.title.substring(0, 10) + '...' : ev.title}</span>
              </div>
            `;
    }).join('')}
          ${moreCount > 0 ? `<div class="month-more-events">+${moreCount} more</div>` : ''}
        </div>
      </div>
    `;
  }

  return `
    <div class="month-view-container">
      <div class="month-grid-header">
        ${weekdays.map(day => `<div class="month-weekday">${day}</div>`).join('')}
      </div>
      <div class="month-grid">
        ${daysHtml}
      </div>
    </div>
  `;
}

// Schedule View Mode
function setScheduleViewMode(mode) {
  scheduleViewMode = mode;
  renderCurrentView();
  // Reinitialize swipe functionality after view change
  setTimeout(() => {
    initCalendarSwipe();
  }, 100);
}

// Navigate Mini Calendar
function navigateMiniCalendar(direction) {
  scheduleCurrentDate.setMonth(scheduleCurrentDate.getMonth() + direction);
  renderCurrentView();
}

// Select Date
function selectScheduleDate(dateStr) {
  scheduleSelectedDate = new Date(dateStr);
  scheduleCurrentDate = new Date(dateStr);
  renderCurrentView();
}

// Toggle sections
function toggleMyScheduleSection() {
  scheduleMyScheduleCollapsed = !scheduleMyScheduleCollapsed;
  renderCurrentView();
}


function toggleScheduleFilter(filterId) {
  const index = scheduleFilters.mySchedule.indexOf(filterId);
  if (index > -1) {
    scheduleFilters.mySchedule.splice(index, 1);
  } else {
    scheduleFilters.mySchedule.push(filterId);
  }
  renderCurrentView();
}

// Helper: Get unique tasks by title (show each name only once)
function getUniqueTasksByTitle(events) {
  const seen = new Set();
  return events.filter(ev => {
    if (seen.has(ev.title)) return false;
    seen.add(ev.title);
    return true;
  }).sort((a, b) => a.date.localeCompare(b.date));
}

// Context menu for schedule tasks
function showTaskContextMenu(event, eventId) {
  // Remove any existing context menu
  const existingMenu = document.getElementById('taskContextMenu');
  if (existingMenu) existingMenu.remove();

  const menu = document.createElement('div');
  menu.id = 'taskContextMenu';
  menu.className = 'task-context-menu';
  menu.innerHTML = `
    <button class="context-menu-item" onclick="duplicateCalendarTask('${eventId}'); hideTaskContextMenu();">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <rect x="9" y="9" width="13" height="13" rx="2"/>
        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
      </svg>
      Duplicate
    </button>
    <button class="context-menu-item" onclick="openEditTaskModal('${eventId}'); hideTaskContextMenu();">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
        <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
      </svg>
      Edit
    </button>
    <button class="context-menu-item delete" onclick="deleteTask('${eventId}'); hideTaskContextMenu();">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m5 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
      </svg>
      Delete
    </button>
  `;

  menu.style.left = event.clientX + 'px';
  menu.style.top = event.clientY + 'px';

  document.body.appendChild(menu);

  // Close on click outside
  setTimeout(() => {
    document.addEventListener('click', hideTaskContextMenu, { once: true });
  }, 10);
}

function hideTaskContextMenu() {
  const menu = document.getElementById('taskContextMenu');
  if (menu) menu.remove();
}

// Drag handlers
// State for drag-move preview
let dragMoveState = {
  isDragging: false,
  eventId: null,
  originalEvent: null,
  previewElement: null,
  currentColumn: null,
  clickOffsetY: 0 // Y offset from where user clicked within the event card
};

function handleDragStart(event, eventId, currentDate) {
  const events = loadCalendarEvents();
  const task = events.find(e => e.id == eventId);

  // Calculate click offset within the event card
  const eventCard = event.currentTarget;
  const cardRect = eventCard.getBoundingClientRect();
  const clickOffsetY = event.clientY - cardRect.top;

  // Store event data and original event info
  event.dataTransfer.setData('text/plain', JSON.stringify({
    id: eventId,
    fromDate: currentDate,
    type: 'move',
    duration: calculateEventDurationMinutes(task?.time, task?.endTime)
  }));
  event.dataTransfer.effectAllowed = 'move';
  event.currentTarget.classList.add('dragging');

  // Initialize drag move state with click offset
  dragMoveState = {
    isDragging: true,
    eventId: eventId,
    originalEvent: task,
    previewElement: null,
    currentColumn: null,
    clickOffsetY: clickOffsetY
  };
}

// Calculate event duration in minutes
function calculateEventDurationMinutes(startTime, endTime) {
  if (!startTime || !endTime) return 60; // Default 1 hour
  const [startH, startM] = startTime.split(':').map(Number);
  const [endH, endM] = endTime.split(':').map(Number);
  let duration = (endH * 60 + endM) - (startH * 60 + startM);
  if (duration <= 0) duration = 60; // Fallback
  return duration;
}

// Sidebar drag handler - for duplicating
function handleSidebarDragStart(event, eventId) {
  event.dataTransfer.setData('text/plain', JSON.stringify({ id: eventId, type: 'duplicate' }));
  event.currentTarget.classList.add('dragging');
}

// Handle drag over column - show preview ghost (Google Calendar style)
function handleColumnDragOver(event, targetDate) {
  event.preventDefault();
  event.dataTransfer.dropEffect = 'move';

  const column = event.currentTarget;

  // Add drag-over class to column for highlighting
  if (!column.classList.contains('drag-over')) {
    // Remove from other columns first
    document.querySelectorAll('.week-day-column.drag-over, .day-events-column.drag-over').forEach(col => {
      if (col !== column) col.classList.remove('drag-over');
    });
    column.classList.add('drag-over');
  }

  if (!dragMoveState.isDragging || !dragMoveState.originalEvent) return;

  const scrollContainer = column.closest('.week-grid-scroll, .day-view-grid-scroll');
  const containerRect = scrollContainer ? scrollContainer.getBoundingClientRect() : column.getBoundingClientRect();
  const scrollTop = scrollContainer?.scrollTop || 0;

  // Calculate position relative to scroll container's content, accounting for click offset
  const clickOffsetY = dragMoveState.clickOffsetY || 0;
  const relativeY = event.clientY - containerRect.top + scrollTop - clickOffsetY;

  // Snap to 15-minute intervals (20px per 15 min)
  const snappedY = Math.round(relativeY / 20) * 20;

  // Calculate the new start time based on the adjusted position (top of event, not cursor)
  const adjustedClientY = event.clientY - clickOffsetY;
  const newTime = yPositionToTime(adjustedClientY, column);

  // Calculate duration for height
  const duration = calculateEventDurationMinutes(
    dragMoveState.originalEvent.time,
    dragMoveState.originalEvent.endTime
  );
  const height = Math.max(40, (duration / 60) * 80);

  // Create or update preview element
  if (dragMoveState.currentColumn !== column) {
    // Remove preview from old column
    if (dragMoveState.previewElement) {
      dragMoveState.previewElement.remove();
    }

    // Create new preview in this column
    const preview = document.createElement('div');
    preview.className = 'drag-move-preview';
    const category = getEventCategory(dragMoveState.originalEvent);
    const color = getCategoryColor(category);
    preview.innerHTML = `
      <div class="drag-move-preview-bar" style="background: ${color};"></div>
      <div class="drag-move-preview-content">
        <div class="drag-move-preview-title">${dragMoveState.originalEvent.title}</div>
        <div class="drag-move-preview-time">${formatTime12h(newTime)}</div>
      </div>
    `;
    column.appendChild(preview);
    dragMoveState.previewElement = preview;
    dragMoveState.currentColumn = column;
  }

  // Update preview position with smooth transition
  if (dragMoveState.previewElement) {
    const clampedY = Math.max(0, Math.min(1920 - height, snappedY));
    dragMoveState.previewElement.style.top = `${clampedY}px`;
    dragMoveState.previewElement.style.height = `${height}px`;

    // Update time display
    const timeEl = dragMoveState.previewElement.querySelector('.drag-move-preview-time');
    if (timeEl) {
      const endTime = calculateEndTimeFromDuration(newTime, duration);
      timeEl.textContent = `${formatTime12h(newTime)} - ${formatTime12h(endTime)}`;
    }
  }
}

// Handle drag leave - clean up column highlight
function handleColumnDragLeave(event) {
  const column = event.currentTarget;
  const relatedTarget = event.relatedTarget;

  // Only remove highlight if actually leaving the column (not entering a child)
  if (relatedTarget && column.contains(relatedTarget)) return;

  column.classList.remove('drag-over');
}

// Calculate end time from start time and duration in minutes
function calculateEndTimeFromDuration(startTime, durationMinutes) {
  if (!startTime) return '';
  const [h, m] = startTime.split(':').map(Number);
  let totalMinutes = h * 60 + m + durationMinutes;
  if (totalMinutes >= 24 * 60) totalMinutes = 24 * 60 - 1;
  const endH = Math.floor(totalMinutes / 60);
  const endM = totalMinutes % 60;
  return `${String(endH).padStart(2, '0')}:${String(endM).padStart(2, '0')}`;
}

// Clean up drag state
function cleanupDragMoveState() {
  if (dragMoveState.previewElement) {
    dragMoveState.previewElement.remove();
  }
  // Remove dragging class from all cards
  document.querySelectorAll('.week-event-card.dragging').forEach(el => {
    el.classList.remove('dragging');
  });
  // Remove drag-over class from all columns
  document.querySelectorAll('.week-day-column.drag-over, .day-events-column.drag-over').forEach(el => {
    el.classList.remove('drag-over');
  });
  dragMoveState = {
    isDragging: false,
    eventId: null,
    originalEvent: null,
    previewElement: null,
    currentColumn: null,
    clickOffsetY: 0
  };
}

// Listen for dragend to cleanup
document.addEventListener('dragend', cleanupDragMoveState);

async function handleDrop(event, targetDate) {
  event.preventDefault();

  // Get drop position for time calculation, accounting for click offset
  const column = event.currentTarget;
  const clickOffsetY = dragMoveState.clickOffsetY || 0;
  const adjustedClientY = event.clientY - clickOffsetY;
  const newTime = yPositionToTime(adjustedClientY, column);

  const data = JSON.parse(event.dataTransfer.getData('text/plain'));
  const { id, fromDate, type, duration } = data;

  let events = loadCalendarEvents();
  const task = events.find(e => e.id == id);
  if (!task) {
    cleanupDragMoveState();
    return;
  }

  if (type === 'duplicate') {
    // Create a duplicate on the target date - preserve all fields including location
    const newTask = {
      id: Date.now() + Math.floor(Math.random() * 10000),
      title: task.title,
      date: targetDate,
      time: task.time || null,
      endTime: task.endTime || null,
      color: task.color || 'blue',
      location: task.location || null,
      projectId: task.projectId || null,
      assignmentId: task.assignmentId || null,
      spaceId: task.spaceId || null,
      isRecurring: false,
      recurringId: null
    };
    // Use async save if authenticated
    await saveCalendarEventAsync(newTask);
    showToast(`Task duplicated to ${targetDate}`);
  } else {
    // Move task to new date AND time
    const updates = { date: targetDate };

    // Update time if we have a valid new time
    if (newTime) {
      const eventDuration = duration || calculateEventDurationMinutes(task.time, task.endTime);
      updates.time = newTime;
      updates.endTime = calculateEndTimeFromDuration(newTime, eventDuration);
    }

    // Use async update if authenticated
    await updateCalendarEventAsync(id, updates);

    // Show feedback
    if (fromDate !== targetDate) {
      showToast(`Moved to ${formatDateForToast(targetDate)} at ${formatTime12h(newTime)}`);
    } else {
      showToast(`Updated time to ${formatTime12h(newTime)}`);
    }
  }

  cleanupDragMoveState();
  saveExpandedTaskId(null);
  // Preserve scroll position when re-rendering after drag
  renderCurrentView(true);
}

// Format date for toast message
function formatDateForToast(dateStr) {
  const date = new Date(dateStr + 'T00:00:00');
  return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
}


// ============================================
// Event Resize (Drag bottom edge to change duration)
// ============================================
let resizeState = {
  isResizing: false,
  eventId: null,
  eventDate: null,
  startY: 0,
  originalHeight: 0,
  originalEndTime: null,
  cardElement: null,
  tooltipElement: null,
  startTime: null
};

function handleEventResizeStart(e, eventId, eventDate) {
  e.preventDefault();
  e.stopPropagation();

  const card = e.target.closest('.week-event-card');
  if (!card) return;

  // Get the event data
  const events = loadCalendarEvents();
  const event = events.find(ev => ev.id == eventId);
  if (!event || !event.time) return;

  // Disable dragging while resizing
  card.setAttribute('draggable', 'false');
  card.classList.add('resizing');

  resizeState = {
    isResizing: true,
    eventId: eventId,
    eventDate: eventDate,
    startY: e.clientY,
    originalHeight: card.offsetHeight,
    originalEndTime: event.endTime,
    cardElement: card,
    tooltipElement: null,
    startTime: event.time
  };

  // Create tooltip
  createResizeTooltip(e.clientX, e.clientY, event.time, event.endTime);

  document.addEventListener('mousemove', handleEventResizeMove);
  document.addEventListener('mouseup', handleEventResizeEnd);

  // Prevent text selection while resizing
  document.body.style.userSelect = 'none';
  document.body.style.cursor = 'ns-resize';
}

function handleEventResizeMove(e) {
  if (!resizeState.isResizing || !resizeState.cardElement) return;

  const deltaY = e.clientY - resizeState.startY;

  // Snap to 15-minute intervals (20px = 15 minutes, 80px = 1 hour)
  const snappedDelta = Math.round(deltaY / 20) * 20;
  const newHeight = Math.max(40, resizeState.originalHeight + snappedDelta);

  // Update card height visually
  resizeState.cardElement.style.height = `${newHeight}px`;

  // Calculate new end time based on height
  const durationMinutes = Math.round((newHeight / 80) * 60);
  const newEndTime = calculateEndTimeFromStart(resizeState.startTime, durationMinutes);

  // Update tooltip
  updateResizeTooltip(e.clientX, e.clientY, resizeState.startTime, newEndTime, durationMinutes);

  // Update time display in the card
  const timeEl = resizeState.cardElement.querySelector('.week-event-time');
  if (timeEl) {
    const startStr = formatTime12h(resizeState.startTime);
    const endStr = formatTime12h(newEndTime);
    timeEl.innerHTML = `
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
      </svg>
      ${startStr} - ${endStr}
    `;
  }
}

async function handleEventResizeEnd(e) {
  if (!resizeState.isResizing) return;

  document.removeEventListener('mousemove', handleEventResizeMove);
  document.removeEventListener('mouseup', handleEventResizeEnd);

  // Remove tooltip
  removeResizeTooltip();

  // Restore cursor and selection
  document.body.style.userSelect = '';
  document.body.style.cursor = '';

  if (resizeState.cardElement) {
    resizeState.cardElement.setAttribute('draggable', 'true');
    resizeState.cardElement.classList.remove('resizing');

    // Calculate final end time
    const finalHeight = resizeState.cardElement.offsetHeight;
    const durationMinutes = Math.round((finalHeight / 80) * 60);
    const newEndTime = calculateEndTimeFromStart(resizeState.startTime, durationMinutes);

    // Save the change if end time actually changed
    if (newEndTime !== resizeState.originalEndTime) {
      // Use async update if authenticated
      await updateCalendarEventAsync(resizeState.eventId, { endTime: newEndTime });

      // Format duration for toast
      const hours = Math.floor(durationMinutes / 60);
      const mins = durationMinutes % 60;
      let durationStr = '';
      if (hours > 0) durationStr += `${hours}h`;
      if (mins > 0) durationStr += `${mins > 0 && hours > 0 ? ' ' : ''}${mins}m`;

      showToast(`Duration updated to ${durationStr}`);
    }
  }

  // Reset state
  resizeState = {
    isResizing: false,
    eventId: null,
    eventDate: null,
    startY: 0,
    originalHeight: 0,
    originalEndTime: null,
    cardElement: null,
    tooltipElement: null,
    startTime: null
  };

  // Re-render to ensure consistency, preserve scroll position
  renderCurrentView(true);
}

function calculateEndTimeFromStart(startTime, durationMinutes) {
  if (!startTime) return '';
  const [h, m] = startTime.split(':').map(Number);
  let totalMinutes = h * 60 + m + durationMinutes;

  // Clamp to end of day (23:59)
  if (totalMinutes >= 24 * 60) totalMinutes = 24 * 60 - 1;

  const endH = Math.floor(totalMinutes / 60);
  const endM = totalMinutes % 60;
  return `${String(endH).padStart(2, '0')}:${String(endM).padStart(2, '0')}`;
}

function createResizeTooltip(x, y, startTime, endTime) {
  removeResizeTooltip();

  const tooltip = document.createElement('div');
  tooltip.className = 'resize-time-tooltip';
  tooltip.id = 'resizeTimeTooltip';

  const durationMinutes = calculateDurationMinutes(startTime, endTime);
  tooltip.innerHTML = formatTooltipContent(startTime, endTime, durationMinutes);

  tooltip.style.left = `${x + 15}px`;
  tooltip.style.top = `${y - 10}px`;

  document.body.appendChild(tooltip);
  resizeState.tooltipElement = tooltip;
}

function updateResizeTooltip(x, y, startTime, endTime, durationMinutes) {
  const tooltip = document.getElementById('resizeTimeTooltip');
  if (!tooltip) return;

  tooltip.innerHTML = formatTooltipContent(startTime, endTime, durationMinutes);
  tooltip.style.left = `${x + 15}px`;
  tooltip.style.top = `${y - 10}px`;
}

function removeResizeTooltip() {
  const tooltip = document.getElementById('resizeTimeTooltip');
  if (tooltip) tooltip.remove();
  if (resizeState.tooltipElement) resizeState.tooltipElement = null;
}

function formatTooltipContent(startTime, endTime, durationMinutes) {
  const startStr = formatTime12h(startTime);
  const endStr = formatTime12h(endTime);

  const hours = Math.floor(durationMinutes / 60);
  const mins = durationMinutes % 60;
  let durationStr = '';
  if (hours > 0) durationStr += `${hours}h`;
  if (mins > 0) durationStr += `${hours > 0 ? ' ' : ''}${mins}m`;
  if (!durationStr) durationStr = '0m';

  return `${startStr} - ${endStr}<span class="duration">${durationStr}</span>`;
}

function calculateDurationMinutes(startTime, endTime) {
  if (!startTime || !endTime) return 60;
  const [startH, startM] = startTime.split(':').map(Number);
  const [endH, endM] = endTime.split(':').map(Number);
  let duration = (endH * 60 + endM) - (startH * 60 + startM);
  if (duration <= 0) duration = 60;
  return duration;
}


// ============================================
function updateCurrentTimeIndicator() {
  // Try to find both week and day view indicators
  const weekIndicator = document.getElementById('currentTimeIndicator');
  const dayIndicator = document.getElementById('currentTimeIndicatorDay');

  const now = new Date();
  const hours = now.getHours();
  const minutes = now.getMinutes();

  // Calculate position (80px per hour, starting at 6 AM with 24-hour wrap)
  let slotIndex = hours - 6;
  if (slotIndex < 0) slotIndex += 24; // Wrap for times 0-5 (after midnight)

  const position = (slotIndex * 80) + (minutes / 60 * 80);

  // Update week view indicator
  if (weekIndicator) {
    weekIndicator.style.top = `${position}px`;
    weekIndicator.style.display = 'block';
  }

  // Update day view indicator
  if (dayIndicator) {
    dayIndicator.style.top = `${position}px`;
    dayIndicator.style.display = 'block';
  }
}

// Update time indicator every minute
setInterval(updateCurrentTimeIndicator, 60000);

// Also update when view is rendered - hook into renderCurrentView
const originalRenderCurrentView = typeof renderCurrentView === 'function' ? renderCurrentView : null;
if (originalRenderCurrentView) {
  // Will be called after view renders
}

// Call once schedule view is shown
function initCurrentTimeIndicator() {
  setTimeout(updateCurrentTimeIndicator, 100);
  initCalendarKeyboardShortcuts();
}

// ============================================
// AGENDA VIEW - Professional List View
// ============================================
function renderAgendaView(events, today) {
  const todayStr = today.toISOString().split('T')[0];

  // Get events for next 30 days
  const futureEvents = [];
  for (let i = 0; i < 30; i++) {
    const date = new Date(today);
    date.setDate(today.getDate() + i);
    const dateStr = date.toISOString().split('T')[0];

    const dayEvents = events.filter(e => e.date === dateStr).sort((a, b) => {
      if (!a.time && !b.time) return 0;
      if (!a.time) return -1;
      if (!b.time) return 1;
      return a.time.localeCompare(b.time);
    });

    if (dayEvents.length > 0) {
      futureEvents.push({ date: dateStr, dateObj: date, events: dayEvents });
    }
  }

  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'];
  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

  if (futureEvents.length === 0) {
    return `
      <div class="agenda-view-container">
        <div class="agenda-empty-state">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="3" y="4" width="18" height="18" rx="2"/>
            <path d="M16 2v4M8 2v4M3 10h18"/>
            <path d="M8 14h.01M12 14h.01M16 14h.01M8 18h.01M12 18h.01"/>
          </svg>
          <h3>No upcoming events</h3>
          <p>You're all caught up! Create a new event to get started.</p>
          <button class="btn btn-primary" onclick="openAdvancedEventModal()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
            Create Event
          </button>
        </div>
      </div>
    `;
  }

  return `
    <div class="agenda-view-container">
      <div class="agenda-header">
        <div class="agenda-summary">
          <span class="agenda-summary-count">${events.filter(e => e.date >= todayStr).length}</span>
          <span class="agenda-summary-text">upcoming events in the next 30 days</span>
        </div>
        <div class="agenda-filters">
          <input type="text" 
                 id="agendaSearchInput" 
                 class="agenda-search-input" 
                 placeholder="Filter events..." 
                 oninput="filterAgendaEvents(this.value)">
        </div>
      </div>
      
      <div class="agenda-list">
        ${futureEvents.map(day => {
    const isToday = day.date === todayStr;
    const isTomorrow = day.date === new Date(today.getTime() + 86400000).toISOString().split('T')[0];

    let dateLabel = '';
    if (isToday) {
      dateLabel = 'Today';
    } else if (isTomorrow) {
      dateLabel = 'Tomorrow';
    } else {
      dateLabel = `${dayNames[day.dateObj.getDay()]}, ${monthNames[day.dateObj.getMonth()]} ${day.dateObj.getDate()}`;
    }

    return `
            <div class="agenda-day-group ${isToday ? 'is-today' : ''}">
              <div class="agenda-day-header">
                <div class="agenda-date-label">
                  <span class="agenda-day-name">${dateLabel}</span>
                  ${!isToday && !isTomorrow ? `<span class="agenda-full-date">${day.dateObj.getFullYear()}</span>` : ''}
                </div>
                <span class="agenda-event-count">${day.events.length} event${day.events.length !== 1 ? 's' : ''}</span>
              </div>
              <div class="agenda-events-list">
                ${day.events.map(event => {
      const category = getEventCategory(event);
      const color = getCategoryColor(category);
      const timeStr = event.time ? formatTime12h(event.time) : 'All day';
      const endTimeStr = event.endTime ? ` - ${formatTime12h(event.endTime)}` : '';

      return `
                    <div class="agenda-event-card" 
                         onclick="openEditTaskModal('${event.id}')"
                         oncontextmenu="showTaskContextMenu(event, '${event.id}'); return false;">
                      <div class="agenda-event-time-block">
                        <span class="agenda-event-time">${timeStr}</span>
                        ${event.endTime ? `<span class="agenda-event-duration">${endTimeStr}</span>` : ''}
                      </div>
                      <div class="agenda-event-color-bar" style="background: ${color};"></div>
                      <div class="agenda-event-content">
                        <div class="agenda-event-title">${event.title}</div>
                        ${event.location ? `
                          <div class="agenda-event-location">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                              <circle cx="12" cy="10" r="3"/>
                            </svg>
                            ${event.location}
                          </div>
                        ` : ''}
                        ${event.description ? `<div class="agenda-event-description">${event.description.substring(0, 80)}${event.description.length > 80 ? '...' : ''}</div>` : ''}
                      </div>
                      <div class="agenda-event-actions">
                        <button class="agenda-action-btn" onclick="event.stopPropagation(); openEditTaskModal('${event.id}')" title="Edit">
                          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                        </button>
                        <button class="agenda-action-btn delete" onclick="event.stopPropagation(); deleteTask('${event.id}')" title="Delete">
                          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m5 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </button>
                      </div>
                    </div>
                  `;
    }).join('')}
              </div>
            </div>
          `;
  }).join('')}
      </div>
    </div>
  `;
}

function filterAgendaEvents(query) {
  scheduleFilters.searchQuery = query.toLowerCase();
  const cards = document.querySelectorAll('.agenda-event-card');
  cards.forEach(card => {
    const title = card.querySelector('.agenda-event-title')?.textContent.toLowerCase() || '';
    const location = card.querySelector('.agenda-event-location')?.textContent.toLowerCase() || '';
    const matches = title.includes(query.toLowerCase()) || location.includes(query.toLowerCase());
    card.style.display = matches || !query ? '' : 'none';
  });

  const groups = document.querySelectorAll('.agenda-day-group');
  groups.forEach(group => {
    const visibleCards = group.querySelectorAll('.agenda-event-card:not([style*="display: none"])');
    group.style.display = visibleCards.length > 0 ? '' : 'none';
  });
}

// ============================================
// YEAR VIEW - 12-Month Overview Grid
// ============================================
function renderYearView(events, today) {
  const year = scheduleCurrentDate.getFullYear();
  const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const todayStr = today.toISOString().split('T')[0];

  const eventsByMonth = {};
  events.forEach(event => {
    const eventDate = new Date(event.date);
    if (eventDate.getFullYear() === year) {
      const month = eventDate.getMonth();
      if (!eventsByMonth[month]) eventsByMonth[month] = [];
      eventsByMonth[month].push(event);
    }
  });

  return `
    <div class="year-view-container">
      <div class="year-header">
        <button class="year-nav-btn" onclick="navigateYear(-1)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <h2 class="year-title">${year}</h2>
        <button class="year-nav-btn" onclick="navigateYear(1)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>
        </button>
      </div>
      
      <div class="year-grid">
        ${Array.from({ length: 12 }, (_, monthIndex) => {
    const monthEvents = eventsByMonth[monthIndex] || [];
    const firstDay = new Date(year, monthIndex, 1);
    const lastDay = new Date(year, monthIndex + 1, 0);
    const startDay = firstDay.getDay();
    const daysInMonth = lastDay.getDate();

    const days = [];
    for (let i = 0; i < startDay; i++) {
      days.push({ day: null, events: [] });
    }
    for (let d = 1; d <= daysInMonth; d++) {
      const dateStr = `${year}-${String(monthIndex + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
      const dayEvents = events.filter(e => e.date === dateStr);
      days.push({
        day: d,
        dateStr,
        isToday: dateStr === todayStr,
        events: dayEvents
      });
    }

    return `
            <div class="year-month-card" onclick="navigateToMonth(${monthIndex})">
              <div class="year-month-header">
                <span class="year-month-name">${monthNames[monthIndex]}</span>
                ${monthEvents.length > 0 ? `<span class="year-month-count">${monthEvents.length}</span>` : ''}
              </div>
              <div class="year-month-grid">
                <div class="year-weekdays">
                  ${['S', 'M', 'T', 'W', 'T', 'F', 'S'].map(d => `<span>${d}</span>`).join('')}
                </div>
                <div class="year-days">
                  ${days.map(({ day, dateStr, isToday, events: dayEvents }) => {
      if (!day) return '<span class="year-day empty"></span>';

      const hasEvents = dayEvents.length > 0;
      const eventColors = [...new Set(dayEvents.map(e => getCategoryColor(getEventCategory(e))))].slice(0, 3);

      return `
                      <span class="year-day ${isToday ? 'today' : ''} ${hasEvents ? 'has-events' : ''}" 
                            onclick="event.stopPropagation(); selectYearDate('${dateStr}')"
                            title="${dayEvents.length} event${dayEvents.length !== 1 ? 's' : ''}">
                        ${day}
                        ${hasEvents ? `<span class="year-day-dots">${eventColors.map(c => `<span style="background:${c}"></span>`).join('')}</span>` : ''}
                      </span>
                    `;
    }).join('')}
                </div>
              </div>
            </div>
          `;
  }).join('')}
      </div>
    </div>
  `;
}

function navigateYear(delta) {
  scheduleCurrentDate.setFullYear(scheduleCurrentDate.getFullYear() + delta);
  renderCurrentView();
}

function navigateToMonth(monthIndex) {
  scheduleCurrentDate.setMonth(monthIndex);
  scheduleViewMode = 'month';
  renderCurrentView();
}

function selectYearDate(dateStr) {
  scheduleCurrentDate = new Date(dateStr + 'T00:00:00');
  scheduleSelectedDate = new Date(dateStr + 'T00:00:00');
  scheduleViewMode = 'day';
  renderCurrentView();
}

// ============================================
// ADVANCED EVENT MODAL (Google Calendar style)
// ============================================
function openAdvancedEventModal(prefillDate = null, prefillTime = null) {
  // Require authentication to create calendar events
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create events', 'error');
    if (typeof openAuthModal === 'function') openAuthModal();
    return;
  }

  const today = new Date();
  const date = prefillDate || today.toISOString().split('T')[0];
  const time = prefillTime || '';
  const endTime = prefillTime ? calculateEndTimeFromDuration(prefillTime, 60) : '';

  const content = `
    <form id="advancedEventForm" class="advanced-event-form" onsubmit="handleAdvancedEventSubmit(event)">
      <div class="form-group form-group-large">
        <input type="text" name="title" class="form-input form-input-title" placeholder="Add title" required autofocus>
      </div>
      
      <div class="event-type-tabs">
        <button type="button" class="event-type-tab active" data-type="event" onclick="setEventType('event')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><path d="M16 2v4M8 2v4M3 10h18"/></svg>
          Event
        </button>
        <button type="button" class="event-type-tab" data-type="task" onclick="setEventType('task')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"/></svg>
          Task
        </button>
        <button type="button" class="event-type-tab" data-type="reminder" onclick="setEventType('reminder')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 8A6 6 0 006 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 01-3.46 0"/></svg>
          Reminder
        </button>
      </div>
      <input type="hidden" name="eventType" id="eventTypeInput" value="event">
      
      <div class="form-section">
        <div class="form-section-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
        </div>
        <div class="form-section-content">
          <label class="all-day-toggle-inline">
            <input type="checkbox" id="allDayToggle" name="isAllDay" onchange="toggleAllDayEvent()">
            <span>All day</span>
          </label>
          
          <div class="date-time-grid" id="dateTimeGrid">
            <div class="form-group">
              <label class="form-label-mini">Start</label>
              <div class="datetime-inputs">
                <input type="date" name="startDate" class="form-input form-input-date" value="${date}" required>
                <select name="startTime" id="eventStartTimeAdv" class="form-select form-select-time" onchange="updateAdvancedEndTime()">
                  <option value="">Time</option>
                  ${generateTimeOptions(time)}
                </select>
              </div>
            </div>
            <div class="datetime-separator">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12h14"/></svg>
            </div>
            <div class="form-group">
              <label class="form-label-mini">End</label>
              <div class="datetime-inputs">
                <input type="date" name="endDate" class="form-input form-input-date" value="${date}">
                <select name="endTime" id="eventEndTimeAdv" class="form-select form-select-time">
                  <option value="">Time</option>
                  ${generateTimeOptions(endTime)}
                </select>
              </div>
            </div>
          </div>
          
          <div class="quick-duration-row" id="quickDurationRow">
            ${[30, 60, 90, 120, 180].map(mins => {
    const label = mins < 60 ? `${mins}m` : mins === 60 ? '1h' : `${mins / 60}h`;
    return `<button type="button" class="quick-dur-chip" onclick="setAdvancedDuration(${mins})">${label}</button>`;
  }).join('')}
          </div>
          
          <div class="form-group form-group-inline">
            <select name="recurrence" class="form-select form-select-recurrence">
              ${RECURRENCE_PATTERNS.map(p => `<option value="${p.value}">${p.label}</option>`).join('')}
            </select>
          </div>
        </div>
      </div>
      
      <div class="form-section">
        <div class="form-section-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>
        </div>
        <div class="form-section-content">
          <input type="text" name="location" class="form-input" placeholder="Add location">
        </div>
      </div>
      
      <div class="form-section">
        <div class="form-section-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2"/></svg>
        </div>
        <div class="form-section-content">
          <input type="url" name="conferenceLink" class="form-input" placeholder="Add video conferencing link">
        </div>
      </div>
      
      <div class="form-section">
        <div class="form-section-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87"/><path d="M16 3.13a4 4 0 010 7.75"/></svg>
        </div>
        <div class="form-section-content">
          <input type="text" name="attendees" class="form-input" placeholder="Add guests (comma separated emails)">
        </div>
      </div>
      
      <div class="form-section">
        <div class="form-section-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 8A6 6 0 006 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 01-3.46 0"/></svg>
        </div>
        <div class="form-section-content">
          <select name="reminder" class="form-select">
            ${REMINDER_PRESETS.map(r => `<option value="${r.value}" ${r.value === 30 ? 'selected' : ''}>${r.label}</option>`).join('')}
          </select>
        </div>
      </div>
      
      <div class="form-section">
        <div class="form-section-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/></svg>
        </div>
        <div class="form-section-content">
          <div class="category-color-row">
            <select name="category" class="form-select form-select-category" onchange="updateCategoryColor(this)">
              ${EVENT_CATEGORIES.map(c => `<option value="${c.id}" data-color="${c.color}">${c.name}</option>`).join('')}
            </select>
            <div class="color-picker-row" id="colorPicker">
              ${EVENT_CATEGORIES.map((c, i) => `
                <button type="button" class="color-dot ${i === 0 ? 'selected' : ''}" style="background: ${c.color};" data-color="${c.color}" onclick="selectEventColor(this, '${c.color}')"></button>
              `).join('')}
            </div>
          </div>
          <input type="hidden" name="color" id="selectedColorInput" value="${EVENT_CATEGORIES[0].color}">
        </div>
      </div>
      
      <div class="form-section form-section-expanded">
        <div class="form-section-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="17" y1="10" x2="3" y2="10"/><line x1="21" y1="6" x2="3" y2="6"/><line x1="21" y1="14" x2="3" y2="14"/><line x1="17" y1="18" x2="3" y2="18"/></svg>
        </div>
        <div class="form-section-content">
          <textarea name="description" class="form-textarea" rows="3" placeholder="Add description"></textarea>
        </div>
      </div>
      
      <div class="form-actions form-actions-advanced">
        <button type="button" class="btn btn-ghost" onclick="closeModal()">Cancel</button>
        <div class="form-actions-right">
          <button type="submit" class="btn btn-primary">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
            Save
          </button>
        </div>
      </div>
    </form>
  `;

  openModal('Create Event', content, 'modal-large');
}

function setEventType(type) {
  document.querySelectorAll('.event-type-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.type === type);
  });
  document.getElementById('eventTypeInput').value = type;
}

function toggleAllDayEvent() {
  const isAllDay = document.getElementById('allDayToggle').checked;
  const timeSelects = document.querySelectorAll('.form-select-time');
  const quickDuration = document.getElementById('quickDurationRow');

  timeSelects.forEach(select => {
    select.style.display = isAllDay ? 'none' : '';
    if (isAllDay) select.value = '';
  });

  if (quickDuration) {
    quickDuration.style.display = isAllDay ? 'none' : '';
  }
}

function updateAdvancedEndTime() {
  const startTime = document.getElementById('eventStartTimeAdv').value;
  const endTimeSelect = document.getElementById('eventEndTimeAdv');
  if (startTime && !endTimeSelect.value) {
    const endTime = calculateEndTimeFromDuration(startTime, 60);
    endTimeSelect.value = endTime;
  }
}

function setAdvancedDuration(minutes) {
  const startTimeEl = document.getElementById('eventStartTimeAdv');
  const endTimeSelect = document.getElementById('eventEndTimeAdv');

  if (!startTimeEl.value) {
    const now = new Date();
    const nextHour = new Date(now);
    nextHour.setHours(nextHour.getHours() + 1, 0, 0, 0);
    const startTimeStr = `${String(nextHour.getHours()).padStart(2, '0')}:00`;
    startTimeEl.value = startTimeStr;
  }

  const currentStartTime = startTimeEl.value;
  const endTime = calculateEndTimeFromDuration(currentStartTime, minutes);
  endTimeSelect.value = endTime;

  document.querySelectorAll('.quick-dur-chip').forEach(chip => chip.classList.remove('active'));
  if (event && event.target) event.target.classList.add('active');
}

function selectEventColor(btn, color) {
  document.querySelectorAll('.color-dot').forEach(dot => dot.classList.remove('selected'));
  btn.classList.add('selected');
  document.getElementById('selectedColorInput').value = color;
}

function updateCategoryColor(select) {
  const option = select.options[select.selectedIndex];
  const color = option.dataset.color;
  if (color) {
    document.getElementById('selectedColorInput').value = color;
    document.querySelectorAll('.color-dot').forEach(dot => {
      dot.classList.toggle('selected', dot.dataset.color === color);
    });
  }
}

async function handleAdvancedEventSubmit(e) {
  e.preventDefault();

  // Require authentication
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create events', 'error');
    closeModal();
    if (typeof openAuthModal === 'function') openAuthModal();
    return;
  }

  const form = e.target;
  const data = new FormData(form);

  const title = data.get('title')?.trim();
  if (!title) return;

  const startDate = data.get('startDate');
  const endDate = data.get('endDate') || startDate;
  const startTime = data.get('startTime') || null;
  const endTime = data.get('endTime') || null;
  const isAllDay = data.get('isAllDay') === 'on';
  const location = data.get('location')?.trim() || '';
  const description = data.get('description')?.trim() || '';
  const category = data.get('category') || 'default';
  const color = data.get('color') || EVENT_CATEGORIES[0].color;
  const recurrence = data.get('recurrence') || 'none';
  const reminder = parseInt(data.get('reminder')) || 30;
  const attendeesStr = data.get('attendees') || '';
  const conferenceLink = data.get('conferenceLink')?.trim() || '';

  const attendees = attendeesStr.split(',').map(a => a.trim()).filter(a => a);

  const newEvent = createEnhancedEvent({
    title,
    date: startDate,
    endDate,
    time: isAllDay ? null : startTime,
    endTime: isAllDay ? null : endTime,
    isAllDay,
    location,
    description,
    category,
    color,
    recurrence,
    reminders: [reminder],
    attendees,
    conferenceLink
  });

  // Use async save if authenticated
  await saveCalendarEventAsync(newEvent);

  closeModal();
  showToast(`Event "${title}" created successfully!`);
  renderCurrentView();
}

// goToScheduleToday - defined at end of file with enhanced scrolling

function navigateScheduleNext() {
  if (scheduleViewMode === 'day') {
    scheduleCurrentDate.setDate(scheduleCurrentDate.getDate() + 1);
  } else if (scheduleViewMode === 'week') {
    scheduleCurrentDate.setDate(scheduleCurrentDate.getDate() + 7);
  } else if (scheduleViewMode === 'month') {
    scheduleCurrentDate.setMonth(scheduleCurrentDate.getMonth() + 1);
  } else if (scheduleViewMode === 'year') {
    scheduleCurrentDate.setFullYear(scheduleCurrentDate.getFullYear() + 1);
  } else if (scheduleViewMode === 'agenda') {
    scheduleCurrentDate.setDate(scheduleCurrentDate.getDate() + 30);
  }
  renderCurrentView();
  // Reinitialize swipe functionality after navigation
  setTimeout(() => {
    initCalendarSwipe();
  }, 100);
}

function navigateSchedulePrev() {
  if (scheduleViewMode === 'day') {
    scheduleCurrentDate.setDate(scheduleCurrentDate.getDate() - 1);
  } else if (scheduleViewMode === 'week') {
    scheduleCurrentDate.setDate(scheduleCurrentDate.getDate() - 7);
  } else if (scheduleViewMode === 'month') {
    scheduleCurrentDate.setMonth(scheduleCurrentDate.getMonth() - 1);
  } else if (scheduleViewMode === 'year') {
    scheduleCurrentDate.setFullYear(scheduleCurrentDate.getFullYear() - 1);
  } else if (scheduleViewMode === 'agenda') {
    scheduleCurrentDate.setDate(scheduleCurrentDate.getDate() - 30);
  }
  renderCurrentView();
  // Reinitialize swipe functionality after navigation
  setTimeout(() => {
    initCalendarSwipe();
  }, 100);
}

function toggleCalendarSearch() {
  const searchContainer = document.getElementById('calendarSearchContainer');
  if (searchContainer) {
    const isHidden = searchContainer.style.display === 'none';
    searchContainer.style.display = isHidden ? 'flex' : 'none';
    if (isHidden) {
      const input = searchContainer.querySelector('input');
      if (input) input.focus();
    }
  }
}


// Duplicate a calendar task - opens modal to select date
function duplicateCalendarTask(eventId) {
  const events = loadCalendarEvents();
  // Use == for type coercion (eventId may be string or number)
  const task = events.find(e => e.id == eventId);
  if (!task) return;

  const today = new Date().toISOString().split('T')[0];

  const content = `
    <form id="duplicateTaskForm" onsubmit="handleDuplicateTaskSubmit(event, ${eventId})">
      <div class="form-group">
        <label class="form-label">Duplicate Task</label>
        <p style="color: var(--muted-foreground); font-size: 14px; margin-bottom: 16px;">
          Creating a copy of "<strong>${task.title}</strong>"
        </p>
      </div>
      <div class="form-group">
        <label class="form-label">Select new date <span class="required">*</span></label>
        <input type="date" name="date" class="form-input" value="${today}" required>
      </div>
      <div class="form-group">
        <label class="form-label">Time (optional)</label>
        <input type="time" name="time" class="form-input" value="${task.time || ''}">
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Duplicate Task</button>
      </div>
    </form>
  `;
  openModal('Duplicate Task', content);
}

async function handleDuplicateTaskSubmit(e, originalEventId) {
  e.preventDefault();
  const form = e.target;
  const data = new FormData(form);

  const date = data.get('date');
  const time = data.get('time');

  if (!date) return;

  const events = loadCalendarEvents();
  // Use == for type coercion
  const originalTask = events.find(ev => ev.id == originalEventId);
  if (!originalTask) return;

  const newTask = {
    id: Date.now() + Math.floor(Math.random() * 10000),
    title: originalTask.title,
    date: date,
    time: time || originalTask.time || null,
    endTime: originalTask.endTime || null,
    color: originalTask.color || 'blue',
    location: originalTask.location || null,
    projectId: originalTask.projectId || null,
    assignmentId: originalTask.assignmentId || null,
    spaceId: originalTask.spaceId || null,
    isRecurring: false,
    recurringId: null
  };

  // Use async save if authenticated
  await saveCalendarEventAsync(newTask);

  closeModal();
  showToast('Task duplicated successfully!');
  // Preserve scroll when duplicating task
  renderCurrentView(true);
}

// Navigation
window.prevMonth = () => { currentCalendarMonth.setMonth(currentCalendarMonth.getMonth() - 1); renderCurrentView(); };
window.nextMonth = () => { currentCalendarMonth.setMonth(currentCalendarMonth.getMonth() + 1); renderCurrentView(); };
window.goToToday = () => { currentCalendarMonth = new Date(); renderCurrentView(); };

// Generate time options for dropdown (Google Calendar style - 15 min intervals for precise drag selection)
function generateTimeOptions(selectedTime = '') {
  const times = [];
  for (let h = 0; h < 24; h++) {
    for (let m = 0; m < 60; m += 15) {
      const hour24 = String(h).padStart(2, '0');
      const min = String(m).padStart(2, '0');
      const value = `${hour24}:${min}`;

      // Format for display (12-hour)
      const hour12 = h === 0 ? 12 : h > 12 ? h - 12 : h;
      const ampm = h < 12 ? 'AM' : 'PM';
      const label = `${hour12}:${min} ${ampm}`;

      const selected = value === selectedTime ? 'selected' : '';
      times.push(`<option value="${value}" ${selected}>${label}</option>`);
    }
  }
  return times.join('');
}

// Calculate duration between two times
function calculateDuration(startTime, endTime) {
  if (!startTime || !endTime) return '';

  const [startH, startM] = startTime.split(':').map(Number);
  const [endH, endM] = endTime.split(':').map(Number);

  let startMinutes = startH * 60 + startM;
  let endMinutes = endH * 60 + endM;

  // Handle next day
  if (endMinutes <= startMinutes) {
    endMinutes += 24 * 60;
  }

  const diffMinutes = endMinutes - startMinutes;
  const hours = Math.floor(diffMinutes / 60);
  const minutes = diffMinutes % 60;

  if (hours === 0) {
    return `${minutes} min`;
  } else if (minutes === 0) {
    return hours === 1 ? '1 hour' : `${hours} hours`;
  } else {
    return `${hours}h ${minutes}m`;
  }
}

// Update end time based on start time and duration
function updateEndTimeFromDuration(duration) {
  const startSelect = document.getElementById('eventStartTime');
  const endSelect = document.getElementById('eventEndTime');
  if (!startSelect || !endSelect) return;

  const startTime = startSelect.value;
  if (!startTime) return;

  const [startH, startM] = startTime.split(':').map(Number);
  let endMinutes = startH * 60 + startM + duration;

  // Wrap around if past midnight
  if (endMinutes >= 24 * 60) {
    endMinutes = endMinutes % (24 * 60);
  }

  const endH = Math.floor(endMinutes / 60);
  const endM = endMinutes % 60;
  const endTime = `${String(endH).padStart(2, '0')}:${String(endM).padStart(2, '0')}`;

  endSelect.value = endTime;
  updateDurationHint();
}

// Update duration hint display
function updateDurationHint() {
  const startSelect = document.getElementById('eventStartTime');
  const endSelect = document.getElementById('eventEndTime');
  const durationHint = document.getElementById('durationHint');

  if (!startSelect || !endSelect || !durationHint) return;

  const duration = calculateDuration(startSelect.value, endSelect.value);
  durationHint.textContent = duration ? `Duration: ${duration}` : '';
}

// Set default end time (1 hour after start)
function setDefaultEndTime() {
  const startSelect = document.getElementById('eventStartTime');
  const endSelect = document.getElementById('eventEndTime');

  if (!startSelect || !endSelect) return;

  const startTime = startSelect.value;
  if (!startTime) return;

  const [startH, startM] = startTime.split(':').map(Number);
  let endH = startH + 1;
  if (endH >= 24) endH = endH - 24;

  const endTime = `${String(endH).padStart(2, '0')}:${String(startM).padStart(2, '0')}`;
  endSelect.value = endTime;
  updateDurationHint();
}

// Create modal with Google Calendar style time picker
function openCreateEventModal(defaultDate = null) {
  const todayStr = new Date().toISOString().split('T')[0];
  const dateValue = defaultDate || todayStr;

  // Default start time: next hour
  const now = new Date();
  const defaultStartHour = now.getHours() + 1;
  const defaultStart = `${String(defaultStartHour % 24).padStart(2, '0')}:00`;
  const defaultEnd = `${String((defaultStartHour + 1) % 24).padStart(2, '0')}:00`;

  const content = `
    <form id="createEventForm" onsubmit="handleCreateEventSubmit(event, '${dateValue}')">
      <div class="form-group">
        <label>Title <span class="required">*</span></label>
        <input type="text" name="title" class="form-input" required placeholder="Meeting / Deadline / Task..." autofocus>
      </div>
      
      <div class="form-group">
        <label>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;vertical-align:middle;margin-right:4px;">
            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
            <circle cx="12" cy="10" r="3"/>
          </svg>
          Location
        </label>
        <input type="text" name="location" class="form-input" placeholder="Add location...">
      </div>
      
      <div class="time-picker-group">
        <div class="time-picker-group-header">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
          </svg>
          Time
        </div>
        
        <div class="time-picker-row">
          <span class="time-picker-label">From</span>
          <div class="time-picker-select-wrapper">
            <select id="eventStartTime" name="startTime" class="time-picker-select" onchange="setDefaultEndTime()">
              <option value="">No time</option>
              ${generateTimeOptions(defaultStart)}
            </select>
          </div>
          <span class="time-picker-divider">→</span>
          <div class="time-picker-select-wrapper">
            <select id="eventEndTime" name="endTime" class="time-picker-select" onchange="updateDurationHint()">
              <option value="">No time</option>
              ${generateTimeOptions(defaultEnd)}
            </select>
          </div>
        </div>
        
        <div class="time-duration-hint" id="durationHint">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/>
          </svg>
          <span>Duration: 1 hour</span>
        </div>
        
        <div class="quick-duration-btns">
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(30)">30 min</button>
          <button type="button" class="quick-duration-btn active" onclick="updateEndTimeFromDuration(60)">1 hour</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(90)">1.5 hours</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(120)">2 hours</button>
          <button type="button" class="quick-duration-btn" onclick="updateEndTimeFromDuration(180)">3 hours</button>
        </div>
      </div>
      
      <div class="form-group">
        <label>Color</label>
        <select name="color" class="form-select">
          <option value="blue">Blue</option>
          <option value="green">Green</option>
          <option value="purple">Purple</option>
          <option value="orange">Orange</option>
          <option value="red">Red</option>
        </select>
      </div>
      
      <!-- Repeat Section -->
      <div class="form-group-collapsible">
        <div class="form-collapsible-header" onclick="toggleRepeatSection()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <path d="M17 1l4 4-4 4"/>
            <path d="M3 11V9a4 4 0 0 1 4-4h14"/>
            <path d="M7 23l-4-4 4-4"/>
            <path d="M21 13v2a4 4 0 0 1-4 4H3"/>
          </svg>
          <span>Repeat</span>
          <span class="repeat-summary-badge" id="repeatSummaryBadge" style="display:none;"></span>
          <svg class="form-collapsible-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
            <path d="M6 9l6 6 6-6"/>
          </svg>
        </div>
        <div class="form-collapsible-content" id="repeatSection">
          <div class="repeat-options-grid">
            <div class="form-group-inline">
              <label>Frequency</label>
              <select name="repeatType" class="form-select form-select-sm" onchange="handleRepeatTypeChange(this.value, '${dateValue}')">
                <option value="none">Does not repeat</option>
                <option value="daily">Daily</option>
                <option value="weekly">Weekly on ${new Date(dateValue).toLocaleDateString('en-US', { weekday: 'long' })}</option>
                <option value="weekdays">Every weekday (Mon-Fri)</option>
                <option value="biweekly">Bi-weekly</option>
                <option value="monthly">Monthly on day ${new Date(dateValue).getDate()}</option>
                <option value="custom">Custom...</option>
              </select>
            </div>
          </div>
          
          <!-- Custom Days Selection (hidden by default) -->
          <div class="repeat-custom-days" id="repeatCustomDays" style="display:none;">
            <label class="form-label" style="font-size:12px; margin-bottom:8px;">Repeat on</label>
            <div class="repeat-days-grid">
              ${['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, i) => `
                <label class="repeat-day-chip ${i === new Date(dateValue).getDay() ? 'selected' : ''}">
                  <input type="checkbox" name="repeatDays" value="${i}" ${i === new Date(dateValue).getDay() ? 'checked' : ''} onchange="updateRepeatDayChip(this)">
                  <span>${day}</span>
                </label>
              `).join('')}
            </div>
          </div>
          
          <!-- End Repeat Options (hidden when none) -->
          <div class="repeat-end-options" id="repeatEndOptions" style="display:none;">
            <div class="form-group-inline" style="margin-top:12px;">
              <label>Ends</label>
              <select name="repeatEndType" class="form-select form-select-sm" onchange="handleRepeatEndTypeChange(this.value)">
                <option value="never">Never</option>
                <option value="after">After occurrences</option>
                <option value="on">On date</option>
              </select>
            </div>
            
            <div class="repeat-end-after" id="repeatEndAfter" style="display:none; margin-top:8px;">
              <div style="display:flex; align-items:center; gap:8px;">
                <input type="number" name="repeatCount" class="form-input form-input-sm" value="10" min="1" max="365" style="width:70px;">
                <span style="color:var(--muted-foreground); font-size:13px;">occurrences</span>
              </div>
            </div>
            
            <div class="repeat-end-on" id="repeatEndOn" style="display:none; margin-top:8px;">
              <input type="date" name="repeatEndDate" class="form-input form-input-sm" value="${getDefaultRepeatEndDate(dateValue)}">
            </div>
          </div>
        </div>
      </div>
      
      <!-- Link to Project, Assignment, or Space -->
      <div class="form-group-collapsible">
        <div class="form-collapsible-header collapsed" onclick="toggleEventLinksSection()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
          </svg>
          <span>Link to Project / Assignment / Space</span>
          <svg class="form-collapsible-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
            <path d="M6 9l6 6 6-6"/>
          </svg>
        </div>
        <div class="form-collapsible-content collapsed" id="eventLinksSection">
          <div class="form-row-triple">
            <div class="form-group-inline">
              <label>Project</label>
              <select name="projectId" class="form-select form-select-sm">
                ${generateProjectOptions()}
              </select>
            </div>
            <div class="form-group-inline">
              <label>Assignment</label>
              <select name="assignmentId" class="form-select form-select-sm">
                ${generateAssignmentOptions()}
              </select>
            </div>
            <div class="form-group-inline">
              <label>Space</label>
              <select name="spaceId" class="form-select form-select-sm">
                ${generateSpaceOptions()}
              </select>
            </div>
          </div>
        </div>
      </div>
      
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Create</button>
      </div>
    </form>
  `;
  openModal('New Task / Event', content);
}

async function handleCreateEventSubmit(e, date) {
  e.preventDefault();
  const form = e.target;
  const data = new FormData(form);

  const title = data.get('title')?.trim();
  const startTime = data.get('startTime');
  const endTime = data.get('endTime');
  const color = data.get('color') || 'blue';
  const location = data.get('location')?.trim() || null;

  // Handle project/assignment/space IDs - convert empty strings to null
  const projectIdValue = data.get('projectId');
  const projectId = projectIdValue && projectIdValue !== '' ? projectIdValue : null;

  const assignmentIdValue = data.get('assignmentId');
  const assignmentId = assignmentIdValue && assignmentIdValue !== '' ? assignmentIdValue : null;

  const spaceIdValue = data.get('spaceId');
  const spaceId = spaceIdValue && spaceIdValue !== '' ? spaceIdValue : null;

  // Repeat options
  const repeatType = data.get('repeatType') || 'none';
  const repeatEndType = data.get('repeatEndType') || 'never';
  const repeatCount = parseInt(data.get('repeatCount')) || 10;
  const repeatEndDate = data.get('repeatEndDate') || null;
  const repeatDays = data.getAll('repeatDays').map(Number);

  if (!title) return;

  // If no repeat, create single event
  if (repeatType === 'none') {
    const newEvent = {
      id: Date.now(),
      title,
      date,
      time: startTime || null,
      endTime: endTime || null,
      color,
      location,
      projectId,
      assignmentId,
      spaceId
    };
    // Use async save if authenticated
    await saveCalendarEventAsync(newEvent);
    saveExpandedTaskId(newEvent.id);
    // Close appropriate form based on which one is present
    const dropdown = document.getElementById('eventDropdownForm');
    if (dropdown) {
      closeEventDropdown();
    } else {
      closeModal();
    }
    renderCurrentView();
    return;
  }

  // Create recurring task rule
  const recurringId = Date.now();
  const startDate = new Date(date);

  // Determine which days to repeat on
  let daysToRepeat = [];
  switch (repeatType) {
    case 'daily':
      daysToRepeat = [0, 1, 2, 3, 4, 5, 6];
      break;
    case 'weekly':
      daysToRepeat = [startDate.getDay()];
      break;
    case 'weekdays':
      daysToRepeat = [1, 2, 3, 4, 5];
      break;
    case 'biweekly':
      daysToRepeat = [startDate.getDay()];
      break;
    case 'monthly':
      // Monthly is handled differently
      break;
    case 'custom':
      daysToRepeat = repeatDays.length > 0 ? repeatDays : [startDate.getDay()];
      break;
  }

  // Calculate end date for repeat
  let endRepeatDate = null;
  if (repeatEndType === 'after') {
    endRepeatDate = new Date(startDate);
    endRepeatDate.setDate(endRepeatDate.getDate() + (repeatCount * 7)); // Approximate
  } else if (repeatEndType === 'on' && repeatEndDate) {
    endRepeatDate = new Date(repeatEndDate);
  } else {
    // Default: 3 months from now
    endRepeatDate = new Date(startDate);
    endRepeatDate.setMonth(endRepeatDate.getMonth() + 3);
  }

  // Generate all recurring event instances
  const generatedEvents = generateRecurringEvents({
    recurringId,
    title,
    startDate,
    endRepeatDate,
    repeatType,
    daysToRepeat,
    repeatCount: repeatEndType === 'after' ? repeatCount : null,
    startTime: startTime || null,
    endTime: endTime || null,
    color,
    location,
    projectId,
    assignmentId,
    spaceId
  });

  // Save all generated events using async if authenticated
  for (const event of generatedEvents) {
    await saveCalendarEventAsync(event);
  }

  // Save recurring rule for future reference
  const recurringTasks = loadRecurringTasks();
  recurringTasks.push({
    id: recurringId,
    title,
    time: startTime || null,
    endTime: endTime || null,
    color,
    location,
    days: daysToRepeat,
    repeatType,
    repeatEndType,
    repeatCount: repeatEndType === 'after' ? repeatCount : null,
    repeatEndDate: repeatEndType === 'on' ? repeatEndDate : null,
    startDate: date,
    projectId,
    assignmentId,
    spaceId
  });
  saveRecurringTasks(recurringTasks);

  if (generatedEvents.length > 0) {
    saveExpandedTaskId(generatedEvents[0].id);
  }

  // Close appropriate form based on which one is present
  const dropdown = document.getElementById('eventDropdownForm');
  if (dropdown) {
    closeEventDropdown();
  } else {
    closeModal();
  }
  showToast(`Created ${generatedEvents.length} recurring events`);
  renderCurrentView();
}

// Generate recurring event instances
function generateRecurringEvents(config) {
  const {
    recurringId, title, startDate, endRepeatDate, repeatType, daysToRepeat,
    repeatCount, startTime, endTime, color, location, projectId, assignmentId, spaceId
  } = config;

  const events = [];
  const current = new Date(startDate);
  let count = 0;
  const maxIterations = 365; // Safety limit
  let iterations = 0;

  while (current <= endRepeatDate && iterations < maxIterations) {
    iterations++;

    if (repeatCount && count >= repeatCount) break;

    let shouldAdd = false;

    if (repeatType === 'monthly') {
      // Monthly: same day of month
      if (current.getDate() === startDate.getDate()) {
        shouldAdd = true;
      }
    } else if (repeatType === 'biweekly') {
      // Biweekly: every 2 weeks on same day
      const weeksDiff = Math.floor((current - startDate) / (7 * 24 * 60 * 60 * 1000));
      if (weeksDiff % 2 === 0 && current.getDay() === startDate.getDay()) {
        shouldAdd = true;
      }
    } else {
      // Daily, weekly, weekdays, custom
      if (daysToRepeat.includes(current.getDay())) {
        shouldAdd = true;
      }
    }

    if (shouldAdd) {
      events.push({
        id: Date.now() + count + Math.floor(Math.random() * 100000),
        title,
        date: current.toISOString().split('T')[0],
        time: startTime,
        endTime: endTime,
        color,
        location,
        isRecurring: true,
        recurringId,
        projectId,
        assignmentId,
        spaceId
      });
      count++;
    }

    current.setDate(current.getDate() + 1);
  }

  return events;
}

// Repeat UI Helper Functions
function toggleRepeatSection() {
  const section = document.getElementById('repeatSection');
  const header = section?.previousElementSibling;
  if (section) {
    section.classList.toggle('open');
    header?.classList.toggle('open');
  }
}

function handleRepeatTypeChange(value, dateValue) {
  const customDays = document.getElementById('repeatCustomDays');
  const endOptions = document.getElementById('repeatEndOptions');
  const badge = document.getElementById('repeatSummaryBadge');

  if (customDays) {
    customDays.style.display = value === 'custom' ? 'block' : 'none';
  }

  if (endOptions) {
    endOptions.style.display = value !== 'none' ? 'block' : 'none';
  }

  // Update badge
  if (badge) {
    if (value === 'none') {
      badge.style.display = 'none';
    } else {
      badge.style.display = 'inline-flex';
      const labels = {
        'daily': 'Daily',
        'weekly': 'Weekly',
        'weekdays': 'Weekdays',
        'biweekly': 'Bi-weekly',
        'monthly': 'Monthly',
        'custom': 'Custom'
      };
      badge.textContent = labels[value] || value;
    }
  }
}

function handleRepeatEndTypeChange(value) {
  const afterDiv = document.getElementById('repeatEndAfter');
  const onDiv = document.getElementById('repeatEndOn');

  if (afterDiv) afterDiv.style.display = value === 'after' ? 'block' : 'none';
  if (onDiv) onDiv.style.display = value === 'on' ? 'block' : 'none';
}

function updateRepeatDayChip(checkbox) {
  const label = checkbox.closest('.repeat-day-chip');
  if (label) {
    label.classList.toggle('selected', checkbox.checked);
  }
}

function getDefaultRepeatEndDate(startDate) {
  const date = new Date(startDate);
  date.setMonth(date.getMonth() + 1);
  return date.toISOString().split('T')[0];
}



/* ============================================
   Layer - Activities/Projects View
   ============================================ */

function renderActivityView(searchQuery = '') {
  let projects = loadProjects();
  console.log('renderActivityView called with', projects.length, 'projects');

  if (searchQuery) {
    const query = searchQuery.toLowerCase();
    projects = projects.filter(p =>
      p.name.toLowerCase().includes(query) ||
      (p.description && p.description.toLowerCase().includes(query))
    );
  }

  if (projects.length === 0) {
    return `
      <div class="projects-container">
        <div class="view-header" style="border: none; padding: 0; margin-bottom: 24px;">
          <h2 class="view-title">Projects</h2>
          <button class="btn btn-primary" onclick="openCreateProjectModal()">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
            Create project
          </button>
        </div>
        <div class="empty-state">
          <div class="empty-state-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:48px;height:48px;color:var(--muted-foreground);">
              <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
            </svg>
          </div>
          <h3 class="empty-state-title">No projects yet</h3>
          <p class="empty-state-text">Get started by creating your first project</p>
          <button class="btn btn-primary" onclick="openCreateProjectModal()">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
            Create Project
          </button>
        </div>
      </div>
    `;
  }

  return `
    <div class="projects-container" style="padding: 24px;">
      <div class="view-header" style="border: none; padding: 0; margin-bottom: 24px; display: flex; align-items: center; justify-content: space-between;">
        <h2 class="view-title" style="font-size: 24px; font-weight: 600; margin: 0;">Workspace</h2>
        <div style="display: flex; align-items: center; gap: 8px;">
          <button class="btn btn-ghost workspace-action-btn" onclick="exportAllProjects()" title="Export Projects">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
          </button>
          <button class="btn btn-ghost workspace-action-btn" onclick="importProjects()" title="Import Projects">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
          </button>
          <button class="btn btn-primary" onclick="openCreateProjectModal()">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
            New Project
          </button>
        </div>
      </div>
      <input type="file" id="projectImportInput" accept=".json" style="display: none;" onchange="handleProjectImport(event)" />
      
      <div class="workspace-projects-grid">
        ${projects.map((project, index) => {
    const { total, completed, percentage } = calculateProgress(project.columns);
    const statusColor = getStatusColor(project.status);
    const isStarted = project.status !== 'todo' || percentage > 0;

    // Get linked space docs/excels
    const linkedSpace = project.linkedSpaceId ? loadSpaces().find(s => s.id === project.linkedSpaceId) : null;
    const spaceDocs = linkedSpace ? loadDocs().filter(d => d.spaceId === linkedSpace.id) : [];
    const spaceExcels = linkedSpace ? loadExcels().filter(e => e.spaceId === linkedSpace.id) : [];

    return `
            <div class="workspace-project-card" onclick="openProjectDetail(${index})">
              <!-- Card Header -->
              <div class="workspace-card-header">
                <div class="workspace-card-icon">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                  </svg>
                </div>
                <div class="workspace-card-title-area">
                  <h3 class="workspace-card-title">${project.name}</h3>
                  ${project.description ? `<p class="workspace-card-description">${project.description}</p>` : ''}
                </div>
                <div class="workspace-card-status ${project.status}">${capitalizeStatus(project.status)}</div>
                <div class="workspace-card-actions">
                  ${!isStarted ? `
                    <button class="workspace-card-action-btn" onclick="event.stopPropagation(); startProject(${index})" title="Start Project">
                      <svg viewBox="0 0 24 24" fill="currentColor" stroke="none" style="width:14px;height:14px;">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                      </svg>
                    </button>
                  ` : ''}
                  <button class="workspace-card-action-btn delete" onclick="event.stopPropagation(); handleDeleteProject(${index})" title="Delete">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                      <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                  </button>
                </div>
              </div>
              
              <!-- Card Body -->
              <div class="workspace-card-body">
                <div class="workspace-card-meta">
                  <div class="workspace-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2"/>
                      <rect x="9" y="3" width="6" height="4" rx="1"/>
                    </svg>
                    <span>${total} tasks</span>
                  </div>
                  <div class="workspace-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <circle cx="12" cy="12" r="10"/>
                      <path d="M8 12l2 2 4-4"/>
                    </svg>
                    <span>${completed} done</span>
                  </div>
                  ${linkedSpace ? `
                    <div class="workspace-meta-item" style="color: var(--primary);">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                      </svg>
                      <span>${linkedSpace.name}</span>
                    </div>
                  ` : ''}
                </div>
                
                <!-- Progress -->
                <div class="workspace-card-progress">
                  <div class="workspace-progress-header">
                    <span class="workspace-progress-label">Progress</span>
                    <span class="workspace-progress-value">${percentage}%</span>
                  </div>
                  <div class="workspace-progress-bar">
                    <div class="workspace-progress-fill" style="width: ${percentage}%; background: ${getProgressColor(percentage)};"></div>
                  </div>
                </div>
              </div>
              
              <!-- Card Footer -->
              <div class="workspace-card-footer">
                <div class="workspace-card-date">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="4" width="18" height="18" rx="2"/>
                    <path d="M16 2v4M8 2v4M3 10h18"/>
                  </svg>
                  <span>${formatDate(project.targetDate)}</span>
                </div>
                ${(spaceDocs.length > 0 || spaceExcels.length > 0) ? `
                  <div class="workspace-card-linked-docs">
                    ${spaceDocs.length > 0 ? `
                      <span class="linked-doc-badge doc">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                          <polyline points="14 2 14 8 20 8"/>
                        </svg>
                        ${spaceDocs.length}
                      </span>
                    ` : ''}
                    ${spaceExcels.length > 0 ? `
                      <span class="linked-doc-badge excel">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <rect x="3" y="3" width="18" height="18" rx="2"/>
                          <line x1="3" y1="9" x2="21" y2="9"/>
                          <line x1="9" y1="3" x2="9" y2="21"/>
                        </svg>
                        ${spaceExcels.length}
                      </span>
                    ` : ''}
                  </div>
                ` : ''}
              </div>
            </div>
          `;
  }).join('')}
      </div>
    </div>
  `;
}

function renderProjectDetailView(projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];

  if (!project) return '';

  const { total, completed, percentage } = calculateProgress(project.columns);

  // Dynamic status based on progress
  let dynamicStatus = 'backlog';
  if (percentage === 0) {
    dynamicStatus = 'backlog';
  } else if (percentage > 0 && percentage < 100) {
    dynamicStatus = 'in-progress';
  } else if (percentage === 100) {
    dynamicStatus = 'done';
  }

  const statusColor = getStatusColor(dynamicStatus);
  const teamMembers = project.teamMembers || ['You'];
  const projectPriority = project.priority;
  const projectComments = project.comments || [];
  const milestones = project.milestones || [];

  // Check if current user is project leader
  const isLeader = isProjectLeader(project);
  const currentUserEmail = window.LayerDB?.getCurrentUser()?.email || getCurrentUserEmail();
  const isTeamMember = teamMembers.includes(currentUserEmail) || teamMembers.includes('You');

  // Generate activity log
  const activityLog = generateActivityLog(project, projectIndex);

  // Format dates
  const startDateFormatted = formatDateAdvanced(project.startDate || new Date().toISOString());
  const targetDateFormatted = formatDateAdvanced(project.targetDate);

  const isSidebarCollapsed = localStorage.getItem('pdSidebarCollapsed') === 'true';

  return `
    <div class="project-detail-advanced">
      <!-- Advanced Header with Breadcrumb & Tabs -->
      <header class="pd-header">
        <div class="pd-header-left">
          <nav class="pd-breadcrumb">
            <button class="pd-breadcrumb-btn" onclick="closeProjectDetail()" title="Back to Projects">
              <span class="pd-breadcrumb-icon">✦</span>
              <span>Projects</span>
            </button>
            <svg class="pd-breadcrumb-arrow" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M9 18l6-6-6-6"/>
            </svg>
            <div class="pd-breadcrumb-current">
              <span class="pd-project-icon-mini">◇</span>
              <span class="pd-project-name-mini">${project.name}</span>
            </div>
            <button class="pd-star-btn" onclick="toggleProjectStar(${projectIndex})" title="Star project">
              <svg viewBox="0 0 24 24" fill="${project.starred ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
              </svg>
            </button>
          </nav>
          
          <div class="pd-tabs">
            <button class="pd-tab ${typeof currentProjectTab !== 'undefined' && currentProjectTab === 'overview' ? 'active' : (typeof currentProjectTab !== 'undefined' && currentProjectTab === 'timeline' ? '' : 'active')}" data-tab="overview" onclick="switchProjectTab('overview', ${projectIndex})">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/>
              </svg>
              Project detail
            </button>
            <button class="pd-tab ${typeof currentProjectTab !== 'undefined' && currentProjectTab === 'timeline' ? 'active' : ''}" data-tab="timeline" onclick="switchProjectTab('timeline', ${projectIndex})">
              <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <style>
                  @keyframes docPop {
                    0%, 100% {
                      transform: scale(1);
                    }
                    50% {
                      transform: scale(1.08);
                    }
                  }
                  
                  @keyframes lineType {
                    0% {
                      stroke-dashoffset: 10;
                      transform: scaleX(0);
                      opacity: 0;
                    }
                    100% {
                      stroke-dashoffset: 0;
                      transform: scaleX(1);
                      opacity: 1;
                    }
                  }
                  
                  @keyframes linePulse {
                    0%, 100% {
                      stroke-width: 2;
                    }
                    50% {
                      stroke-width: 2.5;
                    }
                  }
                  
                  .pd-tab:hover .doc-frame {
                    animation: docPop 0.4s ease-in-out;
                  }
                  
                  .pd-tab:hover .text-line {
                    animation: lineType 0.4s ease-out, linePulse 0.5s ease-in-out;
                    stroke-dasharray: 10;
                    transform-origin: left;
                  }
                  
                  .pd-tab:hover .text-line:nth-child(2) {
                    animation-delay: 0.1s;
                  }
                  
                  .pd-tab:hover .text-line:nth-child(3) {
                    animation-delay: 0.2s;
                  }
                </style>
                
                <rect class="doc-frame" x="3" y="4" width="18" height="18" rx="2"></rect>
                <line class="text-line" x1="9" y1="8" x2="15" y2="8"></line>
                <line class="text-line" x1="9" y1="12" x2="19" y2="12"></line>
                <line class="text-line" x1="9" y1="16" x2="13" y2="16"></line>
              </svg>
              Gantt
            </button>
            <button class="pd-tab" onclick="openGripDiagram(${projectIndex})">
              <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <style>
                  @keyframes boardPop {
                    0%, 100% {
                      transform: scale(1);
                    }
                    50% {
                      transform: scale(1.08);
                    }
                  }
                  
                  @keyframes drawLine {
                    0% {
                      stroke-dashoffset: 20;
                      opacity: 0;
                    }
                    100% {
                      stroke-dashoffset: 0;
                      opacity: 1;
                    }
                  }
                  
                  @keyframes penWrite {
                    0%, 100% {
                      transform: translate(0, 0) rotate(0deg);
                    }
                    25% {
                      transform: translate(-2px, -2px) rotate(-10deg);
                    }
                    50% {
                      transform: translate(2px, -1px) rotate(5deg);
                    }
                    75% {
                      transform: translate(-1px, -2px) rotate(-5deg);
                    }
                  }
                  
                  .pd-tab:hover .board-content {
                    animation: boardPop 0.4s ease-in-out;
                  }
                  
                  .pd-tab:hover .board-line {
                    animation: drawLine 0.4s ease-out;
                    stroke-dasharray: 20;
                  }
                  
                  .pd-tab:hover .board-line:nth-child(2) {
                    animation-delay: 0.1s;
                  }
                  
                  .pd-tab:hover .board-line:nth-child(3) {
                    animation-delay: 0.2s;
                  }
                  
                  .pd-tab:hover .pen {
                    animation: penWrite 0.6s ease-in-out;
                    transform-origin: bottom right;
                  }
                </style>
                
                <!-- Whiteboard frame -->
                <g class="board-content">
                  <rect x="2" y="3" width="18" height="14" rx="1"></rect>
                  
                  <!-- Content lines on board -->
                  <line class="board-line" x1="5" y1="7" x2="11" y2="7"></line>
                  <line class="board-line" x1="5" y1="10" x2="14" y2="10"></line>
                  <line class="board-line" x1="5" y1="13" x2="9" y2="13"></line>
                </g>
                
                <!-- Stand legs -->
                <line x1="6" y1="17" x2="5" y2="22"></line>
                <line x1="16" y1="17" x2="17" y2="22"></line>
                
                <!-- Pen/marker (more prominent) -->
                <g class="pen">
                  <path d="M18 14l3 3"></path>
                  <path d="M17 13l1-1 3 3-1 1z"></path>
                  <line x1="21" y1="16" x2="22" y2="17"></line>
                </g>
              </svg>
              Whiteboard
            </button>
            <button class="pd-tab ${typeof currentProjectTab !== 'undefined' && currentProjectTab === 'backlog' ? 'active' : ''}" data-tab="backlog" onclick="switchProjectTab('backlog', ${projectIndex})">
              <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <style>
                  @keyframes clipboardPop {
                    0%, 100% {
                      transform: scale(1) translateY(0);
                    }
                    50% {
                      transform: scale(1.1) translateY(-2px);
                    }
                  }
                  
                  @keyframes checkmark {
                    0% {
                      stroke-dashoffset: 20;
                      opacity: 0;
                    }
                    50% {
                      opacity: 1;
                    }
                    100% {
                      stroke-dashoffset: 0;
                      opacity: 0;
                    }
                  }
                  
                  .pd-tab:hover .icon .clipboard-body {
                    animation: clipboardPop 0.5s ease-in-out;
                  }
                  
                  .pd-tab:hover .icon .checkmark {
                    animation: checkmark 0.6s ease-in-out;
                  }
                  
                  .checkmark {
                    opacity: 0;
                    stroke-dasharray: 20;
                    stroke-dashoffset: 20;
                  }
                </style>
                
                <g class="clipboard-body">
                  <path d="M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2"></path>
                  <rect x="9" y="3" width="6" height="4" rx="1"></rect>
                </g>
                
                <polyline class="checkmark" points="9 12 11 14 15 10" stroke-width="2"></polyline>
              </svg>
              Backlog
            </button>
          </div>
        </div>
        
        <div class="pd-header-right">
          <button class="pd-action-btn" onclick="toggleSidebar()" title="Toggle sidebar" id="sidebarToggleBtn">
            ${isSidebarCollapsed ?
              `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="11 18 6 13 11 8"/>
                <polyline points="18 18 13 13 18 8"/>
              </svg>` :
              `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="3" y1="6" x2="21" y2="6"/>
                <line x1="3" y1="12" x2="21" y2="12"/>
                <line x1="3" y1="18" x2="21" y2="18"/>
              </svg>`
            }
          </button>

          <button class="pd-action-btn" onclick="copyProjectLink(${projectIndex})" title="Copy link">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            </svg>
          </button>
          ${!isProjectOwner(projectIndex) ? `
            <button class="pd-action-btn pd-action-warning" onclick="leaveProject(${projectIndex})" title="Leave project">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 21H5a2 2 0 01-2-2V5a2 2 0 012-2h4"/>
                <polyline points="16 17 21 12 16 7"/>
                <line x1="21" y1="12" x2="9" y2="12"/>
              </svg>
            </button>
          ` : ''}
          ${isProjectOwner(projectIndex) ? `
          <button class="pd-action-btn pd-action-danger" onclick="handleDeleteProjectFromDetail(${projectIndex})" title="Delete project">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2"/><path d="M9 9h.01M15 9h.01M9 15h6"/>
            </svg>
          </button>
          ` : ''}
        </div>
      </header>
      
      <!-- Main Layout Grid -->
      <div class="pd-layout ${isSidebarCollapsed ? 'sidebar-collapsed' : ''}">
        <!-- Main Content -->
        <main class="pd-main">
          <div class="pd-content-scroll">
            <!-- Project Title Section -->
            <div class="pd-title-section">
              <div class="pd-project-icon">
                <span>◇</span>
              </div>
              <div class="pd-title-content">
                <h1 class="pd-title" contenteditable="true" onblur="handleUpdateProjectName(${projectIndex}, this.textContent)">${project.name}</h1>
                <p class="pd-summary" contenteditable="true" onblur="handleUpdateProjectSummary(${projectIndex}, this.textContent)">${project.summary || 'Add a short summary...'}</p>
              </div>
            </div>
            
            <!-- Properties Bar -->
            <div class="pd-properties-bar">
              <span class="pd-props-label">Properties</span>
              
              <button class="pd-prop-chip status" onclick="toggleStatusDropdown(${projectIndex}, event)">
                <span class="pd-chip-dot" style="background: ${statusColor};"></span>
                <span>${capitalizeStatus(dynamicStatus)}</span>
              </button>
              
              <button class="pd-prop-chip priority" onclick="togglePriorityDropdown(${projectIndex}, event)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/>
                </svg>
                <span>${projectPriority ? projectPriority.charAt(0).toUpperCase() + projectPriority.slice(1) : 'Medium'}</span>
                <!-- Priority Dropdown -->
                <div class="pd-dropdown priority-dropdown" id="priorityDropdown-${projectIndex}" onclick="event.stopPropagation();">
                  <div class="pd-dropdown-header">Change priority...</div>
                  <div class="pd-dropdown-item" onclick="setProjectPriority(${projectIndex}, null); closePriorityDropdown();">
                    <span class="pd-priority-icon none">—</span> No priority <span class="pd-key">0</span>
                  </div>
                  <div class="pd-dropdown-item" onclick="setProjectPriority(${projectIndex}, 'urgent'); closePriorityDropdown();">
                    <span class="pd-priority-icon urgent">!</span> Urgent <span class="pd-key">1</span>
                  </div>
                  <div class="pd-dropdown-item" onclick="setProjectPriority(${projectIndex}, 'high'); closePriorityDropdown();">
                    <span class="pd-priority-icon high">▲</span> High <span class="pd-key">2</span>
                  </div>
                  <div class="pd-dropdown-item" onclick="setProjectPriority(${projectIndex}, 'medium'); closePriorityDropdown();">
                    <span class="pd-priority-icon medium">■</span> Medium <span class="pd-key">3</span>
                  </div>
                  <div class="pd-dropdown-item" onclick="setProjectPriority(${projectIndex}, 'low'); closePriorityDropdown();">
                    <span class="pd-priority-icon low">▼</span> Low <span class="pd-key">4</span>
                  </div>
                </div>
              </button>
              
              <button class="pd-prop-chip member">
                <div class="pd-chip-avatar">${getCurrentUserInitials()}</div>
                <span>${getCurrentUserName()}</span>
              </button>
              
              <button class="pd-prop-chip date" onclick="openEditStartDateModal(${projectIndex})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="4" width="18" height="18" rx="2"/><path d="M16 2v4M8 2v4M3 10h18"/>
                </svg>
                <span>${startDateFormatted}</span>
              </button>
              
              <span class="pd-date-arrow">→</span>
              
              <button class="pd-prop-chip date target" onclick="openEditTargetDateModal(${projectIndex})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="4" width="18" height="18" rx="2"/><path d="M16 2v4M8 2v4M3 10h18"/>
                </svg>
                <span>${targetDateFormatted}</span>
              </button>
              
              <button class="pd-prop-chip team">
                <span class="pd-team-icon">✦</span>
                <span>${project.team || 'Default'}</span>
              </button>
              
              <button class="pd-more-props" onclick="showMorePropertiesMenu(${projectIndex}, event)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/>
                </svg>
              </button>
            </div>
            
            <!-- Resources Section -->
            <div class="pd-resources">
              <span class="pd-resources-label">Resources</span>
              <button class="pd-add-resource" onclick="openAddResourceModal(this, ${projectIndex})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M12 5v14M5 12h14"/>
                </svg>
                Add document or link...
              </button>
              ${(project.resources || []).map((res, idx) => `
                <div class="pd-resource-item">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                  </svg>
                  ${res.type === 'existing' && res.docId ?
      `<a href="#" onclick="openDocEditor('${res.docId}'); return false;" class="pd-resource-link">${res.name}</a>` :
      res.link ?
        `<a href="${res.link}" target="_blank" class="pd-resource-link">${res.name}</a>` :
        `<span>${res.name}</span>`
    }
                  <button class="pd-resource-remove" onclick="removeProjectResource(${projectIndex}, ${idx})">×</button>
                </div>
              `).join('')}
            </div>
            
            
            <!-- Description Section -->
            <div class="pd-section">
              <h3 class="pd-section-title">Description</h3>
              <div class="pd-description-editor" contenteditable="true" onblur="handleUpdateProjectDescription(${projectIndex}, this.textContent)" data-placeholder="Add description...">${project.description || ''}</div>
            </div>
            
            <!-- Tasks Kanban Section -->

          </div>
        </main>
        
        <!-- Sidebar -->
        <aside class="pd-sidebar ${isSidebarCollapsed ? 'collapsed' : ''}" id="pdSidebar">
          
          <!-- Properties Section -->
          <div class="pd-sidebar-section">
            <div class="pd-sidebar-header">
              <span>Properties</span>
              <button class="pd-sidebar-expand">▼</button>
              <button class="pd-sidebar-add" onclick="addCustomProperty(${projectIndex})">+</button>
            </div>
            <div class="pd-props-list">
              <div class="pd-prop-row">
                <span class="pd-prop-label">Status</span>
                <span class="pd-prop-value status-value">
                  <span class="pd-status-dot" style="background: ${statusColor};"></span>
                  ${capitalizeStatus(dynamicStatus)}
                </span>
              </div>
              <div class="pd-prop-row">
                <span class="pd-prop-label">Priority</span>
                <button class="pd-prop-value clickable" onclick="openSidebarPriorityDropdown(${projectIndex}, event)">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/>
                  </svg>
                  ${projectPriority ? projectPriority.charAt(0).toUpperCase() + projectPriority.slice(1) : 'Medium'}
                </button>
              </div>
              <div class="pd-prop-row">
                <span class="pd-prop-label">Lead</span>
                <button class="pd-prop-value clickable" onclick="openAssignLeadModal(${projectIndex})">
                  <div class="pd-mini-avatar">${getProjectLeaderInitials(project)}</div>
                  ${getProjectLeaderDisplayName(project)}
                </button>
              </div>
              <div class="pd-prop-row">
                <span class="pd-prop-label">Members</span>
                <div class="pd-members-list" id="pdMembersList-${projectIndex}">
                  ${teamMembers.map((member, idx) => {
      const initials = getMemberAvatarInitialsWithFullNames(member);
      const backgroundColor = getNameColor(member);
      return `
                    <div class="pd-member-item" data-member="${member}" data-member-id="${idx}" data-project-index="${projectIndex}">
                      <div class="pd-member-avatar" id="memberAvatar-${projectIndex}-${idx}" style="background: ${backgroundColor}" oncontextmenu="showMemberContextMenu(event, '${member}', ${projectIndex}, ${idx})" title="${member === 'You' ? getCurrentUserName() : member}">
                        ${initials}
                      </div>
                      <span class="pd-member-name">${getMemberDisplayName(member)}</span>
                      <span class="pd-member-status" id="memberStatus-${projectIndex}-${idx}">
                        <span class="status-dot offline"></span>
                      </span>
                    </div>
                  `;
    }).join('')}
                  <button class="pd-prop-value clickable muted" onclick="openInviteMemberModal(${projectIndex})">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M16 21v-2a4 4 0 00-4-4H6a4 4 0 00-4 4v2"/>
                      <circle cx="9" cy="7" r="4"/>
                      <path d="M22 21v-2a4 4 0 00-3-3.87M16 3.13a4 4 0 010 7.75"/>
                    </svg>
                    Add members
                  </button>
                </div>
              </div>
              <div class="pd-prop-row">
                <span class="pd-prop-label">Start date</span>
                <span class="pd-prop-value">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="4" width="18" height="18" rx="2"/><path d="M16 2v4M8 2v4M3 10h18"/>
                  </svg>
                  ${startDateFormatted}
                </span>
              </div>
              <div class="pd-prop-row">
                <span class="pd-prop-label">Target date</span>
                <button class="pd-prop-value clickable" onclick="openEditTargetDateModal(${projectIndex})">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="4" width="18" height="18" rx="2"/><path d="M16 2v4M8 2v4M3 10h18"/>
                  </svg>
                  ${targetDateFormatted}
                </button>
              </div>
              <div class="pd-prop-row">
                <span class="pd-prop-label">Teams</span>
                <span class="pd-prop-value">
                  <span class="pd-team-badge">✦ ${project.team || 'Default'}</span>
                </span>
              </div>
              <div class="pd-prop-row">
                <span class="pd-prop-label">Labels</span>
                <button class="pd-prop-value clickable muted" onclick="openLabelsModal(${projectIndex})">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83 0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/>
                    <line x1="7" y1="7" x2="7.01" y2="7"/>
                  </svg>
                  Add label
                </button>
              </div>
            </div>
          </div>
          
          <!-- Activity Section -->
          <div class="pd-sidebar-section pd-activity-section">
            <div class="pd-sidebar-header">
              <span>Activity</span>
              <button class="pd-sidebar-expand">▼</button>
              <button class="pd-see-all" onclick="openActivityModal(${projectIndex})">See all</button>
            </div>
            <div class="pd-activity-feed">
              ${activityLog.slice(0, 5).map(act => `
                <div class="pd-activity-item">
                  <div class="pd-activity-icon ${act.type}">
                    ${getActivityIcon(act.type)}
                  </div>
                  <div class="pd-activity-content">
                    <p class="pd-activity-text"><strong>${act.actor}</strong> ${act.action}</p>
                    <span class="pd-activity-time">${act.time}</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        </aside>
      </div>
    </div>
  `;
}

// Helper functions for Advanced Project Detail View
function formatDateAdvanced(dateStr) {
  if (!dateStr) return 'Not set';
  const date = new Date(dateStr);
  const options = { month: 'short', day: 'numeric' };
  const year = date.getFullYear();
  const currentYear = new Date().getFullYear();
  if (year !== currentYear) {
    return date.toLocaleDateString('en-US', { ...options, year: '2-digit' }).replace(',', '');
  }
  return date.toLocaleDateString('en-US', options);
}

function generateActivityLog(project, projectIndex) {
  const activities = [];
  const updates = project.updates || [];
  const comments = project.comments || [];

  // Add status changes
  if (project.status) {
    activities.push({
      type: 'status',
      actor: project.teamMembers?.[0] || 'You',
      action: `changed status from In Progress to ${capitalizeStatus(project.status)}`,
      time: 'Jan 12'
    });
  }

  // Add target date changes
  if (project.targetDate) {
    activities.push({
      type: 'date',
      actor: project.teamMembers?.[0] || 'You',
      action: `changed target date to ${formatDateAdvanced(project.targetDate)}`,
      time: 'Jan 12'
    });
  }

  // Add priority changes
  if (project.priority) {
    activities.push({
      type: 'priority',
      actor: project.teamMembers?.[0] || 'You',
      action: `changed priority from High to ${project.priority.charAt(0).toUpperCase() + project.priority.slice(1)}`,
      time: 'Dec 30'
    });
  }

  // Add milestone additions
  if (project.milestones && project.milestones.length > 0) {
    project.milestones.forEach(m => {
      activities.push({
        type: 'milestone',
        actor: project.teamMembers?.[0] || 'You',
        action: `added milestone ${m.name}`,
        time: 'Dec 29'
      });
    });
  }

  // Default activities if none
  if (activities.length === 0) {
    activities.push({
      type: 'create',
      actor: project.teamMembers?.[0] || 'You',
      action: 'created this project',
      time: formatTimeAgo(project.createdAt || new Date().toISOString())
    });
  }

  return activities;
}

function getActivityIcon(type) {
  const icons = {
    status: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>',
    date: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><path d="M16 2v4M8 2v4M3 10h18"/></svg>',
    priority: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/></svg>',
    milestone: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>',
    create: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>'
  };
  return icons[type] || icons.create;
}

// Restore sidebar state on load
function restorePdSidebarState() {
  const sidebar = document.getElementById('pdSidebar');
  const layout = document.querySelector('.pd-layout');
  const toggleBtn = document.getElementById('sidebarToggleBtn');
  
  if (!sidebar || !layout) return;

  const isCollapsed = localStorage.getItem('pdSidebarCollapsed') === 'true';
  if (isCollapsed) {
    sidebar.classList.add('collapsed');
    layout.classList.add('sidebar-collapsed');
    if (toggleBtn) {
      toggleBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="11 18 6 13 11 8"/>
          <polyline points="18 18 13 13 18 8"/>
        </svg>
      `;
    }
  } else {
    sidebar.classList.remove('collapsed');
    layout.classList.remove('sidebar-collapsed');
    if (toggleBtn) {
      toggleBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="3" y1="6" x2="21" y2="6"/>
          <line x1="3" y1="12" x2="21" y2="12"/>
          <line x1="3" y1="18" x2="21" y2="18"/>
        </svg>
      `;
    }
  }
}
// Timeline State is defined in Enhanced Timeline section below

// ============================================
// TAB SWITCHING - PROJECT DETAIL TABS
// ============================================

function switchProjectTab(tabName, projectIndex) {
  // Update active tab styling
  const tabs = document.querySelectorAll('.pd-tab');
  tabs.forEach(tab => {
    if (tab.dataset.tab === tabName) {
      tab.classList.add('active');
    } else {
      tab.classList.remove('active');
    }
  });

  // Update the global current project tab variable
  if (typeof currentProjectTab !== 'undefined') {
    currentProjectTab = tabName;
  }

  // Get the content container
  const contentScroll = document.querySelector('.pd-content-scroll');
  if (!contentScroll) return;

  // Render the appropriate content based on tab
  switch (tabName) {
    case 'timeline':
      contentScroll.classList.add('timeline-full-width');
      // Use new Timeline V2 if available, fallback to old
      if (typeof renderTimelineV2 === 'function') {
        renderTimelineV2(projectIndex, contentScroll);
      } else if (typeof renderTimelineView === 'function') {
        renderTimelineView(projectIndex, contentScroll);
      }
      break;
    case 'backlog':
      contentScroll.classList.remove('timeline-full-width');
      renderBacklogTab(projectIndex, contentScroll);
      break;
    case 'overview':
    default:
      contentScroll.classList.remove('timeline-full-width');
      renderOverviewTab(projectIndex, contentScroll);
      break;
  }
  
  // Ensure sidebar state is preserved after tab switch
  restorePdSidebarState();
}


function renderOverviewTab(projectIndex, container) {
  // Re-render only the project detail content without calling openProjectDetail to avoid recursion
  const projects = loadProjects();
  const project = projects[projectIndex];

  if (!project) return;

  const { total, completed, percentage } = calculateProgress(project.columns);

  // Dynamic status based on progress
  let dynamicStatus = 'backlog';
  if (percentage === 0) {
    dynamicStatus = 'backlog';
  } else if (percentage > 0 && percentage < 100) {
    dynamicStatus = 'in-progress';
  } else if (percentage === 100) {
    dynamicStatus = 'done';
  }

  const statusColor = getStatusColor(dynamicStatus);
  const teamMembers = project.teamMembers || ['You'];
  const projectPriority = project.priority;
  const projectComments = project.comments || [];
  const milestones = project.milestones || [];

  // Generate activity log
  const activityLog = generateActivityLog(project, projectIndex);

  // Format dates
  const startDateFormatted = formatDateAdvanced(project.startDate || new Date().toISOString());
  const targetDateFormatted = formatDateAdvanced(project.targetDate);

  // Render the overview content directly into the container
  container.innerHTML = `
    <!-- Project Title Section -->
    <div class="pd-title-section">
      <div class="pd-project-icon">
        <span>◇</span>
      </div>
      <div class="pd-title-content">
        <h1 class="pd-title" contenteditable="true" onblur="handleUpdateProjectName(${projectIndex}, this.textContent)">${project.name}</h1>
        <p class="pd-summary" contenteditable="true" onblur="handleUpdateProjectSummary(${projectIndex}, this.textContent)">${project.summary || 'Add a short summary...'}</p>
      </div>
    </div>
    
    <!-- Properties Bar -->
    <div class="pd-properties-bar">
      <span class="pd-props-label">Properties</span>
      
      <button class="pd-prop-chip status" onclick="toggleStatusDropdown(${projectIndex}, event)">
        <span class="pd-chip-dot" style="background: ${statusColor};"></span>
        <span>${dynamicStatus.charAt(0).toUpperCase() + dynamicStatus.slice(1)}</span>
      </button>
      
      <button class="pd-prop-chip priority" onclick="togglePriorityDropdown(${projectIndex}, event)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"/>
        </svg>
        <span>${projectPriority ? projectPriority.charAt(0).toUpperCase() + projectPriority.slice(1) : 'Medium'}</span>
      </button>
      
      <button class="pd-prop-chip member">
        <div class="pd-chip-avatar">${teamMembers[0]?.charAt(0) || 'Y'}</div>
        <span>${teamMembers[0] || 'You'}</span>
      </button>
      
      <button class="pd-prop-chip date" onclick="openEditStartDateModal(${projectIndex})">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="4" width="18" height="18" rx="2"/><path d="M16 2v4M8 2v4M3 10h18"/>
        </svg>
        <span>${startDateFormatted}</span>
      </button>
      
      <span class="pd-date-arrow">→</span>
      
      <button class="pd-prop-chip date target" onclick="openEditTargetDateModal(${projectIndex})">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="4" width="18" height="18" rx="2"/><path d="M16 2v4M8 2v4M3 10h18"/>
        </svg>
        <span>${targetDateFormatted}</span>
      </button>
      
      <button class="pd-prop-chip team">
        <span class="pd-team-icon">✦</span>
        <span>${project.team || 'Default'}</span>
      </button>
      
      <button class="pd-more-props" onclick="showMorePropertiesMenu(${projectIndex}, event)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/>
        </svg>
      </button>
    </div>
    
    <!-- Resources Section -->
    <div class="pd-resources">
      <span class="pd-resources-label">Resources</span>
      <button class="pd-add-resource" onclick="openAddResourceModal(this, ${projectIndex})">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 5v14M5 12h14"/>
        </svg>
        Add document or link...
      </button>
      ${(project.resources || []).map((res, idx) => `
        <div class="pd-resource-item">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14 2 14 8 20 8"/>
          </svg>
          ${res.type === 'existing' && res.docId ?
      `<a href="#" onclick="openDocEditor('${res.docId}'); return false;" class="pd-resource-link">${res.name}</a>` :
      res.link ?
        `<a href="${res.link}" target="_blank" class="pd-resource-link">${res.name}</a>` :
        `<span>${res.name}</span>`
    }
          <button class="pd-resource-remove" onclick="removeProjectResource(${projectIndex}, ${idx})">×</button>
        </div>
      `).join('')}
    </div>
    
    
    <!-- Description Section -->
    <div class="pd-section">
      <h3 class="pd-section-title">Description</h3>
      <div class="pd-description-editor" contenteditable="true" onblur="handleUpdateProjectDescription(${projectIndex}, this.textContent)" data-placeholder="Add description...">${project.description || ''}</div>
    </div>
    
    <!-- Tasks Kanban Section -->

  `;
}

const RESOURCE_CAPACITY = 8;

// ============================================
// TIMELINE VIEW - LINEAR STYLE REBUILD (ENHANCED)
// ============================================

// Enhanced Timeline State
if (typeof timelineState === 'undefined') {
  var timelineState = {
    viewMode: 'week',
    currentDate: new Date(),
    showResources: false,
    showDone: false,
    isDragging: false,
    isResizing: false,
    zoom: 0.5, // 0.15 to 2 (0.15 = ~6 months view, 0.5 = 50% zoomed out)
    panX: 0,
    showCriticalPath: false,
    selectedTaskIds: [],
    keyboardEnabled: true,
    lastProjectIndex: null,
    scrollLeft: 0,  // Save scroll position
    scrollTop: 0    // Save scroll position
  };
}

function renderBacklogTab(projectIndex, container) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  
  if (!project) return;

  // Get all tasks from all columns that could be considered backlog items
  const allTasks = [];
  const backlogColumns = ['Backlog', 'Todo', 'To Do', 'Backlog Tasks'];
  
  (project.columns || []).forEach((column, colIndex) => {
    if (backlogColumns.includes(column.title)) {
      (column.tasks || []).forEach((task, taskIndex) => {
        allTasks.push({
          ...task,
          columnIndex: colIndex,
          taskIndex: taskIndex,
          columnTitle: column.title
        });
      });
    }
  });

  // Also include tasks without specific status that might be considered backlog
  (project.columns || []).forEach((column, colIndex) => {
    if (!backlogColumns.includes(column.title)) {
      (column.tasks || []).forEach((task, taskIndex) => {
        if (!task.status || task.status === 'todo' || task.status === 'backlog') {
          allTasks.push({
            ...task,
            columnIndex: colIndex,
            taskIndex: taskIndex,
            columnTitle: column.title
          });
        }
      });
    }
  });

  // Sort tasks by priority and creation date
  allTasks.sort((a, b) => {
    const priorityOrder = { high: 3, medium: 2, low: 1 };
    const aPriority = priorityOrder[a.priority] || 2;
    const bPriority = priorityOrder[b.priority] || 2;
    
    if (aPriority !== bPriority) {
      return bPriority - aPriority; // Higher priority first
    }
    
    // Then by creation date (newest first)
    const aDate = new Date(a.createdAt || 0);
    const bDate = new Date(b.createdAt || 0);
    return bDate - aDate;
  });

  const stats = {
    total: allTasks.length,
    high: allTasks.filter(t => t.priority === 'high').length,
    medium: allTasks.filter(t => t.priority === 'medium').length,
    low: allTasks.filter(t => t.priority === 'low').length,
    completed: allTasks.filter(t => t.done).length
  };

  container.innerHTML = `
    <div class="backlog-container backlog-modern">
      ${allTasks.length === 0 ? `
        <!-- Empty State -->
        <div class="backlog-empty-state">
          <div class="empty-illustration">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="120" height="120">
              <path d="M9 5H7a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-2"></path>
              <rect x="9" y="3" width="6" height="4" rx="1"></rect>
            </svg>
          </div>
          <h2 class="empty-title">No backlog tasks</h2>
          <p class="empty-description">Tasks that need to be planned will appear here. Start by adding your first task to get organized.</p>
          <button class="btn-primary" onclick="openAddProjectBacklogTaskModal(${projectIndex})">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
              <path d="M12 5v14M5 12h14"/>
            </svg>
            Add First Task
          </button>
        </div>
      ` : `
        <!-- Backlog Header -->
        <div class="backlog-header">
          <div class="backlog-title-section">
            <h2>Backlog</h2>
            <div class="backlog-stats-row">
              <div class="stat-chip ${stats.total > 0 ? 'active' : ''}">${stats.total} total</div>
              <div class="stat-chip ${stats.high > 0 ? '' : ''}">${stats.high} high</div>
              <div class="stat-chip ${stats.medium > 0 ? '' : ''}">${stats.medium} medium</div>
              <div class="stat-chip ${stats.low > 0 ? '' : ''}">${stats.low} low</div>
              ${stats.completed > 0 ? `<div class="stat-chip done">${stats.completed} done</div>` : ''}
            </div>
          </div>
          <div class="backlog-progress-ring">
            <svg class="progress-ring-svg" width="80" height="80">
              <circle cx="40" cy="40" r="36" fill="none" stroke="var(--glass-border)" stroke-width="8"/>
              <circle cx="40" cy="40" r="36" fill="none" stroke="var(--primary)" stroke-width="8"
                      stroke-dasharray="${2 * Math.PI * 36}"
                      stroke-dashoffset="${2 * Math.PI * 36 * (1 - (stats.completed / stats.total))}"
                      stroke-linecap="round"/>
            </svg>
            <div class="progress-value">${Math.round((stats.completed / stats.total) * 100) || 0}%</div>
          </div>
        </div>

        <!-- Backlog Toolbar -->
        <div class="backlog-toolbar">
          <div class="backlog-filters">
            <button class="filter-chip active" onclick="filterProjectBacklogTasks(${projectIndex}, 'all', 'priority')">All</button>
            <button class="filter-chip" onclick="filterProjectBacklogTasks(${projectIndex}, 'high', 'priority')">High</button>
            <button class="filter-chip" onclick="filterProjectBacklogTasks(${projectIndex}, 'medium', 'priority')">Medium</button>
            <button class="filter-chip" onclick="filterProjectBacklogTasks(${projectIndex}, 'low', 'priority')">Low</button>
          </div>
          <select class="sort-select" onchange="sortProjectBacklogTasks(${projectIndex}, this.value)">
            <option value="priority">Sort by Priority</option>
            <option value="date">Sort by Date</option>
            <option value="name">Sort by Name</option>
          </select>
        </div>

        <!-- Backlog Tasks Grid -->
        <div class="backlog-tasks-grid" id="backlogTasksList">
          ${allTasks.map(task => `
            <div class="backlog-task-card ${task.done ? 'done' : ''}" data-task-id="${task.columnIndex}-${task.taskIndex}">
              <div class="task-card-main">
                <button class="task-checkbox" onclick="toggleProjectBacklogTaskStatus(${projectIndex}, ${task.columnIndex}, ${task.taskIndex}, !${task.done})">
                  ${task.done ? 
                    `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>` :
                    `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <rect x="3" y="3" width="18" height="18" rx="4"/>
                    </svg>`
                  }
                </button>
                <div class="task-content" onclick="editProjectBacklogTask(${projectIndex}, ${task.columnIndex}, ${task.taskIndex})">
                  <div class="task-title">${task.title || 'Untitled Task'}</div>
                  <div class="task-date">${task.columnTitle} ${task.dueDate ? `• Due ${new Date(task.dueDate).toLocaleDateString()}` : ''}</div>
                </div>
              </div>
              <div class="task-actions">
                <button class="task-action-btn" onclick="editProjectBacklogTask(${projectIndex}, ${task.columnIndex}, ${task.taskIndex})" title="Edit">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                  </svg>
                </button>
                <button class="task-action-btn" onclick="moveProjectBacklogTaskToColumn(${projectIndex}, ${task.columnIndex}, ${task.taskIndex})" title="Move">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 12h14M12 5l7 7-7 7"/>
                  </svg>
                </button>
                <button class="task-action-btn delete" onclick="deleteProjectBacklogTask(${projectIndex}, ${task.columnIndex}, ${task.taskIndex})" title="Delete">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="3 6 5 6 21 6"/>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                  </svg>
                </button>
              </div>
            </div>
          `).join('')}
        </div>

        <!-- Add Task Section -->
        <div class="backlog-add-section">
          <div class="backlog-quick-add-wrapper">
            <input type="text" class="backlog-quick-input" placeholder="Add a new task..." 
                   onkeypress="if(event.key === 'Enter') { const value = this.value.trim(); if(value) { quickAddProjectBacklogTask(${projectIndex}, value); this.value = ''; } }">
            <button class="quick-add-btn" onclick="const input = this.previousElementSibling; const value = input.value.trim(); if(value) { quickAddProjectBacklogTask(${projectIndex}, value); input.value = ''; }">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14M5 12h14"/>
              </svg>
            </button>
          </div>
        </div>

        ${stats.completed > 0 ? `
          <!-- Clear Completed Section -->
          <div class="backlog-clear-section">
            <button class="clear-completed-btn" onclick="clearCompletedProjectBacklogTasks(${projectIndex})">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/>
              </svg>
              Clear ${stats.completed} completed
            </button>
          </div>
        ` : ''}
      `}
    </div>
  `;
  
  // Restore sidebar state
  restorePdSidebarState();
}

// Helper functions for backlog tab
function toggleProjectBacklogTaskStatus(projectIndex, columnIndex, taskIndex, isDone) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project || !project.columns[columnIndex]) return;
  
  const task = project.columns[columnIndex].tasks[taskIndex];
  if (task) {
    task.done = isDone;
    saveProjects(projects);
    renderBacklogTab(projectIndex, document.querySelector('.pd-content-scroll'));
  }
}

function editProjectBacklogTask(projectIndex, columnIndex, taskIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project || !project.columns[columnIndex]) return;
  
  const task = project.columns[columnIndex].tasks[taskIndex];
  if (!task) return;
  
  const content = `
    <form onsubmit="saveProjectBacklogTaskEdit(event, ${projectIndex}, ${columnIndex}, ${taskIndex})">
      <div class="form-group">
        <label>Task Title</label>
        <input type="text" name="title" value="${task.title || ''}" required>
      </div>
      <div class="form-group">
        <label>Description</label>
        <textarea name="description" rows="3">${task.description || ''}</textarea>
      </div>
      <div class="form-group">
        <label>Priority</label>
        <select name="priority">
          <option value="low" ${task.priority === 'low' ? 'selected' : ''}>Low</option>
          <option value="medium" ${task.priority === 'medium' ? 'selected' : ''}>Medium</option>
          <option value="high" ${task.priority === 'high' ? 'selected' : ''}>High</option>
        </select>
      </div>
      <div class="form-group">
        <label>Due Date</label>
        <input type="date" name="dueDate" value="${task.dueDate || ''}">
      </div>
      <div class="form-actions">
        <button type="button" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn-primary">Save Changes</button>
      </div>
    </form>
  `;
  
  openModal('Edit Backlog Task', content);
}

function saveProjectBacklogTaskEdit(event, projectIndex, columnIndex, taskIndex) {
  event.preventDefault();
  const formData = new FormData(event.target);
  
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project || !project.columns[columnIndex]) return;
  
  const task = project.columns[columnIndex].tasks[taskIndex];
  if (task) {
    task.title = formData.get('title');
    task.description = formData.get('description');
    task.priority = formData.get('priority');
    task.dueDate = formData.get('dueDate');
    task.updatedAt = new Date().toISOString();
    
    saveProjects(projects);
    closeModal();
    renderBacklogTab(projectIndex, document.querySelector('.pd-content-scroll'));
  }
}

function moveProjectBacklogTaskToColumn(projectIndex, columnIndex, taskIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project || !project.columns[columnIndex]) return;
  
  const task = project.columns[columnIndex].tasks[taskIndex];
  if (!task) return;
  
  const columns = project.columns.map((col, idx) => 
    `<option value="${idx}">${col.title}</option>`
  ).join('');
  
  const content = `
    <form onsubmit="confirmMoveProjectBacklogTask(event, ${projectIndex}, ${columnIndex}, ${taskIndex})">
      <div class="form-group">
        <label>Move to Column</label>
        <select name="targetColumn" required>
          ${columns}
        </select>
      </div>
      <div class="form-actions">
        <button type="button" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn-primary">Move Task</button>
      </div>
    </form>
  `;
  
  openModal('Move Task to Column', content);
}

function confirmMoveProjectBacklogTask(event, projectIndex, columnIndex, taskIndex) {
  event.preventDefault();
  const formData = new FormData(event.target);
  const targetColumnIndex = parseInt(formData.get('targetColumn'));
  
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;
  
  // Remove task from current column
  const task = project.columns[columnIndex].tasks.splice(taskIndex, 1)[0];
  
  // Add to target column
  if (project.columns[targetColumnIndex]) {
    project.columns[targetColumnIndex].tasks.push(task);
  }
  
  saveProjects(projects);
  closeModal();
  renderBacklogTab(projectIndex, document.querySelector('.pd-content-scroll'));
}

function deleteProjectBacklogTask(projectIndex, columnIndex, taskIndex) {
  const content = `
    <div style="padding: 32px; text-align: center;">
      <h3 style="margin: 0 0 16px; font-size: 20px; font-weight: 600; color: var(--foreground);">Delete Task?</h3>
      <p style="margin: 0 0 24px; color: var(--muted-foreground);">This action cannot be undone.</p>
      <div style="display: flex; gap: 12px; justify-content: center;">
        <button type="button" onclick="closeModal()" style="padding: 8px 16px; border: 1px solid var(--border); background: var(--surface); border-radius: 6px;">Cancel</button>
        <button type="button" onclick="confirmDeleteProjectBacklogTask(${projectIndex}, ${columnIndex}, ${taskIndex})" style="padding: 8px 16px; background: var(--destructive); color: white; border: none; border-radius: 6px;">Delete</button>
      </div>
    </div>
  `;
  
  openModal('Confirm Delete', content);
}

function confirmDeleteProjectBacklogTask(projectIndex, columnIndex, taskIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project || !project.columns[columnIndex]) return;
  
  project.columns[columnIndex].tasks.splice(taskIndex, 1);
  saveProjects(projects);
  closeModal();
  renderBacklogTab(projectIndex, document.querySelector('.pd-content-scroll'));
}

function openAddProjectBacklogTaskModal(projectIndex) {
  const content = `
    <form onsubmit="handleAddProjectBacklogTaskForm(event, ${projectIndex})">
      <div class="form-group">
        <label>Task Title</label>
        <input type="text" name="title" placeholder="Enter task title..." required>
      </div>
      <div class="form-group">
        <label>Description</label>
        <textarea name="description" rows="3" placeholder="Enter task description..."></textarea>
      </div>
      <div class="form-group">
        <label>Priority</label>
        <select name="priority">
          <option value="low">Low</option>
          <option value="medium" selected>Medium</option>
          <option value="high">High</option>
        </select>
      </div>
      <div class="form-group">
        <label>Due Date</label>
        <input type="date" name="dueDate">
      </div>
      <div class="form-actions">
        <button type="button" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn-primary">Add Task</button>
      </div>
    </form>
  `;
  
  openModal('Add Backlog Task', content);
}

function handleAddProjectBacklogTaskForm(event, projectIndex) {
  event.preventDefault();
  const formData = new FormData(event.target);
  
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;
  
  // Find or create a backlog column
  let backlogColumn = project.columns.find(col => 
    ['Backlog', 'Todo', 'To Do', 'Backlog Tasks'].includes(col.title)
  );
  
  if (!backlogColumn) {
    // Create a new backlog column
    backlogColumn = {
      title: 'Backlog',
      tasks: [],
      color: '#6b7280'
    };
    project.columns.push(backlogColumn);
  }
  
  const newTask = {
    id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    title: formData.get('title'),
    description: formData.get('description'),
    priority: formData.get('priority'),
    dueDate: formData.get('dueDate'),
    done: false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
  
  backlogColumn.tasks.push(newTask);
  saveProjects(projects);
  closeModal();
  renderBacklogTab(projectIndex, document.querySelector('.pd-content-scroll'));
}

function filterProjectBacklogTasks(projectIndex, value, type) {
  // This function would implement filtering logic
  // For now, just re-render the current tab
  if (projectIndex !== undefined && projectIndex !== null) {
    renderBacklogTab(projectIndex, document.querySelector('.pd-content-scroll'));
  }
}

function sortProjectBacklogTasks(projectIndex, value) {
  // This function would implement sorting logic
  // For now, just re-render the current tab
  if (projectIndex !== undefined && projectIndex !== null) {
    renderBacklogTab(projectIndex, document.querySelector('.pd-content-scroll'));
  }
}

function quickAddProjectBacklogTask(projectIndex, title) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;
  
  // Find or create a backlog column
  let backlogColumn = project.columns.find(col => 
    ['Backlog', 'Todo', 'To Do', 'Backlog Tasks'].includes(col.title)
  );
  
  if (!backlogColumn) {
    // Create a new backlog column
    backlogColumn = {
      title: 'Backlog',
      tasks: [],
      color: '#6b7280'
    };
    project.columns.push(backlogColumn);
  }
  
  const newTask = {
    id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    title: title,
    description: '',
    priority: 'medium',
    dueDate: '',
    done: false,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
  
  backlogColumn.tasks.push(newTask);
  saveProjects(projects);
  renderBacklogTab(projectIndex, document.querySelector('.pd-content-scroll'));
}

function clearCompletedProjectBacklogTasks(projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;
  
  let clearedCount = 0;
  
  // Remove completed tasks from backlog columns
  project.columns.forEach((column, colIndex) => {
    if (['Backlog', 'Todo', 'To Do', 'Backlog Tasks'].includes(column.title)) {
      const originalLength = column.tasks.length;
      column.tasks = column.tasks.filter(task => !task.done);
      clearedCount += originalLength - column.tasks.length;
    }
  });
  
  if (clearedCount > 0) {
    saveProjects(projects);
    renderBacklogTab(projectIndex, document.querySelector('.pd-content-scroll'));
  }
}

function getCurrentProjectIndex() {
  // This would need to be implemented based on how the current project is tracked
  // For now, return null as a placeholder
  return null;
}

// Timeline task colors palette
const TIMELINE_TASK_COLORS = [
  { name: 'Default', value: null },
  { name: 'Blue', value: '#3b82f6' },
  { name: 'Purple', value: '#8b5cf6' },
  { name: 'Pink', value: '#ec4899' },
  { name: 'Red', value: '#ef4444' },
  { name: 'Orange', value: '#f97316' },
  { name: 'Yellow', value: '#eab308' },
  { name: 'Green', value: '#22c55e' },
  { name: 'Teal', value: '#14b8a6' },
  { name: 'Cyan', value: '#06b6d4' }
];

// Critical path calculation removed - dependencies feature cleaned

// Timeline expansion state for columns
let timelineExpandedColumns = {};

function renderTimelineView(projectIndex, container) {
  // Preserve current gantt scroll before we replace DOM
  try {
    const prevWrapper = document.getElementById('tlGanttWrapper') || document.querySelector('.tl-gantt-wrapper');
    if (prevWrapper) {
      timelineState.scrollLeft = prevWrapper.scrollLeft || 0;
      timelineState.scrollTop = prevWrapper.scrollTop || 0;
    }
  } catch (e) {
    // no-op
  }

  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  // Track current project for keyboard shortcuts
  timelineState.lastProjectIndex = projectIndex;

  // Build column data with date ranges and tasks
  const columns = (project.columns || []).map((col, colIdx) => {
    const tasks = col.tasks || [];
    const tasksWithDates = tasks.filter(t => t.startDate || t.dueDate || t.endDate);
    const tasksWithoutDates = tasks.filter(t => !t.startDate && !t.dueDate && !t.endDate);

    let minDate = null;
    let maxDate = null;

    // First check if column has stored timeline dates
    if (col.timelineStart) {
      minDate = new Date(col.timelineStart);
    }
    if (col.timelineEnd) {
      maxDate = new Date(col.timelineEnd);
    }

    // Then check task dates and expand range if needed
    tasksWithDates.forEach(task => {
      const start = task.startDate ? new Date(task.startDate) : null;
      const end = task.endDate ? new Date(task.endDate) : (task.dueDate ? new Date(task.dueDate) : start);

      if (start && (!minDate || start < minDate)) minDate = new Date(start);
      if (end && (!maxDate || end > maxDate)) maxDate = new Date(end);
    });

    return {
      id: `col-${colIdx}`,
      title: col.title,
      columnIndex: colIdx,
      taskCount: tasks.length,
      completedCount: tasks.filter(t => t.done).length,
      tasksWithDates: tasksWithDates.length,
      tasksWithoutDates: tasksWithoutDates.length,
      minDate: minDate,
      maxDate: maxDate,
      color: getColumnColor(col.title),
      hasStoredDates: !!(col.timelineStart || col.timelineEnd),
      tasks: tasks.map((t, tIdx) => ({
        ...t,
        taskIndex: tIdx,
        columnIndex: colIdx,
        columnTitle: col.title
      })),
      isExpanded: timelineExpandedColumns[`col-${colIdx}`] || false
    };
  });

  // Get all tasks for date range calculation
  const allTasks = [];
  (project.columns || []).forEach((col, colIdx) => {
    (col.tasks || []).forEach((task, taskIdx) => {
      allTasks.push({
        ...task,
        columnIndex: colIdx,
        taskIndex: taskIdx,
        columnTitle: col.title,
        status: getColumnStatus(col.title)
      });
    });
  });

  // Calculate date range
  const { startDate, endDate, dates } = calculateTimelineDates(allTasks, timelineState.viewMode);

  // Stats
  const stats = {
    total: allTasks.length,
    completed: allTasks.filter(t => t.status === 'done' || t.done).length,
    inProgress: allTasks.filter(t => t.status === 'in-progress').length,
    overdue: allTasks.filter(t => {
      if (!t.dueDate) return false;
      const due = new Date(t.dueDate);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      return due < today && !t.done;
    }).length
  };

  const progressPercent = Math.round((stats.completed / Math.max(stats.total, 1)) * 100);

  // Calculate week ranges for ClickUp-style header
  const weekRanges = calculateWeekRanges(dates);
  const weekRangesHtml = weekRanges.map(range => `
    <div class="tl-week-range-block" style="width: ${range.days * 48 * timelineState.zoom}px;">
      <span class="tl-week-range-dates">${range.startStr} – ${range.endStr}</span>
      <span class="tl-week-range-week">W${range.weekNum}</span>
    </div>
  `).join('');

  container.innerHTML = `
    <div class="timeline-linear clickup-enhanced">
      <!-- ClickUp-Style Premium Header -->
      <div class="tl-header tl-header-clickup">
        <div class="tl-header-left">
          <div class="tl-title">
            <div class="tl-gantt-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="4" width="18" height="18" rx="2"/>
                <line x1="3" y1="10" x2="21" y2="10"/>
                <line x1="9" y1="4" x2="9" y2="22"/>
              </svg>
            </div>
            <span>Gantt</span>
          </div>
          
          <div class="tl-view-tabs tl-view-tabs-clickup">
            <button class="tl-view-tab ${timelineState.viewMode === 'day' ? 'active' : ''}" onclick="setTimelineViewMode('day', ${projectIndex})">Day</button>
            <button class="tl-view-tab ${timelineState.viewMode === 'week' ? 'active' : ''}" onclick="setTimelineViewMode('week', ${projectIndex})">Week</button>
            <button class="tl-view-tab ${timelineState.viewMode === 'month' ? 'active' : ''}" onclick="setTimelineViewMode('month', ${projectIndex})">Month</button>
            <button class="tl-view-tab ${timelineState.viewMode === 'quarter' ? 'active' : ''}" onclick="setTimelineViewMode('quarter', ${projectIndex})">Quarter</button>
          </div>
        </div>
        
        <div class="tl-header-right">
          <!-- ClickUp Toolbar -->
          <div class="tl-clickup-toolbar">
            <button class="tl-toolbar-btn" onclick="goToTimelineToday(${projectIndex})" title="Go to today">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
              Today
            </button>
            <button class="tl-toolbar-btn" onclick="autofitTimeline(${projectIndex})" title="Auto-fit to content">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>
              Autofit
            </button>
            <button class="tl-toolbar-btn" onclick="exportGanttChart(${projectIndex})" title="Export Gantt">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
              Export
            </button>
          </div>
          
          <div class="tl-toolbar-divider"></div>
          
          <!-- Sort & Filter -->
          <div class="tl-clickup-toolbar">
            <button class="tl-toolbar-btn tl-toolbar-btn-icon" onclick="openGanttSortMenu(event, ${projectIndex})" title="Sort">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 5h10M11 9h7M11 13h4"/><path d="M3 17l3 3 3-3"/><line x1="6" y1="18" x2="6" y2="7"/></svg>
              Sort
            </button>
            <button class="tl-toolbar-btn tl-toolbar-btn-icon ${timelineState.showFilters ? 'active' : ''}" onclick="toggleTimelineFilters(${projectIndex})" title="Filter">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>
              Filter
            </button>
            <button class="tl-toolbar-btn tl-toolbar-btn-icon ${timelineState.meMode ? 'active' : ''}" onclick="toggleMeMode(${projectIndex})" title="Show only my tasks">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
              Me mode
            </button>
            <button class="tl-toolbar-btn tl-toolbar-btn-icon" onclick="openAssigneeFilter(event, ${projectIndex})" title="Filter by assignee">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 00-3-3.87"/><path d="M16 3.13a4 4 0 010 7.75"/></svg>
              Assignee
            </button>
          </div>
          
          <div class="tl-toolbar-divider"></div>
          
          
          <div class="tl-zoom-controls tl-zoom-clickup">
            <button class="tl-zoom-btn" onclick="zoomTimelineSmart(-1, ${projectIndex})" title="Zoom out">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
            </button>
            <div class="tl-zoom-dropdown-wrapper">
              <button class="tl-zoom-level-btn" onclick="toggleZoomDropdown(event)" title="Select zoom level">
                <span class="tl-zoom-level">${getZoomLabel(timelineState.zoom)}</span>
                <svg class="tl-zoom-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
              </button>
              <div class="tl-zoom-dropdown" id="tlZoomDropdown">
                <button class="tl-zoom-preset ${timelineState.zoom === 0.15 ? 'active' : ''}" onclick="setTimelineZoom(0.15, ${projectIndex})">6 Months</button>
                <button class="tl-zoom-preset ${timelineState.zoom === 0.25 ? 'active' : ''}" onclick="setTimelineZoom(0.25, ${projectIndex})">3 Months</button>
                <button class="tl-zoom-preset ${timelineState.zoom === 0.5 ? 'active' : ''}" onclick="setTimelineZoom(0.5, ${projectIndex})">6 Weeks</button>
                <button class="tl-zoom-preset ${timelineState.zoom === 0.75 ? 'active' : ''}" onclick="setTimelineZoom(0.75, ${projectIndex})">1 Month</button>
                <button class="tl-zoom-preset ${timelineState.zoom === 1 ? 'active' : ''}" onclick="setTimelineZoom(1, ${projectIndex})">2 Weeks</button>
                <button class="tl-zoom-preset ${timelineState.zoom === 1.5 ? 'active' : ''}" onclick="setTimelineZoom(1.5, ${projectIndex})">1 Week</button>
                <button class="tl-zoom-preset ${timelineState.zoom === 2 ? 'active' : ''}" onclick="setTimelineZoom(2, ${projectIndex})">Days</button>
              </div>
            </div>
            <button class="tl-zoom-btn" onclick="zoomTimelineSmart(1, ${projectIndex})" title="Zoom in">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>
            </button>
          </div>
          
        </div>
      </div>
      
      <!-- ClickUp-Style Week Range Headers -->
      <div class="tl-week-ranges-header">
        ${weekRangesHtml}
      </div>
      
      <!-- Advanced Features Toolbar -->
      ${typeof renderAdvancedToolbar === 'function' ? renderAdvancedToolbar(projectIndex) : ''}
      
      
      <!-- Timeline Body -->
      <div class="tl-body tl-body-clickup">
        <!-- Left Panel - Task List -->
        <div class="tl-left-panel tl-left-panel-clickup">
          <div class="tl-left-header">
            <span class="tl-left-title">Tasks</span>
            <span class="tl-task-count-badge">${stats.total}</span>
          </div>
            <button class="tl-expand-all-btn" onclick="expandAllTimelineColumns(${projectIndex})" title="Expand/Collapse All">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
            </button>
          </div>
          
          <div class="tl-task-list" id="tlTaskList">
            ${renderTimelineColumnListV5(columns, projectIndex)}
          </div>
        </div>
        
        <!-- Right Panel - Gantt Chart -->
        <div class="tl-right-panel tl-right-panel-clickup">
          <!-- Date Headers -->
          <div class="tl-date-header tl-date-header-clickup">
            <div class="tl-date-header-scroll" id="tlDateHeaderScroll">
              ${renderTimelineDateHeadersV5(dates, timelineState.zoom)}
            </div>
          </div>
          
          <!-- Gantt Grid -->
          <div class="tl-gantt-wrapper" id="tlGanttWrapper" onscroll="syncTimelineScroll(this)">
            <div class="tl-gantt-grid" id="tlGanttGrid" style="width: ${dates.length * 48 * timelineState.zoom}px; position: relative;">
              ${renderTimelineGanttRowsV5(columns, dates, projectIndex, startDate)}
              ${renderTimelineTodayLineClickup(dates, startDate)}
            </div>
          </div>
        </div>
      </div>
      
      <!-- Bottom Stats Bar -->
      <div class="tl-bottom-stats">
        <div class="tl-stat-chip">
          <span class="tl-stat-chip-icon">📊</span>
          <span class="tl-stat-chip-value">${stats.total}</span>
          <span class="tl-stat-chip-label">Total</span>
        </div>
        <div class="tl-stat-chip tl-stat-chip-green">
          <span class="tl-stat-chip-icon">✓</span>
          <span class="tl-stat-chip-value">${stats.completed}</span>
          <span class="tl-stat-chip-label">Done</span>
        </div>
        <div class="tl-stat-chip tl-stat-chip-yellow">
          <span class="tl-stat-chip-icon">⏳</span>
          <span class="tl-stat-chip-value">${stats.inProgress}</span>
          <span class="tl-stat-chip-label">In Progress</span>
        </div>
        ${stats.overdue > 0 ? `
        <div class="tl-stat-chip tl-stat-chip-red">
          <span class="tl-stat-chip-icon">⚠</span>
          <span class="tl-stat-chip-value">${stats.overdue}</span>
          <span class="tl-stat-chip-label">Overdue</span>
        </div>
        ` : ''}
        <div style="flex: 1;"></div>
        <div class="tl-progress-chip">
          <div class="tl-progress-bar-mini">
            <div class="tl-progress-fill-mini" style="width: ${progressPercent}%;"></div>
          </div>
          <span class="tl-progress-text">${progressPercent}% complete</span>
        </div>
      </div>
      
      <!-- Mini-map Navigation Bar -->
      ${renderTimelineMinimap(columns, dates, startDate, projectIndex)}
    </div>
    
    <!-- Premium Kanban Board Section -->
    <div class="tl-kanban-section">
      <div class="tl-kanban-header">
        <div class="tl-kanban-title-group">
          <div class="tl-kanban-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="7" height="7" rx="1"/>
              <rect x="14" y="3" width="7" height="7" rx="1"/>
              <rect x="3" y="14" width="7" height="7" rx="1"/>
              <rect x="14" y="14" width="7" height="7" rx="1"/>
            </svg>
          </div>
          <h3 class="tl-kanban-title">Task Board</h3>
          <span class="tl-kanban-badge">${project.columns.reduce((acc, col) => acc + col.tasks.length, 0)} tasks</span>
        </div>
        <div class="tl-kanban-actions">
          <button class="tl-kanban-add-col-btn" onclick="handleAddColumn(${projectIndex})">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 5v14M5 12h14"/>
            </svg>
            Add Column
          </button>
        </div>
      </div>
      
      <div class="tl-kanban-board">
        ${project.columns.map((column, colIndex) => {
    const completedCount = column.tasks.filter(t => t.done).length;
    const totalCount = column.tasks.length;
    const progressPercent = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;
    const columnColor = getColumnColor(column.title);

    return `
          <div class="tl-kanban-column" data-col-index="${colIndex}">
            <div class="tl-kanban-col-header" style="--col-accent: ${columnColor};">
              <div class="tl-kanban-col-indicator" style="background: ${columnColor};"></div>
              <h4 class="tl-kanban-col-title" contenteditable="true" onblur="handleRenameColumn(${projectIndex}, ${colIndex}, this.textContent)">${column.title}</h4>
              <div class="tl-kanban-col-meta">
                <span class="tl-kanban-col-count">${completedCount}/${totalCount}</span>
                <div class="tl-kanban-col-progress">
                  <div class="tl-kanban-col-progress-fill" style="width: ${progressPercent}%; background: ${columnColor};"></div>
                </div>
              </div>
              <button class="tl-kanban-col-menu" onclick="handleDeleteColumn(${projectIndex}, ${colIndex})" title="Delete column">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
              </button>
            </div>
            
            <div class="tl-kanban-col-tasks" data-col-index="${colIndex}">
              ${column.tasks.map((task, taskIndex) => `
                <div class="tl-kanban-task ${task.done ? 'completed' : ''}" draggable="true" data-task-index="${taskIndex}">
                  <label class="tl-kanban-task-check">
                    <input type="checkbox" ${task.done ? 'checked' : ''} onchange="handleToggleProjectTask(${projectIndex}, ${colIndex}, ${taskIndex}, event)">
                    <span class="tl-kanban-checkmark" style="--check-color: ${columnColor};">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                        <path d="M20 6L9 17l-5-5"/>
                      </svg>
                    </span>
                  </label>
                  <span class="tl-kanban-task-title" contenteditable="true" onblur="handleUpdateTaskTitle(${projectIndex}, ${colIndex}, ${taskIndex}, this.textContent)">${task.title}</span>
                  ${task.priority ? `<span class="tl-kanban-task-priority tl-priority-${task.priority}">${task.priority}</span>` : ''}
                  <button class="tl-kanban-task-delete" onclick="handleDeleteProjectTask(${projectIndex}, ${colIndex}, ${taskIndex}, event)" title="Delete task">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                  </button>
                </div>
              `).join('')}
            </div>
            
            <button class="tl-kanban-add-task" onclick="handleAddTaskToColumn(${projectIndex}, ${colIndex}, event)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14M5 12h14"/>
              </svg>
              <span>Add task</span>
            </button>
          </div>
        `}).join('')}
      </div>
    </div>
  `;


  // Setup scroll sync and event listeners
  setupTimelineInteractions(projectIndex);

  // Sync week ranges header scroll with gantt
  syncWeekRangesScroll();

  // Restore saved scroll position after re-render
  requestAnimationFrame(() => {
    const wrapper = document.getElementById('tlGanttWrapper');
    if (wrapper && (timelineState.scrollLeft || timelineState.scrollTop)) {
      wrapper.scrollLeft = timelineState.scrollLeft || 0;
      wrapper.scrollTop = timelineState.scrollTop || 0;
      // Keep header aligned too
      const headerScroll = document.getElementById('tlDateHeaderScroll');
      if (headerScroll) headerScroll.scrollLeft = wrapper.scrollLeft;
    }

    // Initialize mini-map viewport
    updateMinimapViewport();
  });

  // Setup mini-map interactions
  setupMinimapInteractions(projectIndex, dates, startDate);
}

// Sync week ranges header scroll
function syncWeekRangesScroll() {
  const ganttWrapper = document.getElementById('tlGanttWrapper');
  const weekRangesHeader = document.querySelector('.tl-week-ranges-header');

  if (ganttWrapper && weekRangesHeader) {
    ganttWrapper.addEventListener('scroll', () => {
      weekRangesHeader.scrollLeft = ganttWrapper.scrollLeft;
    });
  }
}

// ============================================
// MINI-MAP NAVIGATION
// Premium feature showing timeline overview
// ============================================

// Mini-map state
let minimapState = {
  isDragging: false,
  startX: 0,
  startScrollLeft: 0
};

// Render mini-map HTML
function renderTimelineMinimap(columns, dates, startDate, projectIndex) {
  if (!dates || dates.length === 0) return '';

  const cellWidth = 48 * timelineState.zoom;
  const totalWidth = dates.length * cellWidth;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Get all tasks with dates for mini-map bars
  const allTasks = [];
  columns.forEach(col => {
    (col.tasks || []).forEach(task => {
      if (task.startDate || task.dueDate || task.endDate) {
        allTasks.push({
          ...task,
          columnColor: col.color
        });
      }
    });
  });

  // Calculate today position as percentage
  const todayOffset = daysBetween(startDate, today);
  const todayPercent = (todayOffset / dates.length) * 100;

  // Format date labels
  const startLabel = startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  const endLabel = dates[dates.length - 1].toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

  // Generate mini-map bars
  const barsHtml = allTasks.map((task, idx) => {
    const taskStart = task.startDate ? new Date(task.startDate) : (task.dueDate ? new Date(task.dueDate) : null);
    const taskEnd = task.endDate || task.dueDate ? new Date(task.endDate || task.dueDate) : taskStart;

    if (!taskStart) return '';

    const startOffset = daysBetween(startDate, taskStart);
    const duration = Math.max(1, daysBetween(taskStart, taskEnd) + 1);

    const leftPercent = (startOffset / dates.length) * 100;
    const widthPercent = (duration / dates.length) * 100;

    // Determine bar color class
    let colorClass = '';
    if (task.done) colorClass = 'done';
    else if (taskEnd < today && !task.done) colorClass = 'overdue';
    else colorClass = 'in-progress';

    // Stack bars vertically (max 3 rows visible)
    const rowHeight = 6;
    const row = idx % 3;
    const top = 2 + (row * rowHeight);

    return `<div class="tl-minimap-bar ${colorClass}" 
                 style="left: ${Math.max(0, leftPercent)}%; width: ${Math.max(0.5, widthPercent)}%; top: ${top}px; background: ${task.columnColor || '#3b82f6'};"
                 title="${task.title || 'Task'}"></div>`;
  }).join('');

  return `
    <div class="tl-minimap-container" id="tlMinimapContainer">
      <div class="tl-minimap-label">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="18" rx="2"/>
          <path d="M3 9h18"/>
          <path d="M9 21V9"/>
        </svg>
        <span>Overview</span>
      </div>
      
      <div class="tl-minimap-track" id="tlMinimapTrack" onclick="handleMinimapClick(event, ${projectIndex})">
        <!-- Date labels -->
        <div class="tl-minimap-dates">
          <span class="tl-minimap-date-label">${startLabel}</span>
          <span class="tl-minimap-date-label">${endLabel}</span>
        </div>
        
        <!-- Task bars -->
        <div class="tl-minimap-bars">
          ${barsHtml}
        </div>
        
        <!-- Today indicator -->
        ${todayPercent >= 0 && todayPercent <= 100 ? `
          <div class="tl-minimap-today" style="left: ${todayPercent}%;"></div>
        ` : ''}
        
        <!-- Viewport indicator (draggable) -->
        <div class="tl-minimap-viewport" id="tlMinimapViewport"
             onmousedown="startMinimapDrag(event, ${projectIndex})">
          <div class="tl-minimap-viewport-handle left"></div>
          <div class="tl-minimap-viewport-handle right"></div>
        </div>
      </div>
      
      <div class="tl-minimap-nav">
        <button class="tl-minimap-nav-btn" onclick="minimapNavigate('start', ${projectIndex})" title="Jump to start">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="11 17 6 12 11 7"/>
            <polyline points="18 17 13 12 18 7"/>
          </svg>
        </button>
        <button class="tl-minimap-nav-btn" onclick="minimapNavigate('today', ${projectIndex})" title="Jump to today">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
            <polyline points="12 6 12 12 16 14"/>
          </svg>
        </button>
        <button class="tl-minimap-nav-btn" onclick="minimapNavigate('end', ${projectIndex})" title="Jump to end">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="13 17 18 12 13 7"/>
            <polyline points="6 17 11 12 6 7"/>
          </svg>
        </button>
      </div>
    </div>
  `;
}

// Update mini-map viewport position based on current scroll
function updateMinimapViewport() {
  const ganttWrapper = document.getElementById('tlGanttWrapper');
  const ganttGrid = document.getElementById('tlGanttGrid');
  const viewport = document.getElementById('tlMinimapViewport');
  const track = document.getElementById('tlMinimapTrack');

  if (!ganttWrapper || !ganttGrid || !viewport || !track) return;

  const totalWidth = ganttGrid.scrollWidth;
  const visibleWidth = ganttWrapper.clientWidth;
  const scrollLeft = ganttWrapper.scrollLeft;

  if (totalWidth <= 0) return;

  const trackWidth = track.clientWidth;

  // Calculate viewport position and width as percentage
  const leftPercent = (scrollLeft / totalWidth) * 100;
  const widthPercent = Math.min(100, (visibleWidth / totalWidth) * 100);

  viewport.style.left = `${leftPercent}%`;
  viewport.style.width = `${Math.max(20, widthPercent)}%`; // Min 20px width
}

// Setup mini-map interactions
function setupMinimapInteractions(projectIndex, dates, startDate) {
  const ganttWrapper = document.getElementById('tlGanttWrapper');

  if (ganttWrapper) {
    // Update viewport on scroll
    ganttWrapper.addEventListener('scroll', () => {
      if (!minimapState.isDragging) {
        updateMinimapViewport();
      }
    });
  }

  // Handle mouse move and up for dragging
  document.addEventListener('mousemove', handleMinimapDragMove);
  document.addEventListener('mouseup', handleMinimapDragEnd);
}

// Start dragging the viewport
function startMinimapDrag(event, projectIndex) {
  event.preventDefault();
  event.stopPropagation();

  const viewport = document.getElementById('tlMinimapViewport');
  const ganttWrapper = document.getElementById('tlGanttWrapper');

  if (!viewport || !ganttWrapper) return;

  minimapState.isDragging = true;
  minimapState.startX = event.clientX;
  minimapState.startScrollLeft = ganttWrapper.scrollLeft;
  minimapState.projectIndex = projectIndex;

  viewport.classList.add('dragging');
  document.body.style.cursor = 'grabbing';
  document.body.style.userSelect = 'none';
}

// Handle drag movement
function handleMinimapDragMove(event) {
  if (!minimapState.isDragging) return;

  const track = document.getElementById('tlMinimapTrack');
  const ganttWrapper = document.getElementById('tlGanttWrapper');
  const ganttGrid = document.getElementById('tlGanttGrid');

  if (!track || !ganttWrapper || !ganttGrid) return;

  const trackRect = track.getBoundingClientRect();
  const deltaX = event.clientX - minimapState.startX;

  // Convert pixel movement to scroll position
  const totalWidth = ganttGrid.scrollWidth;
  const trackWidth = trackRect.width;
  const scrollDelta = (deltaX / trackWidth) * totalWidth;

  const newScrollLeft = minimapState.startScrollLeft + scrollDelta;
  ganttWrapper.scrollLeft = Math.max(0, Math.min(newScrollLeft, totalWidth - ganttWrapper.clientWidth));

  // Update header scroll
  const headerScroll = document.getElementById('tlDateHeaderScroll');
  if (headerScroll) headerScroll.scrollLeft = ganttWrapper.scrollLeft;

  // Update week ranges scroll
  const weekRangesHeader = document.querySelector('.tl-week-ranges-header');
  if (weekRangesHeader) weekRangesHeader.scrollLeft = ganttWrapper.scrollLeft;

  updateMinimapViewport();
}

// End dragging
function handleMinimapDragEnd() {
  if (!minimapState.isDragging) return;

  minimapState.isDragging = false;

  const viewport = document.getElementById('tlMinimapViewport');
  if (viewport) viewport.classList.remove('dragging');

  document.body.style.cursor = '';
  document.body.style.userSelect = '';
}

// Handle click on mini-map track to jump to position
function handleMinimapClick(event, projectIndex) {
  const viewport = document.getElementById('tlMinimapViewport');

  // Ignore if clicking on viewport itself
  if (event.target === viewport || viewport.contains(event.target)) return;

  const track = document.getElementById('tlMinimapTrack');
  const ganttWrapper = document.getElementById('tlGanttWrapper');
  const ganttGrid = document.getElementById('tlGanttGrid');

  if (!track || !ganttWrapper || !ganttGrid) return;

  const trackRect = track.getBoundingClientRect();
  const clickX = event.clientX - trackRect.left;
  const clickPercent = clickX / trackRect.width;

  const totalWidth = ganttGrid.scrollWidth;
  const visibleWidth = ganttWrapper.clientWidth;

  // Center the view on the clicked position
  const targetScrollLeft = (clickPercent * totalWidth) - (visibleWidth / 2);

  // Smooth scroll to position
  ganttWrapper.scrollTo({
    left: Math.max(0, Math.min(targetScrollLeft, totalWidth - visibleWidth)),
    behavior: 'smooth'
  });

  // Update header scroll
  setTimeout(() => {
    const headerScroll = document.getElementById('tlDateHeaderScroll');
    if (headerScroll) headerScroll.scrollLeft = ganttWrapper.scrollLeft;

    const weekRangesHeader = document.querySelector('.tl-week-ranges-header');
    if (weekRangesHeader) weekRangesHeader.scrollLeft = ganttWrapper.scrollLeft;

    updateMinimapViewport();
  }, 300);
}

// Quick navigation functions
function minimapNavigate(target, projectIndex) {
  const ganttWrapper = document.getElementById('tlGanttWrapper');
  const ganttGrid = document.getElementById('tlGanttGrid');

  if (!ganttWrapper || !ganttGrid) return;

  const totalWidth = ganttGrid.scrollWidth;
  const visibleWidth = ganttWrapper.clientWidth;

  let targetScrollLeft = 0;

  switch (target) {
    case 'start':
      targetScrollLeft = 0;
      break;
    case 'end':
      targetScrollLeft = totalWidth - visibleWidth;
      break;
    case 'today':
      // Find today marker and scroll to it
      const todayMarker = document.querySelector('.tl-today-line-clickup, .tl-today-marker');
      if (todayMarker) {
        const markerLeft = parseFloat(todayMarker.style.left) || 0;
        targetScrollLeft = markerLeft - (visibleWidth / 2);
      } else {
        // Fallback: scroll to approximate center
        targetScrollLeft = (totalWidth / 2) - (visibleWidth / 2);
      }
      break;
  }

  ganttWrapper.scrollTo({
    left: Math.max(0, Math.min(targetScrollLeft, totalWidth - visibleWidth)),
    behavior: 'smooth'
  });

  setTimeout(() => {
    const headerScroll = document.getElementById('tlDateHeaderScroll');
    if (headerScroll) headerScroll.scrollLeft = ganttWrapper.scrollLeft;

    const weekRangesHeader = document.querySelector('.tl-week-ranges-header');
    if (weekRangesHeader) weekRangesHeader.scrollLeft = ganttWrapper.scrollLeft;

    updateMinimapViewport();
  }, 300);
}


function toggleTimelineColumnExpand(colId, projectIndex) {
  timelineExpandedColumns[colId] = !timelineExpandedColumns[colId];
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

// Expand/collapse all columns
function expandAllTimelineColumns(projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  const allExpanded = (project.columns || []).every((_, idx) => timelineExpandedColumns[`col-${idx}`]);
  (project.columns || []).forEach((_, idx) => {
    timelineExpandedColumns[`col-${idx}`] = !allExpanded;
  });

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

// Render column list V3 with expandable tasks
function renderTimelineColumnListV3(columns, projectIndex) {
  let html = '';

  columns.forEach(col => {
    const progress = col.taskCount > 0 ? Math.round((col.completedCount / col.taskCount) * 100) : 0;
    const dateRange = col.minDate && col.maxDate
      ? `${formatShortDate(col.minDate)} → ${formatShortDate(col.maxDate)}`
      : (col.tasksWithDates > 0 ? 'Partial dates' : 'No dates');

    // Column header row
    html += `
      <div class="tl-task-item" style="border-left: 3px solid ${col.color}; cursor: pointer;" onclick="toggleTimelineColumnExpand('${col.id}', ${projectIndex})">
        <div class="tl-task-status">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="transition: transform 0.2s; transform: rotate(${col.isExpanded ? '90deg' : '0deg'});">
            <path d="M9 18l6-6-6-6"/>
          </svg>
        </div>
        <div class="tl-task-content">
          <div class="tl-task-title" style="font-weight: 700;">${col.title}</div>
          <div class="tl-task-meta">
            <span class="tl-task-dates">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
              ${dateRange}
            </span>
            <span class="tl-task-count" style="color: ${col.color};">${col.taskCount} tasks</span>
          </div>
          <div style="margin-top: 6px; height: 4px; background: rgba(0,0,0,0.15); border-radius: 2px; overflow: hidden;">
            <div style="width: ${progress}%; height: 100%; background: ${col.color}; border-radius: 2px; transition: width 0.3s;"></div>
          </div>
        </div>
      </div>
    `;

    // Expanded task rows
    if (col.isExpanded && col.tasks.length > 0) {
      col.tasks.forEach(task => {
        const taskDateRange = task.startDate || task.dueDate
          ? `${task.startDate ? formatShortDate(task.startDate) : ''} ${task.startDate && task.dueDate ? '→' : ''} ${task.dueDate ? formatShortDate(task.dueDate) : ''}`
          : 'No date';
        const isDone = task.done || task.status === 'done';

        html += `
          <div class="tl-task-item" style="padding-left: 32px; height: 48px; border-left: 3px solid ${col.color}20; background: rgba(0,0,0,0.02);" 
               onclick="selectTimelineTask('${task.id}', ${projectIndex}, event)">
            <div class="tl-task-status">
              ${isDone
            ? `<svg width="16" height="16" viewBox="0 0 16 16"><circle cx="8" cy="8" r="6" fill="#22c55e"/><path d="M5.5 8l2 2 3.5-3.5" stroke="white" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>`
            : `<svg width="16" height="16" viewBox="0 0 16 16"><circle cx="8" cy="8" r="6" stroke="${col.color}" stroke-width="1.5" fill="none"/></svg>`
          }
            </div>
            <div class="tl-task-content">
              <div class="tl-task-title ${isDone ? 'completed' : ''}" style="font-size: 12px;">${task.title || 'Untitled'}</div>
              <div class="tl-task-meta">
                <span class="tl-task-dates" style="font-size: 10px;">${taskDateRange}</span>
              </div>
            </div>
            ${task.priority ? `<div class="tl-priority-dot ${task.priority}"></div>` : ''}
          </div>
        `;
      });
    }
  });

  return html;
}

// Render date headers V3 with month grouping
function renderTimelineDateHeadersV3(dates, zoom) {
  const cellWidth = 48 * zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Group by month for header row
  let monthHtml = '';
  let currentMonth = '';
  let monthStart = 0;
  let monthCount = 0;

  dates.forEach((date, idx) => {
    const monthKey = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
    if (monthKey !== currentMonth) {
      if (currentMonth) {
        monthHtml += `<div class="tl-month-cell" style="width: ${monthCount * cellWidth}px;">${currentMonth}</div>`;
      }
      currentMonth = monthKey;
      monthStart = idx;
      monthCount = 1;
    } else {
      monthCount++;
    }
  });
  // Last month
  if (currentMonth) {
    monthHtml += `<div class="tl-month-cell" style="width: ${monthCount * cellWidth}px;">${currentMonth}</div>`;
  }

  // Day row
  const dayHtml = dates.map((date, idx) => {
    const isToday = date.toDateString() === today.toDateString();
    const isWeekend = date.getDay() === 0 || date.getDay() === 6;
    const dayName = date.toLocaleDateString('en-US', { weekday: 'short' }).charAt(0);
    const dayNum = date.getDate();

    return `
      <div class="tl-date-col ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px; width: ${cellWidth}px;">
        <div class="tl-date-day">${dayName}</div>
        <div class="tl-date-num">${dayNum}</div>
      </div>
    `;
  }).join('');

  return `
    <div class="tl-month-row">${monthHtml}</div>
    <div class="tl-day-row">${dayHtml}</div>
  `;
}

// Render Gantt rows V3 with expandable task rows
function renderTimelineGanttRowsV3(columns, dates, projectIndex, startDate) {
  const cellWidth = 48 * timelineState.zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let html = '';

  columns.forEach((col, idx) => {
    // Column row
    const cells = dates.map((date, dateIdx) => {
      const isToday = date.toDateString() === today.toDateString();
      const isWeekend = date.getDay() === 0 || date.getDay() === 6;
      return `<div class="tl-gantt-cell ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px;"></div>`;
    }).join('');

    let barHtml = '';
    let left, width, barStartDate, barEndDate;
    const progress = col.taskCount > 0 ? Math.round((col.completedCount / col.taskCount) * 100) : 0;

    if (col.minDate && col.maxDate) {
      const startOffset = daysBetween(startDate, col.minDate);
      const duration = Math.max(1, daysBetween(col.minDate, col.maxDate) + 1);
      left = Math.max(0, startOffset * cellWidth);
      width = Math.max(cellWidth, duration * cellWidth - 4);
      barStartDate = col.minDate.toISOString().split('T')[0];
      barEndDate = col.maxDate.toISOString().split('T')[0];
    } else {
      const todayOffset = daysBetween(startDate, today);
      left = Math.max(0, todayOffset * cellWidth);
      width = 7 * cellWidth - 4;
      barStartDate = today.toISOString().split('T')[0];
      const defaultEnd = new Date(today);
      defaultEnd.setDate(defaultEnd.getDate() + 6);
      barEndDate = defaultEnd.toISOString().split('T')[0];
    }

    // Status icon
    const statusIcon = progress === 100
      ? `<svg class="tl-status-icon done" viewBox="0 0 16 16" style="width:14px;height:14px;"><circle cx="8" cy="8" r="6" fill="#22c55e"/><path d="M5.5 8l2 2 3-3" stroke="#fff" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>`
      : progress > 0
        ? `<svg class="tl-status-icon progress" viewBox="0 0 16 16" style="width:14px;height:14px;"><circle cx="8" cy="8" r="6" stroke="#f59e0b" stroke-width="1.5" fill="none"/><path d="M8 5v3l2 1.5" stroke="#f59e0b" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>`
        : `<svg class="tl-status-icon todo" viewBox="0 0 16 16" style="width:14px;height:14px;"><circle cx="8" cy="8" r="6" stroke="#71717a" stroke-width="1.5" fill="none"/></svg>`;

    barHtml = `
      <div class="tl-bar-header" style="left: ${left}px;">
        <div class="tl-bar-header-left">
          ${statusIcon}
          <span class="tl-bar-header-title">${col.title}</span>
          <span class="tl-bar-header-count">(${col.taskCount})</span>
        </div>
      </div>
      <div class="tl-task-bar column-bar" 
           data-column-id="${col.id}"
           data-column-index="${col.columnIndex}"
           data-start-date="${barStartDate}"
           data-end-date="${barEndDate}"
           style="left: ${left}px; width: ${width}px; background: linear-gradient(180deg, ${col.color}dd 0%, ${col.color} 100%); border: 1px solid ${col.color}; cursor: grab;${!col.minDate ? ' border-style: dashed; opacity: 0.7;' : ''}"
           onmousedown="startColumnBarDrag(event, '${col.id}', ${col.columnIndex}, ${projectIndex})"
           onclick="handleColumnBarClick(event, '${col.id}', ${col.columnIndex}, ${projectIndex})"
           ondblclick="openEditColumnModal(${col.columnIndex}, ${projectIndex})"
           title="${col.title} - ${col.taskCount} tasks (${progress}% complete)">
        <div class="tl-column-bar-actions">
          <button class="tl-bar-quick-btn" onclick="event.stopPropagation(); openEditColumnModal(${col.columnIndex}, ${projectIndex})" title="Edit column">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
              <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
          </button>
          <button class="tl-bar-quick-btn" onclick="event.stopPropagation(); editColumnDates(${col.columnIndex}, ${projectIndex})" title="Edit dates">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="4" width="18" height="18" rx="2"/>
              <line x1="16" y1="2" x2="16" y2="6"/>
              <line x1="8" y1="2" x2="8" y2="6"/>
              <line x1="3" y1="10" x2="21" y2="10"/>
            </svg>
          </button>
        </div>
        <span class="tl-bar-label">${col.title}</span>
        <div class="tl-bar-resize left" onmousedown="startColumnBarResize(event, '${col.id}', ${col.columnIndex}, 'left', ${projectIndex})"></div>
        <div class="tl-bar-resize right" onmousedown="startColumnBarResize(event, '${col.id}', ${col.columnIndex}, 'right', ${projectIndex})"></div>
      </div>
    `;

    html += `<div class="tl-gantt-row" data-row-id="${col.id}">${cells}${barHtml}</div>`;

    // Task rows if expanded
    if (col.isExpanded && col.tasks.length > 0) {
      col.tasks.forEach(task => {
        const taskCells = dates.map((date, dateIdx) => {
          const isToday = date.toDateString() === today.toDateString();
          const isWeekend = date.getDay() === 0 || date.getDay() === 6;
          return `<div class="tl-gantt-cell ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px; height: 48px;"></div>`;
        }).join('');

        let taskBarHtml = '';
        const taskStart = task.startDate ? new Date(task.startDate) : null;
        const taskEnd = task.dueDate ? new Date(task.dueDate) : (task.endDate ? new Date(task.endDate) : taskStart);

        if (taskStart) {
          const taskStartOffset = daysBetween(startDate, taskStart);
          const taskDuration = taskEnd ? Math.max(1, daysBetween(taskStart, taskEnd) + 1) : 1;
          const taskLeft = Math.max(0, taskStartOffset * cellWidth);
          const taskWidth = Math.max(cellWidth - 4, taskDuration * cellWidth - 4);
          const isDone = task.done;

          // Determine task bar color
          const taskColor = task.color || col.color;
          const colorClass = isDone ? 'status-done' : '';

          taskBarHtml = `
            <div class="tl-task-bar ${colorClass}" 
                 data-task-id="${task.id}"
                 data-column-index="${task.columnIndex}"
                 data-task-index="${task.taskIndex}"
                 style="left: ${taskLeft}px; width: ${taskWidth}px; height: 28px; background: linear-gradient(180deg, ${taskColor}cc 0%, ${taskColor} 100%); border-color: ${taskColor};"
                 onmousedown="startTimelineDrag(event, '${task.id}', ${projectIndex})"
                 ondblclick="openTimelineTaskEdit('${task.id}', ${projectIndex})"
                 title="${task.title || 'Untitled'}">
              <span class="tl-bar-label" style="font-size: 11px;">${task.title || ''}</span>
              <div class="tl-bar-resize left" onmousedown="startTaskBarResize(event, '${task.id}', ${task.columnIndex}, ${task.taskIndex}, 'left', ${projectIndex})"></div>
              <div class="tl-bar-resize right" onmousedown="startTaskBarResize(event, '${task.id}', ${task.columnIndex}, ${task.taskIndex}, 'right', ${projectIndex})"></div>
            </div>
          `;
        }

        html += `<div class="tl-gantt-row" data-task-id="${task.id}" style="height: 36px;">${taskCells}${taskBarHtml}</div>`;
      });
    }
  });

  return html;
}

// ============================================
// TIMELINE V5 - ClickUp-Inspired Premium Features
// Dependencies, Avatars, Tooltips, Connection Dots
// ============================================

// Dependencies state
if (typeof tlDependencyState === 'undefined') {
  var tlDependencyState = {
    isConnecting: false,
    sourceTaskId: null,
    sourceElement: null,
    showDependencies: true
  };
}

// Calculate week ranges for ClickUp-style header
function calculateWeekRanges(dates) {
  if (!dates || dates.length === 0) return [];

  const ranges = [];
  let currentRange = null;

  dates.forEach((date, idx) => {
    const weekNum = getWeekNumber(date);

    if (!currentRange || currentRange.weekNum !== weekNum) {
      if (currentRange) {
        currentRange.endDate = dates[idx - 1];
        currentRange.endStr = currentRange.endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        ranges.push(currentRange);
      }
      currentRange = {
        weekNum: weekNum,
        startDate: date,
        startStr: date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
        days: 1
      };
    } else {
      currentRange.days++;
    }
  });

  // Close final range
  if (currentRange) {
    currentRange.endDate = dates[dates.length - 1];
    currentRange.endStr = currentRange.endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    ranges.push(currentRange);
  }

  return ranges;
}

// V5 Column List - Ultra Minimalistic Premium Design
function renderTimelineColumnListV5(columns, projectIndex) {
  let html = '';

  columns.forEach((col, colIdx) => {
    const progress = col.taskCount > 0 ? Math.round((col.completedCount / col.taskCount) * 100) : 0;
    const isComplete = progress === 100;

    // Simple, clean column row
    html += `
      <div class="tl-column-row ${col.isExpanded ? 'expanded' : ''}" onclick="toggleTimelineColumnExpand('${col.id}', ${projectIndex})">
        <div class="tl-column-indicator" style="background: ${col.color};"></div>
        <div class="tl-column-expand">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M9 18l6-6-6-6"/></svg>
        </div>
        <div class="tl-column-info">
          <span class="tl-column-name">${col.title}</span>
          <span class="tl-column-count">${col.taskCount}</span>
        </div>
      </div>
    `;

    // Expanded task rows - also minimal
    if (col.isExpanded && col.tasks.length > 0) {
      col.tasks.forEach((task, taskIdx) => {
        const isDone = task.done || task.status === 'done';

        html += `
          <div class="tl-task-row ${isDone ? 'completed' : ''}" onclick="selectTimelineTask('${task.id}', ${projectIndex}, event)">
            <div class="tl-task-connector" style="border-color: ${col.color}20;"></div>
            <div class="tl-task-check ${isDone ? 'checked' : ''}" onclick="event.stopPropagation(); toggleTimelineTaskDone('${task.id}', ${projectIndex})" style="--check-color: ${col.color};">
              ${isDone ? `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M5 12l5 5L20 7"/></svg>` : ''}
            </div>
            <span class="tl-task-name ${isDone ? 'done' : ''}">${task.title || 'Untitled'}</span>
          </div>
        `;
      });
    }
  });

  return html;
}


// V5 Date Headers with ClickUp-style day columns
function renderTimelineDateHeadersV5(dates, zoom) {
  const cellWidth = 48 * zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const dayHtml = dates.map(date => {
    const isToday = date.toDateString() === today.toDateString();
    const isWeekend = date.getDay() === 0 || date.getDay() === 6;
    const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
    const dayNum = date.getDate();
    const monthName = date.toLocaleDateString('en-US', { month: 'short' });

    return `
      <div class="tl-date-col tl-date-col-clickup ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="width: ${cellWidth}px;">
        <div class="tl-date-day">${dayName}</div>
        <div class="tl-date-num-wrapper ${isToday ? 'today' : ''}">
          <span class="tl-date-num">${dayNum}</span>
        </div>
      </div>
    `;
  }).join('');

  return `<div class="tl-day-row tl-day-row-clickup">${dayHtml}</div>`;
}

// V5 Gantt Rows with ClickUp-style bars
function renderTimelineGanttRowsV5(columns, dates, projectIndex, startDate) {
  const cellWidth = 48 * timelineState.zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let html = '';
  let rowIndex = 0;

  columns.forEach(col => {
    const cells = dates.map(date => {
      const isToday = date.toDateString() === today.toDateString();
      const isWeekend = date.getDay() === 0 || date.getDay() === 6;
      return `<div class="tl-gantt-cell ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px;"></div>`;
    }).join('');

    let left, width, barStartDate, barEndDate;
    const progress = col.taskCount > 0 ? Math.round((col.completedCount / col.taskCount) * 100) : 0;

    if (col.minDate && col.maxDate) {
      const startOffset = daysBetween(startDate, col.minDate);
      const duration = Math.max(1, daysBetween(col.minDate, col.maxDate) + 1);
      left = Math.max(0, startOffset * cellWidth);
      width = Math.max(cellWidth, duration * cellWidth - 4);
      barStartDate = col.minDate.toISOString().split('T')[0];
      barEndDate = col.maxDate.toISOString().split('T')[0];
    } else {
      const todayOffset = daysBetween(startDate, today);
      left = Math.max(0, todayOffset * cellWidth);
      width = 7 * cellWidth - 4;
      barStartDate = today.toISOString().split('T')[0];
      const defaultEnd = new Date(today);
      defaultEnd.setDate(defaultEnd.getDate() + 6);
      barEndDate = defaultEnd.toISOString().split('T')[0];
    }

    // Get assignees for bar avatars
    const assignees = [];
    col.tasks.forEach(t => {
      if (t.assignee && !assignees.find(a => a.name === t.assignee)) {
        assignees.push({ name: t.assignee, avatar: t.assigneeAvatar || null });
      }
    });

    // Determine if bar extends beyond today (for fade effect)
    const barEnd = col.maxDate || new Date();
    const showFade = barEnd > today && progress < 100;

    // Get emoji for bar
    const barEmoji = getBarEmoji(col.title);

    // Get custom milestones for this column
    const customMilestones = col.customMilestones || [];

    const barHtml = `
      <div class="tl-task-bar tl-task-bar-clickup column-bar has-emoji" 
           data-column-id="${col.id}" data-column-index="${col.columnIndex}" data-row-index="${rowIndex}"
           data-start-date="${barStartDate}" data-end-date="${barEndDate}"
           style="left: ${left}px; width: ${width}px; --bar-color: ${col.color}; background: linear-gradient(180deg, ${col.color} 0%, ${adjustColor(col.color, -15)} 100%);${!col.minDate ? ' border-style: dashed; opacity: 0.7;' : ''}"
           onmousedown="startColumnBarDrag(event, '${col.id}', ${col.columnIndex}, ${projectIndex})"
           onclick="showBarContextMenu(event, '${col.id}', 'column', ${projectIndex})"
           ondblclick="openEditColumnModal(${col.columnIndex}, ${projectIndex})">
        
        <!-- Emoji icon on bar -->
        <span class="tl-bar-emoji">${barEmoji}</span>
        
        <!-- Bar Label -->
        <span class="tl-bar-label">${col.title}</span>
        
        <!-- Fade overlay for future/incomplete bars -->
        ${showFade ? '<div class="tl-bar-fade-overlay"></div>' : ''}
        
        <!-- Progress inside bar -->
        <div class="tl-bar-progress-clickup">
          <div class="tl-bar-progress-fill-clickup" style="width: ${progress}%;"></div>
        </div>
        
        <!-- Resize Handles -->
        <div class="tl-bar-resize tl-bar-resize-left" onmousedown="startColumnBarResize(event, '${col.id}', ${col.columnIndex}, 'left', ${projectIndex})"></div>
        <div class="tl-bar-resize tl-bar-resize-right" onmousedown="startColumnBarResize(event, '${col.id}', ${col.columnIndex}, 'right', ${projectIndex})"></div>
      </div>
    `;

    html += `<div class="tl-gantt-row tl-gantt-row-clickup" data-row-id="${col.id}" data-row-index="${rowIndex}">${cells}${barHtml}</div>`;
    rowIndex++;

    // Expanded task rows
    if (col.isExpanded && col.tasks.length > 0) {
      col.tasks.forEach(task => {
        const taskCells = dates.map(date => {
          const isToday = date.toDateString() === today.toDateString();
          const isWeekend = date.getDay() === 0 || date.getDay() === 6;
          return `<div class="tl-gantt-cell ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px; height: 60px;"></div>`;
        }).join('');

        let taskBarHtml = '';
        const taskStart = task.startDate ? new Date(task.startDate) : null;
        const taskEnd = task.dueDate ? new Date(task.dueDate) : (task.endDate ? new Date(task.endDate) : taskStart);

        if (taskStart) {
          const taskStartOffset = daysBetween(startDate, taskStart);
          const taskDuration = taskEnd ? Math.max(1, daysBetween(taskStart, taskEnd) + 1) : 1;
          const taskLeft = Math.max(0, taskStartOffset * cellWidth);
          const taskWidth = Math.max(cellWidth - 4, taskDuration * cellWidth - 4);
          const isDone = task.done;
          const taskColor = task.color || col.color;

          // Check if task extends beyond today for fade effect
          const showTaskFade = taskEnd > today && !isDone;

          // Get emoji for task bar
          const taskEmoji = getBarEmoji(task.title || '');

          // Get custom milestones for this task
          const taskMilestones = task.customMilestones || [];
          const taskStartDateStr = task.startDate || '';
          const taskEndDateStr = task.dueDate || task.endDate || '';

          taskBarHtml = `
            <div class="tl-task-bar tl-task-bar-clickup tl-task-bar-child has-emoji ${isDone ? 'completed' : ''}" 
                 data-task-id="${task.id}" data-column-index="${task.columnIndex}" data-task-index="${task.taskIndex}"
                 data-start-date="${taskStartDateStr}" data-end-date="${taskEndDateStr}"
                 style="left: ${taskLeft}px; width: ${taskWidth}px; --bar-color: ${taskColor}; background: linear-gradient(180deg, ${taskColor} 0%, ${adjustColor(taskColor, -15)} 100%);"
                 onmousedown="startTimelineDrag(event, '${task.id}', ${projectIndex})"
                 onclick="showBarContextMenu(event, '${task.id}', 'task', ${projectIndex})"
                 ondblclick="openTimelineTaskEdit('${task.id}', ${projectIndex})">
              
              <!-- Emoji icon on bar -->
              <span class="tl-bar-emoji">${taskEmoji}</span>
              
              <span class="tl-bar-label">${task.title || ''}</span>
              
              <!-- Fade overlay for future/incomplete tasks -->
              ${showTaskFade ? '<div class="tl-bar-fade-overlay"></div>' : ''}
              
              <div class="tl-bar-resize tl-bar-resize-left" onmousedown="startTaskBarResize(event, '${task.id}', ${task.columnIndex}, ${task.taskIndex}, 'left', ${projectIndex})"></div>
              <div class="tl-bar-resize tl-bar-resize-right" onmousedown="startTaskBarResize(event, '${task.id}', ${task.columnIndex}, ${task.taskIndex}, 'right', ${projectIndex})"></div>
            </div>
          `;
        }

        html += `<div class="tl-gantt-row tl-gantt-row-clickup tl-gantt-row-child" data-task-id="${task.id}" data-row-index="${rowIndex}" style="height: 36px;">${taskCells}${taskBarHtml}</div>`;
        rowIndex++;
      });
    }
  });

  return html;
}

// Render ClickUp-style Today Line - Premium Enhanced
function renderTimelineTodayLineClickup(dates, startDate) {
  const cellWidth = 48 * timelineState.zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const offset = daysBetween(startDate, today);
  if (offset < 0 || offset >= dates.length) return '';

  const left = (offset * cellWidth) + (cellWidth / 2);

  // Format today's date nicely
  const monthName = today.toLocaleDateString('en-US', { month: 'short' });
  const dayNum = today.getDate();

  return `
    <div class="tl-today-line tl-today-line-clickup" style="left: ${left}px;">
      <div class="tl-today-date-label">
        <span class="tl-today-date-label-text">Today</span>
        <span class="tl-today-date-label-date">${monthName} ${dayNum}</span>
      </div>
    </div>
  `;
}

// V2 Dependencies with curved bezier paths
function renderTimelineDependenciesV2(columns, dates, projectIndex, startDate) {
  const cellWidth = 48 * timelineState.zoom;
  const rowHeight = 50; // Updated for tighter spacing

  const allItems = [];
  let rowIndex = 0;

  columns.forEach(col => {
    allItems.push({ id: col.id, row: rowIndex, left: 0, width: 0, minDate: col.minDate, maxDate: col.maxDate, dependencies: col.dependencies || [] });
    rowIndex++;

    if (col.isExpanded && col.tasks.length > 0) {
      col.tasks.forEach(task => {
        allItems.push({ id: task.id, row: rowIndex, startDate: task.startDate, dueDate: task.dueDate, dependencies: task.dependencies || [] });
        rowIndex++;
      });
    }
  });

  // Calculate positions
  allItems.forEach(item => {
    if (item.minDate && item.maxDate) {
      const startOffset = daysBetween(startDate, item.minDate);
      const duration = Math.max(1, daysBetween(item.minDate, item.maxDate) + 1);
      item.left = Math.max(0, startOffset * cellWidth);
      item.width = Math.max(cellWidth, duration * cellWidth - 4);
    } else if (item.startDate) {
      const taskStart = new Date(item.startDate);
      const taskEnd = item.dueDate ? new Date(item.dueDate) : taskStart;
      const startOffset = daysBetween(startDate, taskStart);
      const duration = Math.max(1, daysBetween(taskStart, taskEnd) + 1);
      item.left = Math.max(0, startOffset * cellWidth);
      item.width = Math.max(cellWidth - 4, duration * cellWidth - 4);
    }
  });

  let svg = '';

  allItems.forEach(target => {
    if (!target.dependencies || target.dependencies.length === 0) return;

    target.dependencies.forEach(sourceId => {
      const source = allItems.find(i => i.id === sourceId);
      if (!source || source.width === 0 || !target.width) return;

      const sourceX = source.left + source.width;
      const sourceY = (source.row * rowHeight) + (rowHeight / 2);
      const targetX = target.left;
      const targetY = (target.row * rowHeight) + (rowHeight / 2);

      // Curved bezier path
      const midX = sourceX + (targetX - sourceX) / 2;
      const curve = Math.abs(targetY - sourceY) / 3;

      const path = `M ${sourceX} ${sourceY} C ${sourceX + 30} ${sourceY}, ${targetX - 30} ${targetY}, ${targetX} ${targetY}`;

      svg += `
        <path class="tl-dep-path" d="${path}" fill="none" stroke="#6366f1" stroke-width="2" stroke-dasharray="6,3">
          <animate attributeName="stroke-dashoffset" from="9" to="0" dur="0.5s" repeatCount="indefinite"/>
        </path>
        <circle class="tl-dep-dot-start" cx="${sourceX}" cy="${sourceY}" r="4" fill="#6366f1"/>
        <polygon class="tl-dep-arrow" points="${targetX},${targetY} ${targetX - 8},${targetY - 4} ${targetX - 8},${targetY + 4}" fill="#6366f1"/>
      `;
    });
  });

  return svg;
}

// Helper to adjust color brightness
function adjustColor(color, amount) {
  // Simple hex color adjustment
  if (!color || !color.startsWith('#')) return color;

  let hex = color.replace('#', '');
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }

  const num = parseInt(hex, 16);
  let r = (num >> 16) + amount;
  let g = ((num >> 8) & 0x00FF) + amount;
  let b = (num & 0x0000FF) + amount;

  r = Math.max(0, Math.min(255, r));
  g = Math.max(0, Math.min(255, g));
  b = Math.max(0, Math.min(255, b));

  return '#' + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// Autofit timeline to show all content
function autofitTimeline(projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  // Find date range
  let minDate = null, maxDate = null;
  project.columns.forEach(col => {
    col.tasks.forEach(task => {
      if (task.startDate) {
        const d = new Date(task.startDate);
        if (!minDate || d < minDate) minDate = d;
      }
      if (task.dueDate) {
        const d = new Date(task.dueDate);
        if (!maxDate || d > maxDate) maxDate = d;
      }
    });
  });

  if (minDate && maxDate) {
    timelineState.currentDate = new Date(minDate);
    timelineState.zoom = 1;
    const container = document.querySelector('.pd-content-scroll');
    if (container) renderTimelineView(projectIndex, container);
    showToast('Timeline auto-fitted to content');
  }
}

// Export Gantt chart
function exportGanttChart(projectIndex) {
  showToast('Export feature coming soon');
}

// Toggle Me mode (show only my tasks)
function toggleMeMode(projectIndex) {
  timelineState.meMode = !timelineState.meMode;
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
  showToast(timelineState.meMode ? 'Showing your tasks only' : 'Showing all tasks');
}

// Open sort menu
function openGanttSortMenu(event, projectIndex) {
  event.stopPropagation();
  showToast('Sort options coming soon');
}

// Open assignee filter
function openAssigneeFilter(event, projectIndex) {
  event.stopPropagation();
  showToast('Assignee filter coming soon');
}

// Toggle task done from timeline
async function toggleTimelineTaskDone(taskId, projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  project.columns.forEach(col => {
    col.tasks.forEach(task => {
      if (task.id === taskId) {
        task.done = !task.done;
      }
    });
  });

  saveProjects(projects);

  // Sync to DB if authenticated
  if (window.LayerDB && window.LayerDB.isAuthenticated() && project.id) {
    try {
      await window.LayerDB.updateProject(project.id, { columns: project.columns });
    } catch (error) {
      console.error('Failed to sync task toggle to database:', error);
    }
  }

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

// Toggle dependency mode
// toggleDependencyMode removed

// Toggle timeline filters
function toggleTimelineFilters(projectIndex) {
  showToast('Filters panel coming soon');
}

// V4 Column List with avatars
function renderTimelineColumnListV4(columns, projectIndex) {
  let html = '';

  columns.forEach(col => {
    const progress = col.taskCount > 0 ? Math.round((col.completedCount / col.taskCount) * 100) : 0;
    const dateRange = col.minDate && col.maxDate
      ? `${formatShortDate(col.minDate)} → ${formatShortDate(col.maxDate)}`
      : (col.tasksWithDates > 0 ? 'Partial dates' : 'No dates');

    // Collect unique assignees
    const assignees = [];
    col.tasks.forEach(t => {
      if (t.assignee && !assignees.includes(t.assignee)) {
        assignees.push(t.assignee);
      }
    });

    // Column header row
    html += `
      <div class="tl-task-item" style="border-left: 3px solid ${col.color}; cursor: pointer;" onclick="toggleTimelineColumnExpand('${col.id}', ${projectIndex})">
        <div class="tl-task-status">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="transition: transform 0.2s; transform: rotate(${col.isExpanded ? '90deg' : '0deg'});">
            <path d="M9 18l6-6-6-6"/>
          </svg>
        </div>
        <div class="tl-task-content">
          <div class="tl-task-title" style="font-weight: 700;">${col.title}</div>
          <div class="tl-task-meta">
            <span class="tl-task-dates">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
              ${dateRange}
            </span>
            <span class="tl-task-count" style="color: ${col.color};">${col.taskCount} tasks</span>
          </div>
          <div style="margin-top: 6px; height: 4px; background: rgba(0,0,0,0.15); border-radius: 2px; overflow: hidden;">
            <div style="width: ${progress}%; height: 100%; background: ${col.color}; border-radius: 2px; transition: width 0.3s;"></div>
          </div>
        </div>
        ${assignees.length > 0 ? `
          <div class="tl-task-avatars" style="display: flex; margin-left: 8px;">
            ${assignees.slice(0, 3).map((a, i) => `
              <div class="tl-task-avatar" style="width: 22px; height: 22px; border-radius: 50%; background: linear-gradient(135deg, ${getAvatarColor(a)} 0%, ${getAvatarColorDark(a)} 100%); display: flex; align-items: center; justify-content: center; font-size: 9px; font-weight: 700; color: white; margin-left: ${i > 0 ? '-6px' : '0'}; border: 2px solid var(--card); z-index: ${3 - i};" title="${a}">
                ${a.charAt(0).toUpperCase()}
              </div>
            `).join('')}
            ${assignees.length > 3 ? `<div class="tl-task-avatar" style="width: 22px; height: 22px; border-radius: 50%; background: var(--surface); display: flex; align-items: center; justify-content: center; font-size: 8px; font-weight: 600; color: var(--muted-foreground); margin-left: -6px; border: 2px solid var(--card);">+${assignees.length - 3}</div>` : ''}
          </div>
        ` : ''}
      </div>
    `;

    // Expanded task rows
    if (col.isExpanded && col.tasks.length > 0) {
      col.tasks.forEach(task => {
        const taskDateRange = task.startDate || task.dueDate
          ? `${task.startDate ? formatShortDate(task.startDate) : ''} ${task.startDate && task.dueDate ? '→' : ''} ${task.dueDate ? formatShortDate(task.dueDate) : ''}`
          : 'No date';
        const isDone = task.done || task.status === 'done';
        const hasDependencies = task.dependencies && task.dependencies.length > 0;

        html += `
          <div class="tl-task-item" style="padding-left: 32px; height: 48px; border-left: 3px solid ${col.color}20; background: rgba(0,0,0,0.02);" 
               onclick="selectTimelineTask('${task.id}', ${projectIndex}, event)">
            <div class="tl-task-status">
              ${isDone
            ? `<svg width="16" height="16" viewBox="0 0 16 16"><circle cx="8" cy="8" r="6" fill="#22c55e"/><path d="M5.5 8l2 2 3.5-3.5" stroke="white" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>`
            : `<svg width="16" height="16" viewBox="0 0 16 16"><circle cx="8" cy="8" r="6" stroke="${col.color}" stroke-width="1.5" fill="none"/></svg>`
          }
            </div>
            <div class="tl-task-content">
              <div class="tl-task-title ${isDone ? 'completed' : ''}" style="font-size: 12px;">${task.title || 'Untitled'}</div>
              <div class="tl-task-meta">
                <span class="tl-task-dates" style="font-size: 10px;">${taskDateRange}</span>
                ${hasDependencies ? `<span class="tl-dep-badge" style="font-size: 9px; padding: 1px 5px; background: rgba(99, 102, 241, 0.15); color: #818cf8; border-radius: 4px; margin-left: 6px;">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 10px; height: 10px; margin-right: 2px; vertical-align: middle;">
                    <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/>
                    <polyline points="15 3 21 3 21 9"/>
                    <line x1="10" y1="14" x2="21" y2="3"/>
                  </svg>
                  ${task.dependencies.length}
                </span>` : ''}
              </div>
            </div>
            ${task.assignee ? `
              <div class="tl-task-avatar" style="width: 24px; height: 24px; border-radius: 50%; background: linear-gradient(135deg, ${getAvatarColor(task.assignee)} 0%, ${getAvatarColorDark(task.assignee)} 100%); display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 700; color: white;" title="${task.assignee}">
                ${task.assignee.charAt(0).toUpperCase()}
              </div>
            ` : ''}
            ${task.priority ? `<div class="tl-priority-dot ${task.priority}"></div>` : ''}
          </div>
        `;
      });
    }
  });

  return html;
}

// Get avatar color based on name
function getAvatarColor(name) {
  const colors = ['#3b82f6', '#8b5cf6', '#ec4899', '#f97316', '#14b8a6', '#22c55e', '#eab308', '#ef4444'];
  const hash = name.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  return colors[hash % colors.length];
}

function getAvatarColorDark(name) {
  const colors = ['#2563eb', '#7c3aed', '#db2777', '#ea580c', '#0d9488', '#16a34a', '#ca8a04', '#dc2626'];
  const hash = name.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  return colors[hash % colors.length];
}

// V4 Date Headers with week indicators
function renderTimelineDateHeadersV4(dates, zoom) {
  const cellWidth = 48 * zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Group by month for header row
  let monthHtml = '';
  let currentMonth = '';
  let monthCount = 0;

  dates.forEach((date, idx) => {
    const monthKey = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
    if (monthKey !== currentMonth) {
      if (currentMonth) {
        monthHtml += `<div class="tl-month-cell" style="width: ${monthCount * cellWidth}px;">${currentMonth}</div>`;
      }
      currentMonth = monthKey;
      monthCount = 1;
    } else {
      monthCount++;
    }
  });
  if (currentMonth) {
    monthHtml += `<div class="tl-month-cell" style="width: ${monthCount * cellWidth}px;">${currentMonth}</div>`;
  }

  // Week indicators row
  let weekHtml = '';
  let currentWeek = -1;
  let weekCount = 0;

  dates.forEach((date) => {
    const weekNum = getWeekNumber(date);
    if (weekNum !== currentWeek) {
      if (currentWeek !== -1 && weekCount > 0) {
        weekHtml += `<div class="tl-week-cell" style="width: ${weekCount * cellWidth}px; flex-shrink: 0; padding: 0 8px; font-size: 10px; font-weight: 600; color: #818cf8; display: flex; align-items: center; border-right: 1px solid rgba(99, 102, 241, 0.1);">W${currentWeek}</div>`;
      }
      currentWeek = weekNum;
      weekCount = 1;
    } else {
      weekCount++;
    }
  });
  if (currentWeek !== -1 && weekCount > 0) {
    weekHtml += `<div class="tl-week-cell" style="width: ${weekCount * cellWidth}px; flex-shrink: 0; padding: 0 8px; font-size: 10px; font-weight: 600; color: #818cf8; display: flex; align-items: center; border-right: 1px solid rgba(99, 102, 241, 0.1);">W${currentWeek}</div>`;
  }

  // Day row
  const dayHtml = dates.map((date) => {
    const isToday = date.toDateString() === today.toDateString();
    const isWeekend = date.getDay() === 0 || date.getDay() === 6;
    const dayName = date.toLocaleDateString('en-US', { weekday: 'short' }).charAt(0);
    const dayNum = date.getDate();

    return `
      <div class="tl-date-col ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px; width: ${cellWidth}px;">
        <div class="tl-date-day">${dayName}</div>
        <div class="tl-date-num">${dayNum}</div>
      </div>
    `;
  }).join('');

  return `
    <div class="tl-month-row">${monthHtml}</div>
    <div class="tl-week-row" style="display: flex; height: 20px; border-bottom: 1px solid rgba(255, 255, 255, 0.04); background: rgba(99, 102, 241, 0.03);">${weekHtml}</div>
    <div class="tl-day-row">${dayHtml}</div>
  `;
}

// Get week number
function getWeekNumber(date) {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  const dayNum = d.getUTCDay() || 7;
  d.setUTCDate(d.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
}

// V4 Gantt Rows with avatars, tooltips, connection dots
function renderTimelineGanttRowsV4(columns, dates, projectIndex, startDate) {
  const cellWidth = 48 * timelineState.zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let html = '';
  let rowIndex = 0;

  columns.forEach((col) => {
    const cells = dates.map((date) => {
      const isToday = date.toDateString() === today.toDateString();
      const isWeekend = date.getDay() === 0 || date.getDay() === 6;
      return `<div class="tl-gantt-cell ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px;"></div>`;
    }).join('');

    let left, width, barStartDate, barEndDate;
    const progress = col.taskCount > 0 ? Math.round((col.completedCount / col.taskCount) * 100) : 0;

    if (col.minDate && col.maxDate) {
      const startOffset = daysBetween(startDate, col.minDate);
      const duration = Math.max(1, daysBetween(col.minDate, col.maxDate) + 1);
      left = Math.max(0, startOffset * cellWidth);
      width = Math.max(cellWidth, duration * cellWidth - 4);
      barStartDate = col.minDate.toISOString().split('T')[0];
      barEndDate = col.maxDate.toISOString().split('T')[0];
    } else {
      const todayOffset = daysBetween(startDate, today);
      left = Math.max(0, todayOffset * cellWidth);
      width = 7 * cellWidth - 4;
      barStartDate = today.toISOString().split('T')[0];
      const defaultEnd = new Date(today);
      defaultEnd.setDate(defaultEnd.getDate() + 6);
      barEndDate = defaultEnd.toISOString().split('T')[0];
    }

    // Collect assignees
    const assignees = [];
    col.tasks.forEach(t => {
      if (t.assignee && !assignees.includes(t.assignee)) assignees.push(t.assignee);
    });

    const statusIcon = progress === 100
      ? `<svg class="tl-status-icon done" viewBox="0 0 16 16" style="width:14px;height:14px;"><circle cx="8" cy="8" r="6" fill="#22c55e"/><path d="M5.5 8l2 2 3-3" stroke="#fff" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>`
      : progress > 0
        ? `<svg class="tl-status-icon progress" viewBox="0 0 16 16" style="width:14px;height:14px;"><circle cx="8" cy="8" r="6" stroke="#f59e0b" stroke-width="1.5" fill="none"/><path d="M8 5v3l2 1.5" stroke="#f59e0b" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>`
        : `<svg class="tl-status-icon todo" viewBox="0 0 16 16" style="width:14px;height:14px;"><circle cx="8" cy="8" r="6" stroke="#71717a" stroke-width="1.5" fill="none"/></svg>`;

    const tooltipHtml = `
      <div class="tl-bar-tooltip">
        <div class="tl-tooltip-header">
          <div class="tl-tooltip-status ${progress === 100 ? 'done' : progress > 0 ? 'in-progress' : 'todo'}">${statusIcon}</div>
          <div class="tl-tooltip-title"><h4>${col.title}</h4><span>${col.taskCount} tasks</span></div>
        </div>
        <div class="tl-tooltip-meta">
          <div class="tl-tooltip-meta-item"><span class="tl-tooltip-meta-label">Start</span><span class="tl-tooltip-meta-value">${formatShortDate(barStartDate)}</span></div>
          <div class="tl-tooltip-meta-item"><span class="tl-tooltip-meta-label">End</span><span class="tl-tooltip-meta-value">${formatShortDate(barEndDate)}</span></div>
        </div>
        <div class="tl-tooltip-progress">
          <div class="tl-tooltip-progress-header"><span class="tl-tooltip-progress-label">Progress</span><span class="tl-tooltip-progress-value">${progress}%</span></div>
          <div class="tl-tooltip-progress-bar"><div class="tl-tooltip-progress-fill" style="width: ${progress}%;"></div></div>
        </div>
      </div>
    `;

    const avatarsHtml = assignees.length > 0 ? `
      <div class="tl-bar-avatars">
        ${assignees.slice(0, 3).map((a) => `<div class="tl-bar-avatar" style="background: linear-gradient(135deg, ${getAvatarColor(a)} 0%, ${getAvatarColorDark(a)} 100%);" title="${a}">${a.charAt(0).toUpperCase()}</div>`).join('')}
        ${assignees.length > 3 ? `<div class="tl-bar-avatar tl-bar-avatar-more">+${assignees.length - 3}</div>` : ''}
      </div>
    ` : '';

    const barHtml = `
      <div class="tl-bar-header" style="left: ${left}px;">
        <div class="tl-bar-header-left">${statusIcon}<span class="tl-bar-header-title">${col.title}</span><span class="tl-bar-header-count">(${col.taskCount})</span></div>
      </div>
      <div class="tl-task-bar column-bar" 
           data-column-id="${col.id}" data-column-index="${col.columnIndex}" data-row-index="${rowIndex}"
           data-start-date="${barStartDate}" data-end-date="${barEndDate}"
           style="left: ${left}px; width: ${width}px; background: linear-gradient(180deg, ${col.color}dd 0%, ${col.color} 100%); border: 1px solid ${col.color}; cursor: grab;${!col.minDate ? ' border-style: dashed; opacity: 0.7;' : ''}"
           onmousedown="startColumnBarDrag(event, '${col.id}', ${col.columnIndex}, ${projectIndex})"
           onclick="handleColumnBarClick(event, '${col.id}', ${col.columnIndex}, ${projectIndex})"
           ondblclick="openEditColumnModal(${col.columnIndex}, ${projectIndex})">
        ${tooltipHtml}
        <div class="tl-column-bar-actions">
          <button class="tl-bar-quick-btn" onclick="event.stopPropagation(); openEditColumnModal(${col.columnIndex}, ${projectIndex})" title="Edit"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg></button>
          <button class="tl-bar-quick-btn" onclick="event.stopPropagation(); editColumnDates(${col.columnIndex}, ${projectIndex})" title="Dates"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg></button>
        </div>
        <span class="tl-bar-label">${col.title}</span>
        ${avatarsHtml}
        <div class="tl-bar-resize left" onmousedown="startColumnBarResize(event, '${col.id}', ${col.columnIndex}, 'left', ${projectIndex})"></div>
        <div class="tl-bar-resize right" onmousedown="startColumnBarResize(event, '${col.id}', ${col.columnIndex}, 'right', ${projectIndex})"></div>
      </div>
    `;

    html += `<div class="tl-gantt-row" data-row-id="${col.id}" data-row-index="${rowIndex}">${cells}${barHtml}</div>`;
    rowIndex++;

    if (col.isExpanded && col.tasks.length > 0) {
      col.tasks.forEach(task => {
        const taskCells = dates.map((date) => {
          const isToday = date.toDateString() === today.toDateString();
          const isWeekend = date.getDay() === 0 || date.getDay() === 6;
          return `<div class="tl-gantt-cell ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px; height: 48px;"></div>`;
        }).join('');

        let taskBarHtml = '';
        const taskStart = task.startDate ? new Date(task.startDate) : null;
        const taskEnd = task.dueDate ? new Date(task.dueDate) : (task.endDate ? new Date(task.endDate) : taskStart);

        if (taskStart) {
          const taskStartOffset = daysBetween(startDate, taskStart);
          const taskDuration = taskEnd ? Math.max(1, daysBetween(taskStart, taskEnd) + 1) : 1;
          const taskLeft = Math.max(0, taskStartOffset * cellWidth);
          const taskWidth = Math.max(cellWidth - 4, taskDuration * cellWidth - 4);
          const isDone = task.done;
          const taskColor = task.color || col.color;
          const colorClass = isDone ? 'status-done' : '';

          const taskTooltipHtml = `
            <div class="tl-bar-tooltip">
              <div class="tl-tooltip-header">
                <div class="tl-tooltip-status ${isDone ? 'done' : 'todo'}">
                  ${isDone ? `<svg viewBox="0 0 16 16" style="width:18px;height:18px;"><circle cx="8" cy="8" r="6" fill="#22c55e"/><path d="M5.5 8l2 2 3.5-3.5" stroke="white" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>` : `<svg viewBox="0 0 16 16" style="width:18px;height:18px;"><circle cx="8" cy="8" r="6" stroke="${taskColor}" stroke-width="1.5" fill="none"/></svg>`}
                </div>
                <div class="tl-tooltip-title"><h4>${task.title || 'Untitled'}</h4><span>${col.title}</span></div>
              </div>
              <div class="tl-tooltip-meta">
                <div class="tl-tooltip-meta-item"><span class="tl-tooltip-meta-label">Start</span><span class="tl-tooltip-meta-value">${formatShortDate(task.startDate)}</span></div>
                <div class="tl-tooltip-meta-item"><span class="tl-tooltip-meta-label">Due</span><span class="tl-tooltip-meta-value">${formatShortDate(task.dueDate || task.endDate)}</span></div>
                ${task.assignee ? `<div class="tl-tooltip-meta-item"><span class="tl-tooltip-meta-label">Assignee</span><span class="tl-tooltip-meta-value">${task.assignee}</span></div>` : ''}
              </div>
            </div>
          `;

          taskBarHtml = `
            <div class="tl-task-bar ${colorClass}" 
                 data-task-id="${task.id}" data-column-index="${task.columnIndex}" data-task-index="${task.taskIndex}" data-row-index="${rowIndex}"
                 style="left: ${taskLeft}px; width: ${taskWidth}px; height: 28px; background: linear-gradient(180deg, ${taskColor}cc 0%, ${taskColor} 100%); border-color: ${taskColor};"
                 onmousedown="startTimelineDrag(event, '${task.id}', ${projectIndex})"
                 ondblclick="openTimelineTaskEdit('${task.id}', ${projectIndex})">
              ${taskTooltipHtml}
              <span class="tl-bar-label" style="font-size: 11px;">${task.title || ''}</span>
              ${task.assignee ? `<div class="tl-bar-avatar" style="width: 20px; height: 20px; font-size: 9px; background: linear-gradient(135deg, ${getAvatarColor(task.assignee)} 0%, ${getAvatarColorDark(task.assignee)} 100%); margin-left: auto; margin-right: 4px;" title="${task.assignee}">${task.assignee.charAt(0).toUpperCase()}</div>` : ''}
              <div class="tl-bar-resize left" onmousedown="startTaskBarResize(event, '${task.id}', ${task.columnIndex}, ${task.taskIndex}, 'left', ${projectIndex})"></div>
              <div class="tl-bar-resize right" onmousedown="startTaskBarResize(event, '${task.id}', ${task.columnIndex}, ${task.taskIndex}, 'right', ${projectIndex})"></div>
            </div>
          `;
        }

        html += `<div class="tl-gantt-row" data-task-id="${task.id}" data-row-index="${rowIndex}" style="height: 36px;">${taskCells}${taskBarHtml}</div>`;
        rowIndex++;
      });
    }
  });

  return html;
}

// ============================================
// LINEAR-STYLE MILESTONE SYSTEM
// Diamond milestones on bars with right-click context menu
// ============================================

// Milestone state
if (typeof tlMilestoneState === 'undefined') {
  var tlMilestoneState = {
    draggingMilestone: null,
    activeInputPopup: null,
    activeContextMenu: null
  };
}

// Load milestones for a bar (stored in project.milestones JSONB for DB sync)
function loadBarMilestones(projectIndex, barId) {
  const projects = loadProjects();
  if (!projects[projectIndex]) return [];

  // Milestones are stored in project.milestones object keyed by barId
  const milestones = projects[projectIndex].milestones || {};
  return milestones[barId] || [];
}

// Save milestones for a bar (stored in project for DB sync)
async function saveBarMilestones(projectIndex, barId, milestones) {
  const projects = loadProjects();
  if (!projects[projectIndex]) return;

  // Initialize milestones object if it doesn't exist
  if (!projects[projectIndex].milestones) {
    projects[projectIndex].milestones = {};
  }

  projects[projectIndex].milestones[barId] = milestones;
  saveProjects(projects);

  // Sync to DB if authenticated
  if (window.LayerDB && window.LayerDB.isAuthenticated() && projects[projectIndex].id) {
    try {
      await window.LayerDB.updateProject(projects[projectIndex].id, {
        milestones: projects[projectIndex].milestones
      });
    } catch (error) {
      console.error('Failed to save milestones to database:', error);
    }
  }
}


// Generate milestone ID
function generateMilestoneId() {
  return 'ms_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
}

// Render milestones on a bar
function renderBarMilestones(projectIndex, barId, barWidth) {
  const milestones = loadBarMilestones(projectIndex, barId);
  if (milestones.length === 0) return '';

  return milestones.map(m => {
    const leftPx = (m.position / 100) * barWidth;
    return `
      <div class="tl-bar-milestone" 
           data-milestone-id="${m.id}"
           data-bar-id="${barId}"
           data-project-index="${projectIndex}"
           style="left: ${leftPx}px;"
           onmousedown="startMilestoneDrag(event, '${m.id}', '${barId}', ${projectIndex})"
           oncontextmenu="showMilestoneContextMenu(event, '${m.id}', '${barId}', ${projectIndex})"
           title="${m.name || 'Milestone'}">
        <span class="tl-bar-milestone-label">${m.name || 'Milestone'}</span>
      </div>
    `;
  }).join('');
}

// Add right-click listener to timeline bars
function setupBarContextMenu(projectIndex) {
  document.addEventListener('contextmenu', function (e) {
    const bar = e.target.closest('.tl-task-bar');
    if (!bar) return;

    // Don't show if clicking on milestone
    if (e.target.closest('.tl-bar-milestone')) return;

    e.preventDefault();
    closeAllContextMenus();

    const barId = bar.dataset.columnId || bar.dataset.taskId;
    if (!barId) return;

    const barRect = bar.getBoundingClientRect();
    const clickX = e.clientX - barRect.left;
    const position = Math.max(5, Math.min(95, (clickX / barRect.width) * 100));

    showBarContextMenu(e.clientX, e.clientY, barId, projectIndex, position, barRect.width);
  });

  // Close context menu on click outside
  document.addEventListener('click', closeAllContextMenus);
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape') closeAllContextMenus();
  });
}

// Show bar context menu
function showBarContextMenu(x, y, barId, projectIndex, position, barWidth) {
  closeAllContextMenus();

  const menu = document.createElement('div');
  menu.className = 'tl-bar-context-menu';
  menu.id = 'tlBarContextMenu';
  menu.style.left = `${x}px`;
  menu.style.top = `${y}px`;

  menu.innerHTML = `
    <div class="tl-bar-context-menu-item" onclick="addMilestoneAtPosition('${barId}', ${projectIndex}, ${position}, ${barWidth})">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
      </svg>
      Add marker here
    </div>
    <div class="tl-bar-context-menu-separator"></div>
    <div class="tl-bar-context-menu-item" onclick="closeAllContextMenus(); openEditColumnModal && openEditColumnModal(parseInt('${barId}'.replace('col_', '')), ${projectIndex})">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
        <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
      </svg>
      Edit bar
    </div>
  `;

  document.body.appendChild(menu);
  tlMilestoneState.activeContextMenu = menu;

  // Adjust position if off-screen
  const menuRect = menu.getBoundingClientRect();
  if (menuRect.right > window.innerWidth) {
    menu.style.left = `${x - menuRect.width}px`;
  }
  if (menuRect.bottom > window.innerHeight) {
    menu.style.top = `${y - menuRect.height}px`;
  }
}

// Show milestone context menu (right-click on milestone)
function showMilestoneContextMenu(e, milestoneId, barId, projectIndex) {
  e.preventDefault();
  e.stopPropagation();
  closeAllContextMenus();

  const milestones = loadBarMilestones(projectIndex, barId);
  const milestone = milestones.find(m => m.id === milestoneId);
  if (!milestone) return;

  const menu = document.createElement('div');
  menu.className = 'tl-bar-context-menu';
  menu.id = 'tlBarContextMenu';
  menu.style.left = `${e.clientX}px`;
  menu.style.top = `${e.clientY}px`;

  menu.innerHTML = `
    <div class="tl-bar-context-menu-item" onclick="editMilestoneName('${milestoneId}', '${barId}', ${projectIndex}, ${e.clientX}, ${e.clientY})">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
        <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
      </svg>
      Edit label
    </div>
    <div class="tl-bar-context-menu-separator"></div>
    <div class="tl-bar-context-menu-item danger" onclick="deleteMilestone('${milestoneId}', '${barId}', ${projectIndex})">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="3 6 5 6 21 6"/>
        <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
      </svg>
      Delete marker
    </div>
  `;

  document.body.appendChild(menu);
  tlMilestoneState.activeContextMenu = menu;
}

// Close all context menus and popups
function closeAllContextMenus() {
  const menu = document.getElementById('tlBarContextMenu');
  if (menu) menu.remove();
  const popup = document.getElementById('tlMilestoneInputPopup');
  if (popup) popup.remove();
  tlMilestoneState.activeContextMenu = null;
  tlMilestoneState.activeInputPopup = null;
}

// Add milestone at position
function addMilestoneAtPosition(barId, projectIndex, position, barWidth) {
  closeAllContextMenus();

  // Show input popup for name
  const bar = document.querySelector(`[data-column-id="${barId}"], [data-task-id="${barId}"]`);
  if (!bar) return;

  const barRect = bar.getBoundingClientRect();
  const leftPx = (position / 100) * barRect.width;

  const popup = document.createElement('div');
  popup.className = 'tl-milestone-input-popup';
  popup.id = 'tlMilestoneInputPopup';
  popup.style.left = `${barRect.left + leftPx}px`;
  popup.style.top = `${barRect.bottom + 20}px`;

  popup.innerHTML = `
    <div class="tl-milestone-input-title">New Marker</div>
    <input type="text" class="tl-milestone-input-field" id="milestoneNameInput" 
           placeholder="e.g., POC, Beta, Internal Release..." autofocus>
    <div class="tl-milestone-input-actions">
      <button class="tl-milestone-input-btn cancel" onclick="closeAllContextMenus()">Cancel</button>
      <button class="tl-milestone-input-btn save" onclick="saveMilestoneFromInput('${barId}', ${projectIndex}, ${position})">Add</button>
    </div>
  `;

  document.body.appendChild(popup);
  tlMilestoneState.activeInputPopup = popup;

  const input = document.getElementById('milestoneNameInput');
  input.focus();
  input.addEventListener('keydown', function (e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      saveMilestoneFromInput(barId, projectIndex, position);
    } else if (e.key === 'Escape') {
      closeAllContextMenus();
    }
  });
}

// Save milestone from input popup
function saveMilestoneFromInput(barId, projectIndex, position) {
  const input = document.getElementById('milestoneNameInput');
  const name = input ? input.value.trim() : '';

  if (!name) {
    closeAllContextMenus();
    return;
  }

  const milestones = loadBarMilestones(projectIndex, barId);
  milestones.push({
    id: generateMilestoneId(),
    name: name,
    position: position,
    completed: false,
    createdAt: new Date().toISOString()
  });

  saveBarMilestones(projectIndex, barId, milestones);
  closeAllContextMenus();

  // Refresh timeline
  refreshTimelineView(projectIndex);
  showToast && showToast(`Milestone "${name}" added`);
}

// Edit milestone name
function editMilestoneName(milestoneId, barId, projectIndex, x, y) {
  closeAllContextMenus();

  const milestones = loadBarMilestones(projectIndex, barId);
  const milestone = milestones.find(m => m.id === milestoneId);
  if (!milestone) return;

  const popup = document.createElement('div');
  popup.className = 'tl-milestone-input-popup';
  popup.id = 'tlMilestoneInputPopup';
  popup.style.left = `${x}px`;
  popup.style.top = `${y}px`;

  popup.innerHTML = `
    <div class="tl-milestone-input-title">Edit Marker Label</div>
    <input type="text" class="tl-milestone-input-field" id="milestoneNameInput" 
           value="${milestone.name}" autofocus>
    <div class="tl-milestone-input-actions">
      <button class="tl-milestone-input-btn cancel" onclick="closeAllContextMenus()">Cancel</button>
      <button class="tl-milestone-input-btn save" onclick="updateMilestoneName('${milestoneId}', '${barId}', ${projectIndex})">Save</button>
    </div>
  `;

  document.body.appendChild(popup);
  tlMilestoneState.activeInputPopup = popup;

  const input = document.getElementById('milestoneNameInput');
  input.focus();
  input.select();
  input.addEventListener('keydown', function (e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      updateMilestoneName(milestoneId, barId, projectIndex);
    } else if (e.key === 'Escape') {
      closeAllContextMenus();
    }
  });
}

// Update milestone name
function updateMilestoneName(milestoneId, barId, projectIndex) {
  const input = document.getElementById('milestoneNameInput');
  const name = input ? input.value.trim() : '';

  if (!name) {
    closeAllContextMenus();
    return;
  }

  const milestones = loadBarMilestones(projectIndex, barId);
  const milestone = milestones.find(m => m.id === milestoneId);
  if (milestone) {
    milestone.name = name;
    saveBarMilestones(projectIndex, barId, milestones);
    closeAllContextMenus();
    refreshTimelineView(projectIndex);
    showToast && showToast('Milestone updated');
  }
}

// Toggle milestone complete
function toggleMilestoneComplete(milestoneId, barId, projectIndex) {
  closeAllContextMenus();

  const milestones = loadBarMilestones(projectIndex, barId);
  const milestone = milestones.find(m => m.id === milestoneId);
  if (milestone) {
    milestone.completed = !milestone.completed;
    saveBarMilestones(projectIndex, barId, milestones);
    refreshTimelineView(projectIndex);
    showToast && showToast(milestone.completed ? 'Milestone completed!' : 'Milestone reopened');
  }
}

// Delete milestone
function deleteMilestone(milestoneId, barId, projectIndex) {
  closeAllContextMenus();

  let milestones = loadBarMilestones(projectIndex, barId);
  milestones = milestones.filter(m => m.id !== milestoneId);
  saveBarMilestones(projectIndex, barId, milestones);
  refreshTimelineView(projectIndex);
  showToast && showToast('Milestone deleted');
}

// Start dragging a milestone
function startMilestoneDrag(e, milestoneId, barId, projectIndex) {
  if (e.button !== 0) return; // Only left click
  e.preventDefault();
  e.stopPropagation();

  const milestoneEl = e.target.closest('.tl-bar-milestone');
  const bar = document.querySelector(`[data-column-id="${barId}"], [data-task-id="${barId}"]`);
  if (!milestoneEl || !bar) return;

  milestoneEl.classList.add('dragging');

  tlMilestoneState.draggingMilestone = {
    milestoneId,
    barId,
    projectIndex,
    element: milestoneEl,
    bar: bar,
    barWidth: bar.offsetWidth,
    startX: e.clientX,
    startLeft: parseFloat(milestoneEl.style.left) || 0
  };

  document.addEventListener('mousemove', handleMilestoneDrag);
  document.addEventListener('mouseup', endMilestoneDrag);
}

// Handle milestone drag
function handleMilestoneDrag(e) {
  const state = tlMilestoneState.draggingMilestone;
  if (!state) return;

  const deltaX = e.clientX - state.startX;
  let newLeft = state.startLeft + deltaX;

  // Clamp to bar bounds
  newLeft = Math.max(10, Math.min(state.barWidth - 10, newLeft));
  state.element.style.left = `${newLeft}px`;
}

// End milestone drag
function endMilestoneDrag(e) {
  document.removeEventListener('mousemove', handleMilestoneDrag);
  document.removeEventListener('mouseup', endMilestoneDrag);

  const state = tlMilestoneState.draggingMilestone;
  if (!state) return;

  state.element.classList.remove('dragging');

  const newLeft = parseFloat(state.element.style.left) || 0;
  const newPosition = (newLeft / state.barWidth) * 100;

  // Update milestone position
  const milestones = loadBarMilestones(state.projectIndex, state.barId);
  const milestone = milestones.find(m => m.id === state.milestoneId);
  if (milestone) {
    milestone.position = newPosition;
    saveBarMilestones(state.projectIndex, state.barId, milestones);
  }

  tlMilestoneState.draggingMilestone = null;
}

// Refresh timeline view helper
function refreshTimelineView(projectIndex) {
  const container = document.querySelector('.pd-content-scroll');
  if (container && typeof renderTimelineView === 'function') {
    renderTimelineView(projectIndex, container);
  }
}

// Check if task/column is overdue
function isBarOverdue(endDate) {
  if (!endDate) return false;
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const end = new Date(endDate);
  end.setHours(0, 0, 0, 0);
  return end < today;
}

// Dependency functions removed
function renderTimelineDependencies() { return ''; }
function renderDependencyArrow() { return ''; }

// Get column color based on title
function getColumnColor(title) {
  const lowerTitle = title.toLowerCase();
  if (lowerTitle.includes('done') || lowerTitle.includes('complete')) return '#10b981';
  if (lowerTitle.includes('progress') || lowerTitle.includes('doing')) return '#f59e0b';
  if (lowerTitle.includes('review') || lowerTitle.includes('test')) return '#8b5cf6';
  if (lowerTitle.includes('todo') || lowerTitle.includes('backlog')) return '#6b7280';
  return '#3b82f6';
}

// Render column list for timeline left panel
function renderTimelineColumnList(columns) {
  let html = '';

  // Column rows
  columns.forEach(col => {
    const progress = col.taskCount > 0 ? Math.round((col.completedCount / col.taskCount) * 100) : 0;
    const dateRange = col.minDate && col.maxDate
      ? `${formatShortDate(col.minDate)} → ${formatShortDate(col.maxDate)}`
      : (col.tasksWithDates > 0 ? 'Partial dates' : 'No dates');

    html += `
      <div class="tl-task-item" style="border-left: 3px solid ${col.color};">
        <div class="tl-task-status">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <rect x="2" y="2" width="12" height="12" rx="2" stroke="${col.color}" stroke-width="1.5"/>
            <rect x="4" y="6" width="8" height="1.5" fill="${col.color}" opacity="0.5"/>
            <rect x="4" y="9" width="5" height="1.5" fill="${col.color}" opacity="0.5"/>
          </svg>
        </div>
        <div class="tl-task-content">
          <div class="tl-task-title" style="font-weight: 600;">${col.title}</div>
          <div class="tl-task-meta">
            <span class="tl-task-dates">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
              ${dateRange}
            </span>
            <span class="tl-task-count" style="margin-left: 8px; color: ${col.color};">${col.taskCount} tasks</span>
          </div>
          <div style="margin-top: 6px; height: 4px; background: rgba(0,0,0,0.1); border-radius: 2px; overflow: hidden;">
            <div style="width: ${progress}%; height: 100%; background: ${col.color}; border-radius: 2px;"></div>
          </div>
        </div>
      </div>
    `;
  });

  return html;
}

// Render Gantt rows for columns
function renderTimelineColumnGanttRows(columns, dates, projectIndex, startDate) {
  const cellWidth = 48 * timelineState.zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let html = '';

  // Column rows
  columns.forEach((col, idx) => {
    const cells = dates.map((date, dateIdx) => {
      const isToday = date.toDateString() === today.toDateString();
      const isWeekend = date.getDay() === 0 || date.getDay() === 6;
      return `<div class="tl-gantt-cell ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px;"></div>`;
    }).join('');

    let barHtml = '';
    let left, width, barStartDate, barEndDate;
    const progress = col.taskCount > 0 ? Math.round((col.completedCount / col.taskCount) * 100) : 0;

    if (col.minDate && col.maxDate) {
      // Column has tasks with dates
      const startOffset = daysBetween(startDate, col.minDate);
      const duration = Math.max(1, daysBetween(col.minDate, col.maxDate) + 1);
      left = Math.max(0, startOffset * cellWidth);
      width = Math.max(cellWidth, duration * cellWidth - 4);
      barStartDate = col.minDate.toISOString().split('T')[0];
      barEndDate = col.maxDate.toISOString().split('T')[0];
    } else {
      // No dates - create a default bar starting from today, 7 days wide
      const todayOffset = daysBetween(startDate, today);
      left = Math.max(0, todayOffset * cellWidth);
      width = 7 * cellWidth - 4;
      barStartDate = today.toISOString().split('T')[0];
      const defaultEnd = new Date(today);
      defaultEnd.setDate(defaultEnd.getDate() + 6);
      barEndDate = defaultEnd.toISOString().split('T')[0];
    }

    // Get status icon based on progress
    const statusIcon = progress === 100
      ? `<svg class="tl-status-icon done" viewBox="0 0 16 16"><circle cx="8" cy="8" r="6" fill="#22c55e"/><path d="M5.5 8l2 2 3-3" stroke="#fff" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`
      : progress > 0
        ? `<svg class="tl-status-icon progress" viewBox="0 0 16 16"><circle cx="8" cy="8" r="6" stroke="#f59e0b" stroke-width="1.5" fill="none"/><path d="M8 5v3l2 1.5" stroke="#f59e0b" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg>`
        : `<svg class="tl-status-icon todo" viewBox="0 0 16 16"><circle cx="8" cy="8" r="6" stroke="#71717a" stroke-width="1.5" fill="none"/></svg>`;

    // Priority icon (simplified)
    const priorityIcon = `<svg class="tl-priority-icon" viewBox="0 0 16 16"><path d="M8 2l1.5 3 3.5.5-2.5 2.5.5 3.5L8 10l-3 1.5.5-3.5L3 5.5 6.5 5z" fill="#6366f1" opacity="0.7"/></svg>`;

    // Check if overdue (end date passed and not 100% complete)
    const isOverdue = progress < 100 && isBarOverdue(barEndDate);
    const overdueClass = isOverdue ? 'linear-overdue' : '';

    // Get milestones for this bar
    const milestonesHtml = renderBarMilestones(projectIndex, col.id, width);

    // Build bar style - Linear-style gradient
    let barStyle = `left: ${left}px; width: ${width}px; `;
    if (isOverdue) {
      // Gradient from normal to red for overdue
      barStyle += `background: linear-gradient(90deg, rgba(55, 55, 65, 0.95) 0%, rgba(55, 55, 65, 0.95) 40%, rgba(127, 29, 29, 0.95) 70%, rgba(153, 27, 27, 0.98) 100%); border-color: rgba(239, 68, 68, 0.4);`;
    } else {
      barStyle += `background: linear-gradient(180deg, rgba(55, 55, 65, 0.95) 0%, rgba(42, 42, 52, 0.95) 100%); border: 1px solid rgba(255, 255, 255, 0.1);`;
    }
    if (!col.minDate) {
      barStyle += ' border-style: dashed; opacity: 0.7;';
    }

    barHtml = `
      <!-- Linear-Style Floating Header Above Bar -->
      <div class="tl-bar-header" style="left: ${left}px;">
        <div class="tl-bar-header-left">
          ${statusIcon}
          <span class="tl-bar-header-title">${col.title}</span>
          ${priorityIcon}
          <span class="tl-bar-header-count">(${col.taskCount})</span>
        </div>
      </div>
      <div class="tl-task-bar column-bar ${overdueClass}" 
           data-column-id="${col.id}"
           data-column-index="${col.columnIndex}"
           data-start-date="${barStartDate}"
           data-end-date="${barEndDate}"
           data-has-dates="${col.minDate && col.maxDate ? 'true' : 'false'}"
           style="${barStyle} cursor: grab;"
           onmousedown="startColumnBarDrag(event, '${col.id}', ${col.columnIndex}, ${projectIndex})"
           onclick="handleColumnBarClick(event, '${col.id}', ${col.columnIndex}, ${projectIndex})"
           ondblclick="openEditColumnModal(${col.columnIndex}, ${projectIndex})"
           title="${col.title} - ${col.taskCount} tasks${col.minDate ? ` (${progress}% complete)` : ' (no dates set)'}${isOverdue ? ' - OVERDUE' : ''}">
        <!-- Hover Quick Actions for Column Bar -->
        <div class="tl-column-bar-actions">
          <button class="tl-bar-quick-btn" 
                  onclick="event.stopPropagation(); openEditColumnModal(${col.columnIndex}, ${projectIndex})"
                  title="Edit column">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
              <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
          </button>
          <button class="tl-bar-quick-btn" 
                  onclick="event.stopPropagation(); editColumnDates(${col.columnIndex}, ${projectIndex})"
                  title="Edit dates">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="4" width="18" height="18" rx="2"/>
              <line x1="16" y1="2" x2="16" y2="6"/>
              <line x1="8" y1="2" x2="8" y2="6"/>
              <line x1="3" y1="10" x2="21" y2="10"/>
            </svg>
          </button>
        </div>
        <span class="tl-bar-label">${col.title}</span>
        ${milestonesHtml}
        <div class="tl-bar-resize left" onmousedown="startColumnBarResize(event, '${col.id}', ${col.columnIndex}, 'left', ${projectIndex})"></div>
        <div class="tl-bar-resize right" onmousedown="startColumnBarResize(event, '${col.id}', ${col.columnIndex}, 'right', ${projectIndex})"></div>
      </div>
    `;

    html += `
      <div class="tl-gantt-row" data-row-id="${col.id}">
        ${cells}
        ${barHtml}
      </div>
    `;
  });

  return html;
}

// ============================================
// Enhanced Milestone System
// ============================================

// Render milestones on the timeline
function renderTimelineMilestones(columns, dates, projectIndex, startDate) {
  const cellWidth = 48 * timelineState.zoom;
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return '';

  // Get milestones from project (or create from column end dates)
  let milestones = project.milestones || [];

  // Auto-generate milestones from column end dates if none exist
  if (milestones.length === 0) {
    columns.forEach((col, idx) => {
      if (col.maxDate) {
        milestones.push({
          id: `auto-ms-${col.id}`,
          name: `${col.title} Complete`,
          date: col.maxDate.toISOString().split('T')[0],
          columnId: col.id,
          columnIndex: col.columnIndex,
          progress: col.taskCount > 0 ? Math.round((col.completedCount / col.taskCount) * 100) : 0,
          status: col.completedCount === col.taskCount && col.taskCount > 0 ? 'completed' : 'pending'
        });
      }
    });
  }

  let html = '';

  milestones.forEach((ms, idx) => {
    if (!ms.date) return;

    const msDate = new Date(ms.date);
    const offset = daysBetween(startDate, msDate);
    const left = offset * cellWidth + cellWidth / 2;

    // Determine status class
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    let statusClass = '';
    if (ms.status === 'completed' || ms.progress === 100) {
      statusClass = 'completed';
    } else if (msDate < today) {
      statusClass = 'critical'; // Overdue
    } else if (daysBetween(today, msDate) <= 7) {
      statusClass = 'upcoming';
    }

    // Calculate progress ring values
    const progress = ms.progress || 0;
    const circumference = 2 * Math.PI * 10;
    const strokeDashoffset = circumference - (progress / 100) * circumference;

    html += `
      <div class="tl-milestone" 
           data-milestone-id="${ms.id}"
           style="left: ${left}px; top: 50%; transform: translate(-50%, -50%);"
           onclick="openMilestoneDetails('${ms.id}', ${projectIndex})"
           title="${ms.name} - ${formatShortDate(ms.date)}">
        <div class="tl-milestone-diamond ${statusClass}">
          ${progress > 0 && progress < 100 ? `
            <svg class="tl-milestone-progress" viewBox="0 0 24 24">
              <circle class="progress-bg" cx="12" cy="12" r="10"/>
              <circle class="progress-fill" cx="12" cy="12" r="10" 
                      stroke-dasharray="${circumference}" 
                      stroke-dashoffset="${strokeDashoffset}"/>
            </svg>
          ` : ''}
        </div>
        <div class="tl-milestone-info">
          <span class="tl-milestone-name">${ms.name}</span>
          <span class="tl-milestone-date">${formatShortDate(ms.date)}</span>
        </div>
      </div>
    `;
  });

  return html;
}

// Legacy milestone rendering removed - using new Linear-style system
function renderTimelineMilestonesEnhanced() { return ''; }
function openMilestoneDetails() { }

// Calculate timeline date range
function calculateTimelineDates(tasks, viewMode) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let startDate = new Date(today);
  let endDate = new Date(today);

  // Adjust based on view mode
  switch (viewMode) {
    case 'day':
      startDate.setDate(startDate.getDate() - 3);
      endDate.setDate(endDate.getDate() + 11);
      break;
    case 'week':
      startDate.setDate(startDate.getDate() - 7);
      endDate.setDate(endDate.getDate() + 21);
      break;
    case 'month':
      startDate.setDate(startDate.getDate() - 14);
      endDate.setDate(endDate.getDate() + 45);
      break;
    case 'quarter':
      startDate.setMonth(startDate.getMonth() - 1);
      endDate.setMonth(endDate.getMonth() + 3);
      break;
  }

  // Expand range to include all tasks
  tasks.forEach(task => {
    if (task.startDate) {
      const taskStart = new Date(task.startDate);
      if (taskStart < startDate) startDate = new Date(taskStart);
    }
    if (task.dueDate || task.endDate) {
      const taskEnd = new Date(task.dueDate || task.endDate);
      if (taskEnd > endDate) endDate = new Date(taskEnd);
    }
  });

  // Add padding
  startDate.setDate(startDate.getDate() - 3);
  endDate.setDate(endDate.getDate() + 7);

  // Generate date array
  const dates = [];
  const current = new Date(startDate);
  while (current <= endDate) {
    dates.push(new Date(current));
    current.setDate(current.getDate() + 1);
  }

  return { startDate, endDate, dates };
}

// Render task list
function renderTimelineTaskList(tasks, projectIndex) {
  if (tasks.length === 0) {
    return `
      <div class="tl-empty-state" style="padding: 32px 16px;">
        <div class="tl-empty-icon" style="width: 40px; height: 40px; margin-bottom: 12px;">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="3" y="4" width="18" height="18" rx="2"/>
            <line x1="16" y1="2" x2="16" y2="6"/>
            <line x1="8" y1="2" x2="8" y2="6"/>
            <line x1="3" y1="10" x2="21" y2="10"/>
          </svg>
        </div>
        <p class="tl-empty-title" style="font-size: 14px;">No tasks yet</p>
        <p class="tl-empty-desc" style="font-size: 12px;">Add tasks to see them on the timeline</p>
      </div>
    `;
  }

  // Sort by date
  const sortedTasks = [...tasks].sort((a, b) => {
    const dateA = new Date(a.startDate || a.dueDate || '9999-12-31');
    const dateB = new Date(b.startDate || b.dueDate || '9999-12-31');
    return dateA - dateB;
  });

  return sortedTasks.map((task, idx) => {
    const isSelected = timelineState.selectedTaskIds.includes(task.id);
    const isMilestone = task.type === 'milestone';
    const priority = task.priority || 'none';
    const statusIcon = getTimelineStatusIcon(task.status);

    const startStr = task.startDate ? formatShortDate(task.startDate) : '';
    const endStr = task.dueDate || task.endDate ? formatShortDate(task.dueDate || task.endDate) : '';
    const dateStr = startStr && endStr ? `${startStr} → ${endStr}` : (startStr || endStr || 'No date');

    return `
      <div class="tl-task-item ${isSelected ? 'selected' : ''} ${isMilestone ? 'milestone' : ''}" 
           data-task-id="${task.id}"
           onclick="selectTimelineTask('${task.id}', ${projectIndex}, event)">
        <div class="tl-task-status">${statusIcon}</div>
        <div class="tl-task-content">
          <div class="tl-task-title">${isMilestone ? '◇ ' : ''}${task.columnTitle || task.title || task.name || 'Untitled'}</div>
          <div class="tl-task-meta">
            <span class="tl-task-dates">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
              ${dateStr}
            </span>
            ${priority !== 'none' ? `
              <span class="tl-task-priority">
                <span class="tl-priority-dot ${priority}"></span>
              </span>
            ` : ''}
          </div>
        </div>
        ${task.assignee ? `
          <div class="tl-task-assignee" title="${task.assignee}">${task.assignee.charAt(0).toUpperCase()}</div>
        ` : ''}
      </div>
    `;
  }).join('');
}

// Get status icon
function getTimelineStatusIcon(status) {
  const icons = {
    'todo': `<svg width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" stroke="#a1a1aa" stroke-width="1.5"/></svg>`,
    'in-progress': `<svg width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" stroke="#f59e0b" stroke-width="1.5"/><path d="M8 4v4l2.5 2.5" stroke="#f59e0b" stroke-width="1.5" stroke-linecap="round"/></svg>`,
    'review': `<svg width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" stroke="#8b5cf6" stroke-width="1.5"/></svg>`,
    'done': `<svg width="16" height="16" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" fill="#10b981"/><path d="M5.5 8l2 2 3.5-3.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`
  };
  return icons[status] || icons['todo'];
}

// Render date headers
function renderTimelineDateHeaders(dates, zoom) {
  const cellWidth = 48 * zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  return dates.map((date, idx) => {
    const isToday = date.toDateString() === today.toDateString();
    const isWeekend = date.getDay() === 0 || date.getDay() === 6;
    const dayName = date.toLocaleDateString('en-US', { weekday: 'short' }).charAt(0);
    const dayNum = date.getDate();

    return `
      <div class="tl-date-col ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px; width: ${cellWidth}px;">
        <div class="tl-date-day">${dayName}</div>
        <div class="tl-date-num">${dayNum}</div>
      </div>
    `;
  }).join('');
}

// Render Gantt rows
function renderTimelineGanttRows(tasks, dates, projectIndex, startDate) {
  const cellWidth = 48 * timelineState.zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Sort tasks by date
  const sortedTasks = [...tasks].sort((a, b) => {
    const dateA = new Date(a.startDate || a.dueDate || '9999-12-31');
    const dateB = new Date(b.startDate || b.dueDate || '9999-12-31');
    return dateA - dateB;
  });

  return sortedTasks.map((task, idx) => {
    // Render cells
    const cells = dates.map((date, dateIdx) => {
      const isToday = date.toDateString() === today.toDateString();
      const isWeekend = date.getDay() === 0 || date.getDay() === 6;
      return `<div class="tl-gantt-cell ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px;"></div>`;
    }).join('');

    // Calculate bar position
    const taskStart = task.startDate ? new Date(task.startDate) : (task.dueDate ? new Date(task.dueDate) : null);
    const taskEnd = task.endDate || task.dueDate ? new Date(task.endDate || task.dueDate) : taskStart;

    let barHtml = '';
    if (taskStart) {
      const startOffset = daysBetween(startDate, taskStart);
      const duration = Math.max(1, daysBetween(taskStart, taskEnd) + 1);
      const left = startOffset * cellWidth;
      const width = duration * cellWidth - 4;

      const isMilestone = task.type === 'milestone';
      const isSelected = timelineState.selectedTaskIds.includes(task.id);
      const colorClass = task.color ? `color-${getColorName(task.color)}` : 'color-blue';
      const statusClass = task.status === 'done' || task.done ? 'status-done' : '';

      if (isMilestone) {
        barHtml = `
          <div class="tl-task-bar milestone ${isSelected ? 'selected' : ''}" 
               style="left: ${left + cellWidth / 2 - 14}px;"
               data-task-id="${task.id}"
               ondblclick="openTimelineTaskEdit('${task.id}', ${projectIndex})"
               title="${task.name || task.title}">
          </div>
        `;
      } else {
        barHtml = `
          <div class="tl-task-bar ${colorClass} ${statusClass} ${isSelected ? 'selected' : ''}" 
               style="left: ${left}px; width: ${width}px;"
               data-task-id="${task.id}"
               data-column-index="${task.columnIndex}"
               data-task-index="${task.taskIndex}"
               data-start-date="${task.startDate || ''}"
               data-end-date="${task.dueDate || task.endDate || ''}"
               onmousedown="startTimelineDrag(event, '${task.id}', ${projectIndex})"
               onclick="handleTimelineBarClick(event, '${task.id}', ${projectIndex})"
               ondblclick="openTimelineTaskEdit('${task.id}', ${projectIndex})"
               title="${task.title || task.name}">
            <span class="tl-bar-label">${task.title || task.name || ''}</span>
            <div class="tl-bar-resize left" onmousedown="startTimelineResize(event, '${task.id}', 'left', ${projectIndex})"></div>
            <div class="tl-bar-resize right" onmousedown="startTimelineResize(event, '${task.id}', 'right', ${projectIndex})"></div>
          </div>
        `;
      }
    }

    return `
      <div class="tl-gantt-row" data-task-id="${task.id}">
        ${cells}
        ${barHtml}
      </div>
    `;
  }).join('');
}

// Render today line
function renderTimelineTodayLine(dates, startDate) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const cellWidth = 48 * timelineState.zoom;
  const offset = daysBetween(startDate, today);

  if (offset < 0 || offset >= dates.length) return '';

  const left = offset * cellWidth + cellWidth / 2;
  return `<div class="tl-today-line" style="left: ${left}px;"></div>`;
}

// Helper: Get status from column title
function getColumnStatus(title) {
  const lower = title.toLowerCase();
  if (lower.includes('done') || lower.includes('complete')) return 'done';
  if (lower.includes('progress') || lower.includes('doing')) return 'in-progress';
  if (lower.includes('review')) return 'review';
  return 'todo';
}

// Helper functions
function formatShortDate(dateStr) {
  if (!dateStr) return '';
  const date = new Date(dateStr);
  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

function getColorName(color) {
  const colors = {
    '#3b82f6': 'blue',
    '#8b5cf6': 'purple',
    '#ec4899': 'pink',
    '#ef4444': 'red',
    '#f97316': 'orange',
    '#eab308': 'yellow',
    '#22c55e': 'green',
    '#14b8a6': 'teal',
    '#06b6d4': 'cyan'
  };
  return colors[color] || 'blue';
}

// Timeline Drag State
let tlDragState = {
  isDragging: false,
  isResizing: false,
  taskId: null,
  taskBar: null,
  startX: 0,
  originalLeft: 0,
  originalWidth: 0,
  resizeDirection: null,
  projectIndex: null,
  startDate: null,
  endDate: null,
  columnIndex: null,
  taskIndex: null
};

// Timeline interactions
function setupTimelineInteractions(projectIndex) {
  // Sync scroll between header and grid
  const wrapper = document.getElementById('tlGanttWrapper');
  const headerScroll = document.getElementById('tlDateHeaderScroll');

  if (wrapper && headerScroll) {
    wrapper.addEventListener('scroll', () => {
      headerScroll.scrollLeft = wrapper.scrollLeft;
    });
  }

  // Add global mouse event listeners for drag
  document.addEventListener('mousemove', handleTimelineMouseMove);
  document.addEventListener('mouseup', handleTimelineMouseUp);

  // Keyboard shortcuts
  document.addEventListener('keydown', handleTimelineKeydown);

  // Setup right-click context menu for milestones
  setupBarContextMenu(projectIndex);
}

// Start dragging a task bar
function startTimelineDrag(event, taskId, projectIndex) {
  // Ignore if clicking on resize handles
  if (event.target.classList.contains('tl-bar-resize')) return;

  event.preventDefault();
  event.stopPropagation();

  const taskBar = event.currentTarget;

  tlDragState = {
    isDragging: true,
    isResizing: false,
    taskId: taskId,
    taskBar: taskBar,
    startX: event.clientX,
    originalLeft: parseInt(taskBar.style.left) || 0,
    originalWidth: parseInt(taskBar.style.width) || 100,
    resizeDirection: null,
    projectIndex: projectIndex,
    startDate: taskBar.dataset.startDate,
    endDate: taskBar.dataset.endDate,
    columnIndex: parseInt(taskBar.dataset.columnIndex),
    taskIndex: parseInt(taskBar.dataset.taskIndex)
  };

  taskBar.classList.add('dragging');
  document.body.style.cursor = 'grabbing';
  document.body.style.userSelect = 'none';
}

// Start resizing a task bar (main function)
function startTimelineResize(event, taskId, direction, projectIndex) {
  event.preventDefault();
  event.stopPropagation();

  const taskBar = event.target.closest('.tl-task-bar');
  if (!taskBar) return;

  tlDragState = {
    isDragging: false,
    isResizing: true,
    taskId: taskId,
    taskBar: taskBar,
    startX: event.clientX,
    originalLeft: parseInt(taskBar.style.left) || 0,
    originalWidth: parseInt(taskBar.style.width) || 100,
    resizeDirection: direction,
    projectIndex: projectIndex,
    startDate: taskBar.dataset.startDate,
    endDate: taskBar.dataset.endDate,
    columnIndex: parseInt(taskBar.dataset.columnIndex),
    taskIndex: parseInt(taskBar.dataset.taskIndex)
  };

  taskBar.classList.add('resizing');
  document.body.style.cursor = 'ew-resize';
  document.body.style.userSelect = 'none';
}

// Alias function for task bar resize (called from HTML onmousedown handlers)
function startTaskBarResize(event, taskId, columnIndex, taskIndex, direction, projectIndex) {
  event.preventDefault();
  event.stopPropagation();

  const taskBar = event.target.closest('.tl-task-bar');
  if (!taskBar) return;

  tlDragState = {
    isDragging: false,
    isResizing: true,
    taskId: taskId,
    taskBar: taskBar,
    startX: event.clientX,
    originalLeft: parseInt(taskBar.style.left) || 0,
    originalWidth: parseInt(taskBar.style.width) || 100,
    resizeDirection: direction,
    projectIndex: projectIndex,
    startDate: taskBar.dataset.startDate,
    endDate: taskBar.dataset.endDate,
    columnIndex: columnIndex,
    taskIndex: taskIndex
  };

  taskBar.classList.add('resizing');
  document.body.style.cursor = 'ew-resize';
  document.body.style.userSelect = 'none';
}

// Handle mouse move during drag/resize
function handleTimelineMouseMove(event) {
  if (!tlDragState.isDragging && !tlDragState.isResizing) return;

  const cellWidth = 48 * timelineState.zoom;
  const deltaX = event.clientX - tlDragState.startX;
  const daysDelta = Math.round(deltaX / cellWidth);

  if (tlDragState.isDragging) {
    // Move the task bar
    const newLeft = tlDragState.originalLeft + (daysDelta * cellWidth);
    tlDragState.taskBar.style.left = `${newLeft}px`;

    // Show preview tooltip
    showDragPreview(tlDragState.taskBar, daysDelta);
  } else if (tlDragState.isResizing) {
    if (tlDragState.resizeDirection === 'right') {
      // Resize from right
      const newWidth = Math.max(cellWidth - 4, tlDragState.originalWidth + (daysDelta * cellWidth));
      tlDragState.taskBar.style.width = `${newWidth}px`;
    } else {
      // Resize from left
      const newLeft = tlDragState.originalLeft + (daysDelta * cellWidth);
      const newWidth = Math.max(cellWidth - 4, tlDragState.originalWidth - (daysDelta * cellWidth));
      tlDragState.taskBar.style.left = `${newLeft}px`;
      tlDragState.taskBar.style.width = `${newWidth}px`;
    }

    // Show resize preview
    showResizePreview(tlDragState.taskBar, daysDelta, tlDragState.resizeDirection);
  }
}

// Handle mouse up - finalize drag/resize
function handleTimelineMouseUp(event) {
  if (!tlDragState.isDragging && !tlDragState.isResizing) return;

  const cellWidth = 48 * timelineState.zoom;
  const deltaX = event.clientX - tlDragState.startX;
  const daysDelta = Math.round(deltaX / cellWidth);

  // Remove visual classes
  if (tlDragState.taskBar) {
    tlDragState.taskBar.classList.remove('dragging', 'resizing');
  }
  document.body.style.cursor = '';
  document.body.style.userSelect = '';

  // Remove preview tooltip
  removeDragPreview();

  // Only update if there was actual movement
  if (daysDelta !== 0) {
    if (tlDragState.isDragging) {
      // Update task dates (move both start and end)
      updateTaskDatesAfterDrag(daysDelta);
    } else if (tlDragState.isResizing) {
      // Update task duration
      updateTaskDatesAfterResize(daysDelta, tlDragState.resizeDirection);
    }
  }

  // Reset state
  tlDragState = {
    isDragging: false,
    isResizing: false,
    taskId: null,
    taskBar: null,
    startX: 0,
    originalLeft: 0,
    originalWidth: 0,
    resizeDirection: null,
    projectIndex: null,
    startDate: null,
    endDate: null,
    columnIndex: null,
    taskIndex: null
  };
}

// Update task dates after dragging
async function updateTaskDatesAfterDrag(daysDelta) {
  const projects = loadProjects();
  const project = projects[tlDragState.projectIndex];
  if (!project) return;

  // Find the task
  const task = project.columns[tlDragState.columnIndex]?.tasks[tlDragState.taskIndex];
  if (!task) return;

  // Update start date
  if (task.startDate) {
    const newStart = new Date(task.startDate);
    newStart.setDate(newStart.getDate() + daysDelta);
    task.startDate = newStart.toISOString().split('T')[0];
  }

  // Update end/due date
  if (task.dueDate) {
    const newEnd = new Date(task.dueDate);
    newEnd.setDate(newEnd.getDate() + daysDelta);
    task.dueDate = newEnd.toISOString().split('T')[0];
  }
  if (task.endDate) {
    const newEnd = new Date(task.endDate);
    newEnd.setDate(newEnd.getDate() + daysDelta);
    task.endDate = newEnd.toISOString().split('T')[0];
  }

  // Save to localStorage and auto-sync to DB (debounced)
  saveProjects(projects);

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(tlDragState.projectIndex, container);

  showToast(`Task moved ${Math.abs(daysDelta)} day${Math.abs(daysDelta) !== 1 ? 's' : ''} ${daysDelta > 0 ? 'forward' : 'back'}`);
}

// Update task dates after resizing
async function updateTaskDatesAfterResize(daysDelta, direction) {
  const projects = loadProjects();
  const project = projects[tlDragState.projectIndex];
  if (!project) return;

  // Find the task
  const task = project.columns[tlDragState.columnIndex]?.tasks[tlDragState.taskIndex];
  if (!task) return;

  if (direction === 'right') {
    // Extend/shrink end date
    const endDateField = task.dueDate ? 'dueDate' : 'endDate';
    if (task[endDateField]) {
      const newEnd = new Date(task[endDateField]);
      newEnd.setDate(newEnd.getDate() + daysDelta);
      task[endDateField] = newEnd.toISOString().split('T')[0];
    } else if (task.startDate) {
      // Create end date from start
      const newEnd = new Date(task.startDate);
      newEnd.setDate(newEnd.getDate() + daysDelta);
      task.dueDate = newEnd.toISOString().split('T')[0];
    }
  } else {
    // Move start date
    if (task.startDate) {
      const newStart = new Date(task.startDate);
      newStart.setDate(newStart.getDate() + daysDelta);
      task.startDate = newStart.toISOString().split('T')[0];
    }
  }

  // Save to localStorage and auto-sync to DB (debounced)
  saveProjects(projects);

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(tlDragState.projectIndex, container);

  showToast('Task duration updated');
}

// Show drag preview tooltip
function showDragPreview(taskBar, daysDelta) {
  removeDragPreview();

  if (daysDelta === 0) return;

  const preview = document.createElement('div');
  preview.className = 'tl-drag-preview';
  preview.innerHTML = `
    <span>${daysDelta > 0 ? '+' : ''}${daysDelta} day${Math.abs(daysDelta) !== 1 ? 's' : ''}</span>
  `;

  const rect = taskBar.getBoundingClientRect();
  preview.style.top = `${rect.top - 30}px`;
  preview.style.left = `${rect.left + rect.width / 2}px`;

  document.body.appendChild(preview);
}

// Show resize preview tooltip
function showResizePreview(taskBar, daysDelta, direction) {
  removeDragPreview();

  if (daysDelta === 0) return;

  const preview = document.createElement('div');
  preview.className = 'tl-drag-preview';

  if (direction === 'right') {
    preview.innerHTML = `<span>${daysDelta > 0 ? '+' : ''}${daysDelta} day${Math.abs(daysDelta) !== 1 ? 's' : ''}</span>`;
  } else {
    preview.innerHTML = `<span>${daysDelta > 0 ? '+' : ''}${daysDelta} day${Math.abs(daysDelta) !== 1 ? 's' : ''}</span>`;
  }

  const rect = taskBar.getBoundingClientRect();
  preview.style.top = `${rect.top - 30}px`;
  preview.style.left = `${direction === 'right' ? rect.right - 40 : rect.left}px`;

  document.body.appendChild(preview);
}

// Remove drag preview
function removeDragPreview() {
  const existing = document.querySelector('.tl-drag-preview');
  if (existing) existing.remove();
}

// ============================================
// Column Bar Drag & Resize (Timeline)
// ============================================

let tlColumnDragState = {
  isDragging: false,
  isResizing: false,
  columnId: null,
  columnIndex: null,
  columnBar: null,
  startX: 0,
  originalLeft: 0,
  originalWidth: 0,
  resizeDirection: null,
  projectIndex: null,
  startDate: null,
  endDate: null
};

// Start dragging a column bar
function startColumnBarDrag(event, columnId, columnIndex, projectIndex) {
  if (event.target.classList.contains('tl-bar-resize')) return;

  event.preventDefault();
  event.stopPropagation();

  const columnBar = event.currentTarget;

  tlColumnDragState = {
    isDragging: true,
    isResizing: false,
    columnId: columnId,
    columnIndex: columnIndex,
    columnBar: columnBar,
    startX: event.clientX,
    originalLeft: parseInt(columnBar.style.left) || 0,
    originalWidth: parseInt(columnBar.style.width) || 100,
    resizeDirection: null,
    projectIndex: projectIndex,
    startDate: columnBar.dataset.startDate,
    endDate: columnBar.dataset.endDate
  };

  columnBar.classList.add('dragging');
  columnBar.style.cursor = 'grabbing';
  document.body.style.cursor = 'grabbing';
  document.body.style.userSelect = 'none';

  // Add event listeners
  document.addEventListener('mousemove', handleColumnBarMouseMove);
  document.addEventListener('mouseup', handleColumnBarMouseUp);
}

// Start resizing a column bar
function startColumnBarResize(event, columnId, columnIndex, direction, projectIndex) {
  event.preventDefault();
  event.stopPropagation();

  const columnBar = event.target.closest('.tl-task-bar');
  if (!columnBar) return;

  tlColumnDragState = {
    isDragging: false,
    isResizing: true,
    columnId: columnId,
    columnIndex: columnIndex,
    columnBar: columnBar,
    startX: event.clientX,
    originalLeft: parseInt(columnBar.style.left) || 0,
    originalWidth: parseInt(columnBar.style.width) || 100,
    resizeDirection: direction,
    projectIndex: projectIndex,
    startDate: columnBar.dataset.startDate,
    endDate: columnBar.dataset.endDate
  };

  columnBar.classList.add('resizing');
  document.body.style.cursor = 'ew-resize';
  document.body.style.userSelect = 'none';

  // Add event listeners
  document.addEventListener('mousemove', handleColumnBarMouseMove);
  document.addEventListener('mouseup', handleColumnBarMouseUp);
}

// Handle mouse move during column bar drag/resize
function handleColumnBarMouseMove(event) {
  if (!tlColumnDragState.isDragging && !tlColumnDragState.isResizing) return;

  const cellWidth = 48 * timelineState.zoom;
  const deltaX = event.clientX - tlColumnDragState.startX;
  const daysDelta = Math.round(deltaX / cellWidth);

  if (tlColumnDragState.isDragging) {
    const newLeft = tlColumnDragState.originalLeft + (daysDelta * cellWidth);
    tlColumnDragState.columnBar.style.left = `${newLeft}px`;
    showDragPreview(tlColumnDragState.columnBar, daysDelta);
  } else if (tlColumnDragState.isResizing) {
    if (tlColumnDragState.resizeDirection === 'right') {
      const newWidth = Math.max(cellWidth - 4, tlColumnDragState.originalWidth + (daysDelta * cellWidth));
      tlColumnDragState.columnBar.style.width = `${newWidth}px`;
    } else {
      const newLeft = tlColumnDragState.originalLeft + (daysDelta * cellWidth);
      const newWidth = Math.max(cellWidth - 4, tlColumnDragState.originalWidth - (daysDelta * cellWidth));
      tlColumnDragState.columnBar.style.left = `${newLeft}px`;
      tlColumnDragState.columnBar.style.width = `${newWidth}px`;
    }
    showResizePreview(tlColumnDragState.columnBar, daysDelta, tlColumnDragState.resizeDirection);
  }
}

// Handle mouse up for column bar drag/resize
function handleColumnBarMouseUp(event) {
  document.removeEventListener('mousemove', handleColumnBarMouseMove);
  document.removeEventListener('mouseup', handleColumnBarMouseUp);

  if (!tlColumnDragState.isDragging && !tlColumnDragState.isResizing) return;

  const cellWidth = 48 * timelineState.zoom;
  const deltaX = event.clientX - tlColumnDragState.startX;
  const daysDelta = Math.round(deltaX / cellWidth);

  if (tlColumnDragState.columnBar) {
    tlColumnDragState.columnBar.classList.remove('dragging', 'resizing');
    tlColumnDragState.columnBar.style.cursor = 'grab';
  }
  document.body.style.cursor = '';
  document.body.style.userSelect = '';

  removeDragPreview();

  if (daysDelta !== 0) {
    if (tlColumnDragState.isDragging) {
      updateColumnDatesAfterDrag(daysDelta);
    } else if (tlColumnDragState.isResizing) {
      updateColumnDatesAfterResize(daysDelta, tlColumnDragState.resizeDirection);
    }
  }

  tlColumnDragState = {
    isDragging: false,
    isResizing: false,
    columnId: null,
    columnIndex: null,
    columnBar: null,
    startX: 0,
    originalLeft: 0,
    originalWidth: 0,
    resizeDirection: null,
    projectIndex: null,
    startDate: null,
    endDate: null
  };
}

// Update all task dates in a column after dragging
async function updateColumnDatesAfterDrag(daysDelta) {
  const projects = loadProjects();
  const project = projects[tlColumnDragState.projectIndex];
  if (!project) return;

  const column = project.columns[tlColumnDragState.columnIndex];
  if (!column) return;

  // Get the bar's current dates from the dataset
  const barStartDate = tlColumnDragState.startDate;
  const barEndDate = tlColumnDragState.endDate;

  // Calculate new bar dates
  const newBarStart = new Date(barStartDate);
  newBarStart.setDate(newBarStart.getDate() + daysDelta);
  const newBarEnd = new Date(barEndDate);
  newBarEnd.setDate(newBarEnd.getDate() + daysDelta);

  // If column has tasks with dates, update them
  if (column.tasks && column.tasks.length > 0) {
    const tasksWithDates = column.tasks.filter(t => t.startDate || t.dueDate || t.endDate);

    if (tasksWithDates.length > 0) {
      // Update all tasks in the column that have dates
      column.tasks.forEach(task => {
        if (task.startDate) {
          const newStart = new Date(task.startDate);
          newStart.setDate(newStart.getDate() + daysDelta);
          task.startDate = newStart.toISOString().split('T')[0];
        }
        if (task.dueDate) {
          const newEnd = new Date(task.dueDate);
          newEnd.setDate(newEnd.getDate() + daysDelta);
          task.dueDate = newEnd.toISOString().split('T')[0];
        }
        if (task.endDate) {
          const newEnd = new Date(task.endDate);
          newEnd.setDate(newEnd.getDate() + daysDelta);
          task.endDate = newEnd.toISOString().split('T')[0];
        }
      });
    } else {
      // No tasks have dates - set dates for all tasks based on new bar position
      column.tasks.forEach(task => {
        task.startDate = newBarStart.toISOString().split('T')[0];
        task.dueDate = newBarEnd.toISOString().split('T')[0];
      });
    }
  }

  // Store column-level date info (for columns without task dates)
  if (!column.timelineStart || !column.timelineEnd) {
    column.timelineStart = newBarStart.toISOString().split('T')[0];
    column.timelineEnd = newBarEnd.toISOString().split('T')[0];
  } else {
    const colStart = new Date(column.timelineStart);
    colStart.setDate(colStart.getDate() + daysDelta);
    column.timelineStart = colStart.toISOString().split('T')[0];

    const colEnd = new Date(column.timelineEnd);
    colEnd.setDate(colEnd.getDate() + daysDelta);
    column.timelineEnd = colEnd.toISOString().split('T')[0];
  }

  // Save to localStorage and auto-sync to DB (debounced)
  saveProjects(projects);

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(tlColumnDragState.projectIndex, container);

  showToast(`Column "${column.title}" moved ${Math.abs(daysDelta)} day${Math.abs(daysDelta) !== 1 ? 's' : ''} ${daysDelta > 0 ? 'forward' : 'back'}`);
}

// Update column task dates after resizing
async function updateColumnDatesAfterResize(daysDelta, direction) {
  const projects = loadProjects();
  const project = projects[tlColumnDragState.projectIndex];
  if (!project) return;

  const column = project.columns[tlColumnDragState.columnIndex];
  if (!column) return;

  const barStartDate = tlColumnDragState.startDate;
  const barEndDate = tlColumnDragState.endDate;

  // Get tasks with dates
  const tasksWithDates = (column.tasks || []).filter(t => t.startDate || t.dueDate || t.endDate);

  if (tasksWithDates.length > 0) {
    if (direction === 'right') {
      // Extend end dates
      tasksWithDates.forEach(task => {
        if (task.dueDate) {
          const newEnd = new Date(task.dueDate);
          newEnd.setDate(newEnd.getDate() + daysDelta);
          task.dueDate = newEnd.toISOString().split('T')[0];
        } else if (task.endDate) {
          const newEnd = new Date(task.endDate);
          newEnd.setDate(newEnd.getDate() + daysDelta);
          task.endDate = newEnd.toISOString().split('T')[0];
        }
      });
    } else {
      // Move start dates
      tasksWithDates.forEach(task => {
        if (task.startDate) {
          const newStart = new Date(task.startDate);
          newStart.setDate(newStart.getDate() + daysDelta);
          task.startDate = newStart.toISOString().split('T')[0];
        }
      });
    }
  }

  // Update column-level stored dates
  if (direction === 'right') {
    const newEnd = new Date(barEndDate);
    newEnd.setDate(newEnd.getDate() + daysDelta);
    column.timelineEnd = newEnd.toISOString().split('T')[0];
    if (!column.timelineStart) {
      column.timelineStart = barStartDate;
    }
  } else {
    const newStart = new Date(barStartDate);
    newStart.setDate(newStart.getDate() + daysDelta);
    column.timelineStart = newStart.toISOString().split('T')[0];
    if (!column.timelineEnd) {
      column.timelineEnd = barEndDate;
    }
  }

  // Save to localStorage and auto-sync to DB (debounced)
  saveProjects(projects);

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(tlColumnDragState.projectIndex, container);

  showToast(`Column "${column.title}" dates updated`);
}

// Column bar click handler (context menu removed)
function handleColumnBarClick(event, columnId, columnIndex, projectIndex) {
  // Direct double-click to edit instead of context menu
}

// Handle column bar click
function handleColumnBarClick(event, columnId, columnIndex, projectIndex) {
  // No linking mode - just allow normal clicks
}

// Open edit column modal (name, color)
function openEditColumnModal(columnIndex, projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  const column = project.columns[columnIndex];
  if (!column) return;

  const colorOptions = [
    { name: 'blue', hex: '#3b82f6' },
    { name: 'purple', hex: '#8b5cf6' },
    { name: 'pink', hex: '#ec4899' },
    { name: 'red', hex: '#ef4444' },
    { name: 'orange', hex: '#f97316' },
    { name: 'yellow', hex: '#eab308' },
    { name: 'green', hex: '#22c55e' },
    { name: 'teal', hex: '#14b8a6' },
    { name: 'cyan', hex: '#06b6d4' },
    { name: 'gray', hex: '#6b7280' }
  ];

  // Get current column color
  const currentColor = getColumnColor(column.title) || '#3b82f6';

  const modal = document.createElement('div');
  modal.className = 'modal-overlay';
  modal.id = 'editColumnModal';
  modal.innerHTML = `
    <div class="modal-container quick-edit-modal" style="max-width: 400px;">
      <div class="modal-header">
        <h3>Edit Column</h3>
        <button class="modal-close" onclick="closeEditColumnModal()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
      </div>
      <div class="modal-body" style="display: flex; flex-direction: column; gap: 20px; padding: 20px;">
        <!-- Column Name -->
        <div class="form-group">
          <label style="display: block; font-size: 12px; font-weight: 600; color: var(--muted-foreground); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">Column Name</label>
          <input type="text" id="editColumnName" 
                 value="${(column.title || '').replace(/"/g, '&quot;')}" 
                 style="width: 100%; padding: 12px 14px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--foreground); font-size: 14px;"
                 placeholder="Enter column name...">
        </div>
        
        <!-- Color Picker -->
        <div class="form-group">
          <label style="display: block; font-size: 12px; font-weight: 600; color: var(--muted-foreground); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">Color</label>
          <div class="quick-edit-color-grid" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px;">
            ${colorOptions.map(c => `
              <button type="button" 
                      class="quick-edit-color-btn column-color-btn ${currentColor === c.hex ? 'active' : ''}" 
                      data-color="${c.hex}"
                      onclick="selectColumnColor('${c.hex}')"
                      style="width: 100%; aspect-ratio: 1; border-radius: 8px; background: ${c.hex}; border: 2px solid ${currentColor === c.hex ? 'white' : 'transparent'}; cursor: pointer; transition: all 0.15s;">
              </button>
            `).join('')}
          </div>
          <input type="hidden" id="editColumnColor" value="${currentColor}">
        </div>
      </div>
      <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 10px; padding: 16px 20px; border-top: 1px solid var(--border);">
        <button onclick="closeEditColumnModal()" 
                style="padding: 10px 20px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--foreground); font-size: 13px; cursor: pointer;">
          Cancel
        </button>
        <button onclick="saveEditColumn(${columnIndex}, ${projectIndex})" 
                style="padding: 10px 20px; background: var(--primary); border: none; border-radius: 8px; color: var(--primary-foreground); font-size: 13px; font-weight: 500; cursor: pointer;">
          Save Changes
        </button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  setTimeout(() => document.getElementById('editColumnName')?.focus(), 100);

  modal.addEventListener('click', (e) => {
    if (e.target === modal) closeEditColumnModal();
  });
}

function selectColumnColor(hex) {
  document.getElementById('editColumnColor').value = hex;
  document.querySelectorAll('.column-color-btn').forEach(btn => {
    btn.style.border = btn.dataset.color === hex ? '2px solid white' : '2px solid transparent';
    btn.classList.toggle('active', btn.dataset.color === hex);
  });
}

function closeEditColumnModal() {
  const modal = document.getElementById('editColumnModal');
  if (modal) modal.remove();
}

function saveEditColumn(columnIndex, projectIndex) {
  const name = document.getElementById('editColumnName')?.value?.trim();
  const color = document.getElementById('editColumnColor')?.value;

  if (!name) {
    showToast('Please enter a column name');
    return;
  }

  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project?.columns?.[columnIndex]) return;

  project.columns[columnIndex].title = name;
  project.columns[columnIndex].color = color;

  saveProjects(projects);
  closeEditColumnModal();

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
  showToast('Column updated');
}

// Edit column dates modal
function editColumnDates(columnIndex, projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  const column = project.columns[columnIndex];
  if (!column) return;

  const startDate = column.timelineStart || '';
  const endDate = column.timelineEnd || '';

  const modal = document.createElement('div');
  modal.className = 'modal-overlay';
  modal.id = 'editColumnDatesModal';
  modal.innerHTML = `
    <div class="modal-container" style="max-width: 400px;">
      <div class="modal-header">
        <h3>Edit Column Dates: ${column.title}</h3>
        <button class="modal-close" onclick="closeEditColumnDatesModal()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Start Date</label>
          <input type="date" id="columnStartDate" value="${startDate}" class="form-input">
        </div>
        <div class="form-group">
          <label>End Date</label>
          <input type="date" id="columnEndDate" value="${endDate}" class="form-input">
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" onclick="closeEditColumnDatesModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveColumnDates(${columnIndex}, ${projectIndex})">Save</button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  modal.addEventListener('click', (e) => {
    if (e.target === modal) closeEditColumnDatesModal();
  });
}

function closeEditColumnDatesModal() {
  const modal = document.getElementById('editColumnDatesModal');
  if (modal) modal.remove();
}

function saveColumnDates(columnIndex, projectIndex) {
  const startDate = document.getElementById('columnStartDate').value;
  const endDate = document.getElementById('columnEndDate').value;

  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  const column = project.columns[columnIndex];
  if (!column) return;

  column.timelineStart = startDate;
  column.timelineEnd = endDate;

  saveProjects(projects);
  closeEditColumnDatesModal();

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);

  showToast('Column dates updated');
}

// Task context menu removed - use double-click to edit instead

// Find task by ID in project
function findTaskById(project, taskId) {
  for (const col of project.columns || []) {
    for (const task of col.tasks || []) {
      if (task.id === taskId) return task;
    }
  }
  return null;
}

// Delete a timeline task
function deleteTimelineTask(taskId, colIdx, taskIdx, projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project?.columns?.[colIdx]?.tasks?.[taskIdx]) return;

  project.columns[colIdx].tasks.splice(taskIdx, 1);

  // Also remove this task from other tasks' dependencies
  project.columns.forEach(col => {
    col.tasks.forEach(task => {
      if (task.dependsOn) {
        const idx = task.dependsOn.indexOf(taskId);
        if (idx > -1) task.dependsOn.splice(idx, 1);
      }
    });
  });

  saveProjects(projects);

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);

  showToast('Task deleted');
}

function syncTimelineScroll(wrapper) {
  const headerScroll = document.getElementById('tlDateHeaderScroll');
  if (headerScroll) {
    headerScroll.scrollLeft = wrapper.scrollLeft;
  }

  // Persist scroll so re-renders can restore it
  timelineState.scrollLeft = wrapper.scrollLeft || 0;
  timelineState.scrollTop = wrapper.scrollTop || 0;
}

// Navigation functions
function goToTimelineToday(projectIndex) {
  timelineState.currentDate = new Date();
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);

  // Scroll to today after render
  setTimeout(() => {
    const todayLine = document.querySelector('.tl-today-line');
    const wrapper = document.getElementById('tlGanttWrapper');
    if (todayLine && wrapper) {
      const todayLeft = parseInt(todayLine.style.left);
      wrapper.scrollLeft = todayLeft - wrapper.clientWidth / 2;
    }
  }, 50);
}

function zoomTimeline(delta, projectIndex) {
  // Extended zoom range: 0.15 (6 months) to 2 (detailed day view)
  const newZoom = Math.max(0.15, Math.min(2, timelineState.zoom + delta));
  timelineState.zoom = newZoom;
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

function toggleTimelineFilters() {
  const panel = document.getElementById('tlFiltersPanel');
  if (panel) {
    panel.classList.toggle('show');
  }
}

function toggleTimelineShowDone(projectIndex) {
  timelineState.showDone = !timelineState.showDone;
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

// Handle bar click
function handleTimelineBarClick(event, taskId, projectIndex) {
  // Normal selection
  selectTimelineTask(taskId, projectIndex, event);
}

// Task selection
function selectTimelineTask(taskId, projectIndex, event) {
  if (event.shiftKey) {
    // Multi-select
    const idx = timelineState.selectedTaskIds.indexOf(taskId);
    if (idx > -1) {
      timelineState.selectedTaskIds.splice(idx, 1);
    } else {
      timelineState.selectedTaskIds.push(taskId);
    }
  } else {
    timelineState.selectedTaskIds = [taskId];
  }

  // Update UI
  document.querySelectorAll('.tl-task-item, .tl-task-bar').forEach(el => {
    el.classList.toggle('selected', timelineState.selectedTaskIds.includes(el.dataset.taskId));
  });
}

// Quick add task
function handleTimelineQuickAdd(event, projectIndex) {
  if (event.key === 'Enter' && event.target.value.trim()) {
    const title = event.target.value.trim();
    const projects = loadProjects();
    const project = projects[projectIndex];

    // Add to first column (To Do)
    if (project && project.columns && project.columns[0]) {
      const today = new Date().toISOString().split('T')[0];
      const nextWeek = new Date();
      nextWeek.setDate(nextWeek.getDate() + 7);

      project.columns[0].tasks.push({
        id: generateId('TASK'),
        title: title,
        done: false,
        startDate: today,
        dueDate: nextWeek.toISOString().split('T')[0],
        createdAt: new Date().toISOString()
      });

      saveProjects(projects);
      event.target.value = '';

      // Re-render
      const container = document.querySelector('.pd-content-scroll');
      if (container) renderTimelineView(projectIndex, container);
      showToast('Task added to timeline');
    }
  }
}

// Add task modal
function openTimelineAddTask(projectIndex) {
  showModal('Add Timeline Task', `
    <div style="display: flex; flex-direction: column; gap: 16px;">
      <div>
        <label style="display: block; font-size: 12px; font-weight: 500; color: var(--muted-foreground); margin-bottom: 6px;">Task Title</label>
        <input type="text" id="tlNewTaskTitle" style="width: 100%; padding: 10px 12px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--foreground); font-size: 14px;" placeholder="Enter task title...">
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
        <div>
          <label style="display: block; font-size: 12px; font-weight: 500; color: var(--muted-foreground); margin-bottom: 6px;">Start Date</label>
          <input type="date" id="tlNewTaskStart" style="width: 100%; padding: 10px 12px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--foreground); font-size: 14px;">
        </div>
        <div>
          <label style="display: block; font-size: 12px; font-weight: 500; color: var(--muted-foreground); margin-bottom: 6px;">End Date</label>
          <input type="date" id="tlNewTaskEnd" style="width: 100%; padding: 10px 12px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--foreground); font-size: 14px;">
        </div>
      </div>
      <div style="display: flex; justify-content: flex-end; gap: 8px; margin-top: 8px;">
        <button onclick="closeModal()" style="padding: 10px 20px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--foreground); font-size: 13px; cursor: pointer;">Cancel</button>
        <button onclick="saveTimelineTask(${projectIndex})" style="padding: 10px 20px; background: var(--primary); border: none; border-radius: 8px; color: var(--primary-foreground); font-size: 13px; font-weight: 500; cursor: pointer;">Add Task</button>
      </div>
    </div>
  `);

  // Set default dates
  const today = new Date().toISOString().split('T')[0];
  const nextWeek = new Date();
  nextWeek.setDate(nextWeek.getDate() + 7);
  document.getElementById('tlNewTaskStart').value = today;
  document.getElementById('tlNewTaskEnd').value = nextWeek.toISOString().split('T')[0];

  // Focus title input
  setTimeout(() => document.getElementById('tlNewTaskTitle').focus(), 100);
}

function saveTimelineTask(projectIndex) {
  const title = document.getElementById('tlNewTaskTitle').value.trim();
  const startDate = document.getElementById('tlNewTaskStart').value;
  const endDate = document.getElementById('tlNewTaskEnd').value;

  if (!title) {
    showToast('Please enter a task title');
    return;
  }

  const projects = loadProjects();
  const project = projects[projectIndex];

  if (project && project.columns && project.columns[0]) {
    project.columns[0].tasks.push({
      id: generateId('TASK'),
      title: title,
      done: false,
      startDate: startDate,
      dueDate: endDate,
      createdAt: new Date().toISOString()
    });

    saveProjects(projects);
    closeModal();

    const container = document.querySelector('.pd-content-scroll');
    if (container) renderTimelineView(projectIndex, container);
    showToast('Task added successfully');
  }
}

// Toggle task complete status from timeline
async function toggleTimelineTaskComplete(taskId, projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  // Find the task
  for (const col of project.columns || []) {
    for (const task of col.tasks || []) {
      if (task.id === taskId) {
        // Toggle status
        if (task.status === 'done' || task.status === 'completed' || task.done) {
          task.status = 'todo';
          task.done = false;
        } else {
          task.status = 'done';
          task.done = true;
        }

        // Save to localStorage and auto-sync to DB (debounced)
        saveProjects(projects);

        const container = document.querySelector('.pd-content-scroll');
        if (container) renderTimelineView(projectIndex, container);
        showToast(task.status === 'done' ? 'Task completed!' : 'Task marked incomplete');
        return;
      }
    }
  }
}

// Open quick edit modal for task (name, color, dates)
function openQuickEditTaskModal(taskId, projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  // Find the task
  let foundTask = null;
  let foundColIdx = -1;
  let foundTaskIdx = -1;

  for (let colIdx = 0; colIdx < (project.columns || []).length; colIdx++) {
    const col = project.columns[colIdx];
    for (let taskIdx = 0; taskIdx < (col.tasks || []).length; taskIdx++) {
      if (col.tasks[taskIdx].id === taskId) {
        foundTask = col.tasks[taskIdx];
        foundColIdx = colIdx;
        foundTaskIdx = taskIdx;
        break;
      }
    }
    if (foundTask) break;
  }

  if (!foundTask) {
    showToast('Task not found');
    return;
  }

  const colorOptions = [
    { name: 'blue', hex: '#3b82f6' },
    { name: 'purple', hex: '#8b5cf6' },
    { name: 'pink', hex: '#ec4899' },
    { name: 'red', hex: '#ef4444' },
    { name: 'orange', hex: '#f97316' },
    { name: 'yellow', hex: '#eab308' },
    { name: 'green', hex: '#22c55e' },
    { name: 'teal', hex: '#14b8a6' },
    { name: 'cyan', hex: '#06b6d4' },
    { name: 'gray', hex: '#6b7280' }
  ];

  const currentColor = foundTask.color || '#3b82f6';

  const modal = document.createElement('div');
  modal.className = 'modal-overlay';
  modal.id = 'quickEditTaskModal';
  modal.innerHTML = `
    <div class="modal-container quick-edit-modal" style="max-width: 420px;">
      <div class="modal-header">
        <h3>Edit Task</h3>
        <button class="modal-close" onclick="closeQuickEditTaskModal()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
      </div>
      <div class="modal-body" style="display: flex; flex-direction: column; gap: 20px; padding: 20px;">
        <!-- Task Name -->
        <div class="form-group">
          <label style="display: block; font-size: 12px; font-weight: 600; color: var(--muted-foreground); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">Task Name</label>
          <input type="text" id="quickEditTaskName" 
                 value="${(foundTask.title || foundTask.name || '').replace(/"/g, '&quot;')}" 
                 style="width: 100%; padding: 12px 14px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--foreground); font-size: 14px;"
                 placeholder="Enter task name...">
        </div>
        
        <!-- Dates -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
          <div class="form-group">
            <label style="display: block; font-size: 12px; font-weight: 600; color: var(--muted-foreground); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">Start Date</label>
            <input type="date" id="quickEditStartDate" 
                   value="${foundTask.startDate || ''}" 
                   style="width: 100%; padding: 12px 14px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--foreground); font-size: 14px;">
          </div>
          <div class="form-group">
            <label style="display: block; font-size: 12px; font-weight: 600; color: var(--muted-foreground); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">End Date</label>
            <input type="date" id="quickEditEndDate" 
                   value="${foundTask.endDate || foundTask.dueDate || ''}" 
                   style="width: 100%; padding: 12px 14px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--foreground); font-size: 14px;">
          </div>
        </div>
        
        <!-- Color Picker -->
        <div class="form-group">
          <label style="display: block; font-size: 12px; font-weight: 600; color: var(--muted-foreground); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">Color</label>
          <div class="quick-edit-color-grid" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px;">
            ${colorOptions.map(c => `
              <button type="button" 
                      class="quick-edit-color-btn ${currentColor === c.hex ? 'active' : ''}" 
                      data-color="${c.hex}"
                      onclick="selectQuickEditColor('${c.hex}')"
                      style="width: 100%; aspect-ratio: 1; border-radius: 8px; background: ${c.hex}; border: 2px solid ${currentColor === c.hex ? 'white' : 'transparent'}; cursor: pointer; transition: all 0.15s;">
              </button>
            `).join('')}
          </div>
          <input type="hidden" id="quickEditTaskColor" value="${currentColor}">
        </div>
      </div>
      <div class="modal-footer" style="display: flex; justify-content: flex-end; gap: 10px; padding: 16px 20px; border-top: 1px solid var(--border);">
        <button onclick="closeQuickEditTaskModal()" 
                style="padding: 10px 20px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; color: var(--foreground); font-size: 13px; cursor: pointer;">
          Cancel
        </button>
        <button onclick="saveQuickEditTask('${taskId}', ${projectIndex}, ${foundColIdx}, ${foundTaskIdx})" 
                style="padding: 10px 20px; background: var(--primary); border: none; border-radius: 8px; color: var(--primary-foreground); font-size: 13px; font-weight: 500; cursor: pointer;">
          Save Changes
        </button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // Focus title input
  setTimeout(() => document.getElementById('quickEditTaskName')?.focus(), 100);

  // Close on background click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) closeQuickEditTaskModal();
  });

  // Close on Escape
  const handleEscape = (e) => {
    if (e.key === 'Escape') {
      closeQuickEditTaskModal();
      document.removeEventListener('keydown', handleEscape);
    }
  };
  document.addEventListener('keydown', handleEscape);
}

function selectQuickEditColor(hex) {
  document.getElementById('quickEditTaskColor').value = hex;
  document.querySelectorAll('.quick-edit-color-btn').forEach(btn => {
    btn.style.border = btn.dataset.color === hex ? '2px solid white' : '2px solid transparent';
    btn.classList.toggle('active', btn.dataset.color === hex);
  });
}

function closeQuickEditTaskModal() {
  const modal = document.getElementById('quickEditTaskModal');
  if (modal) modal.remove();
}

function saveQuickEditTask(taskId, projectIndex, colIdx, taskIdx) {
  const name = document.getElementById('quickEditTaskName')?.value?.trim();
  const startDate = document.getElementById('quickEditStartDate')?.value;
  const endDate = document.getElementById('quickEditEndDate')?.value;
  const color = document.getElementById('quickEditTaskColor')?.value;

  if (!name) {
    showToast('Please enter a task name');
    return;
  }

  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project?.columns?.[colIdx]?.tasks?.[taskIdx]) {
    showToast('Task not found');
    return;
  }

  const task = project.columns[colIdx].tasks[taskIdx];
  task.title = name;
  task.name = name;
  task.startDate = startDate || task.startDate;
  task.endDate = endDate;
  task.dueDate = endDate || task.dueDate;
  task.color = color;

  saveProjects(projects);
  closeQuickEditTaskModal();

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
  showToast('Task updated');
}

// Keyboard handler
function handleTimelineKeydown(e) {
  // Only handle if timeline is visible
  const timeline = document.querySelector('.timeline-linear');
  if (!timeline) return;

  // Don't handle if typing in input
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

  const projectIndex = timelineState.lastProjectIndex;

  switch (e.key.toLowerCase()) {
    case 'd':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        setTimelineViewMode('day', projectIndex);
      }
      break;
    case 'w':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        setTimelineViewMode('week', projectIndex);
      }
      break;
    case 'm':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        setTimelineViewMode('month', projectIndex);
      }
      break;
    case 't':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        goToTimelineToday(projectIndex);
      }
      break;
  }
}

// Calculate stats
function calculateTimelineStats(tasks, milestones) {
  const allItems = [...tasks, ...milestones];
  const total = allItems.length;
  const completed = allItems.filter(t => t.status === 'completed' || t.status === 'done').length;
  const inProgress = allItems.filter(t => t.status === 'in-progress' || t.status === 'in_progress').length;
  const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
  return { total, completed, inProgress, percentage };
}

// Resource Section
function renderResourceSection(project, dates, projectIndex) {
  const tasks = project.tasks || [];
  const members = [...new Set(tasks.map(t => t.assignee || 'Unassigned'))];

  if (members.length === 0) {
    return `
      <div class="tl-resource-panel">
        <div class="tl-resource-empty">No assignees found. Assign tasks to see workload.</div>
      </div>
    `;
  }

  return `
    <div class="tl-resource-panel">
      <div class="tl-resource-header">
        <span class="tl-resource-title">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
            <circle cx="9" cy="7" r="4"/>
          </svg>
          Team Workload
        </span>
        <button class="tl-collapse-btn" onclick="toggleTimelineResources(${projectIndex})">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>
        </button>
      </div>
      <div class="tl-resource-body">
        ${members.slice(0, 5).map(member => {
    const memberTasks = tasks.filter(t => t.assignee === member);
    const workload = Math.min(100, memberTasks.length * 25);
    return `
            <div class="tl-resource-row">
              <div class="tl-member-info">
                <div class="tl-member-avatar" style="background: ${getAvatarColor(member)}">${member.charAt(0).toUpperCase()}</div>
                <span class="tl-member-name">${member}</span>
              </div>
              <div class="tl-workload-bar">
                <div class="tl-workload-fill ${workload > 80 ? 'high' : workload > 50 ? 'medium' : 'low'}" style="width: ${workload}%"></div>
              </div>
              <span class="tl-workload-label">${memberTasks.length} tasks</span>
            </div>
          `;
  }).join('')}
      </div>
    </div>
  `;
}

// Task List (left panel) - ADVANCED Linear.app Style Clone
function renderTaskList(tasks, milestones, projectIndex, criticalPath = []) {
  const criticalSet = new Set(criticalPath);
  const allItems = [
    ...tasks.map(t => ({ ...t, type: 'task' })),
    ...milestones.map(m => ({ ...m, type: 'milestone' }))
  ].filter(item => {
    if (timelineState.showDone) return true;
    return item.status !== 'completed' && item.status !== 'done';
  });

  if (allItems.length === 0) {
    return `
      <div class="tl-empty-list">
        <div class="tl-empty-icon">
          <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="3" y="4" width="18" height="18" rx="2"/>
            <line x1="16" y1="2" x2="16" y2="6"/>
            <line x1="8" y1="2" x2="8" y2="6"/>
            <line x1="3" y1="10" x2="21" y2="10"/>
          </svg>
        </div>
        <p class="tl-empty-title">No tasks scheduled</p>
        <p class="tl-empty-desc">Add tasks with dates to see them on the timeline</p>
      </div>
    `;
  }

  allItems.sort((a, b) => normalizeToLocalMidnight(a.startDate || a.dueDate || 0) - normalizeToLocalMidnight(b.startDate || b.dueDate || 0));

  // Priority colors and icons (no emojis - using colored dots via CSS)
  const priorityConfig = {
    urgent: { color: '#ef4444', icon: '', label: 'Urgent' },
    high: { color: '#f97316', icon: '', label: 'High' },
    medium: { color: '#eab308', icon: '', label: 'Medium' },
    low: { color: '#6b7280', icon: '', label: 'Low' },
    none: { color: '#3f3f46', icon: '', label: '' }
  };

  // Status configuration with Linear-style icons
  const statusConfig = {
    'backlog': { icon: `<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" stroke="#6b7280" stroke-width="1.5" stroke-dasharray="2 2"/></svg>`, color: '#6b7280', label: 'Backlog' },
    'todo': { icon: `<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" stroke="#a1a1aa" stroke-width="1.5"/></svg>`, color: '#a1a1aa', label: 'Todo' },
    'in-progress': { icon: `<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" stroke="#f59e0b" stroke-width="1.5"/><path d="M8 4v4l2.5 2.5" stroke="#f59e0b" stroke-width="1.5" stroke-linecap="round"/></svg>`, color: '#f59e0b', label: 'In Progress' },
    'in_progress': { icon: `<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" stroke="#f59e0b" stroke-width="1.5"/><path d="M8 4v4l2.5 2.5" stroke="#f59e0b" stroke-width="1.5" stroke-linecap="round"/></svg>`, color: '#f59e0b', label: 'In Progress' },
    'review': { icon: `<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" stroke="#8b5cf6" stroke-width="1.5"/><path d="M5 8h6M8 5v6" stroke="#8b5cf6" stroke-width="1.5" stroke-linecap="round"/></svg>`, color: '#8b5cf6', label: 'In Review' },
    'done': { icon: `<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" fill="#10b981"/><path d="M5.5 8l2 2 3.5-3.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`, color: '#10b981', label: 'Done' },
    'completed': { icon: `<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" fill="#10b981"/><path d="M5.5 8l2 2 3.5-3.5" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`, color: '#10b981', label: 'Completed' },
    'cancelled': { icon: `<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" stroke="#6b7280" stroke-width="1.5"/><path d="M5.5 5.5l5 5M10.5 5.5l-5 5" stroke="#6b7280" stroke-width="1.5" stroke-linecap="round"/></svg>`, color: '#6b7280', label: 'Cancelled' },
    'blocked': { icon: `<svg width="14" height="14" viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6" fill="#ef4444"/><rect x="5" y="7" width="6" height="2" fill="white" rx="0.5"/></svg>`, color: '#ef4444', label: 'Blocked' }
  };

  return allItems.map((item, idx) => {
    const statusKey = (item.status || 'todo').toLowerCase().replace(/\s+/g, '-');
    const statusClass = statusKey;
    const isMilestone = item.type === 'milestone';
    const isCritical = criticalSet.has(item.id);
    const isSelected = timelineState.selectedTaskIds.includes(item.id);
    const hasCustomColor = item.color && item.color !== null;
    const priority = item.priority || 'none';
    const priorityData = priorityConfig[priority] || priorityConfig.none;
    const statusData = statusConfig[statusKey] || statusConfig.todo;

    // Format dates for display
    const startDate = item.startDate ? new Date(item.startDate) : null;
    const endDate = item.endDate || item.dueDate ? new Date(item.endDate || item.dueDate) : null;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const isOverdue = endDate && endDate < today && statusClass !== 'done' && statusClass !== 'completed';

    const formatShortDate = (date) => {
      if (!date) return '';
      const d = new Date(date);
      return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    };

    const dateDisplay = startDate && endDate
      ? `${formatShortDate(startDate)} → ${formatShortDate(endDate)}`
      : endDate
        ? formatShortDate(endDate)
        : startDate
          ? formatShortDate(startDate)
          : '';

    // Assignee avatar
    const assigneeAvatar = item.assignee ? `
      <div class="tl-task-assignee" title="${item.assignee}">
        <div class="tl-assignee-avatar" style="background: ${getAvatarColor(item.assignee)}">
          ${item.assignee.charAt(0).toUpperCase()}
        </div>
      </div>
    ` : '';

    // Labels/Tags
    const labels = item.labels || item.tags || [];
    const labelColors = ['#3b82f6', '#8b5cf6', '#ec4899', '#10b981', '#f59e0b', '#ef4444'];
    const labelsHtml = labels.length > 0 ? `
      <div class="tl-task-labels">
        ${labels.slice(0, 2).map((label, i) => `
          <span class="tl-task-label" style="background: ${labelColors[i % labelColors.length]}20; color: ${labelColors[i % labelColors.length]}; border-color: ${labelColors[i % labelColors.length]}40;">
            ${typeof label === 'string' ? label : label.name || label}
          </span>
        `).join('')}
        ${labels.length > 2 ? `<span class="tl-task-label-more">+${labels.length - 2}</span>` : ''}
      </div>
    ` : '';

    // Priority indicator bar
    const priorityBar = priority !== 'none' ? `
      <div class="tl-priority-bar" style="background: ${priorityData.color};" title="${priorityData.label} priority"></div>
    ` : '';

    // Milestone row
    if (isMilestone) {
      return `
        <div class="tl-list-row milestone ${isCritical ? 'critical' : ''} ${isSelected ? 'selected' : ''}" 
             data-id="${item.id}" 
             data-index="${idx}"
             onclick="selectTimelineTask(event, '${item.id}', ${projectIndex})">
          ${priorityBar}
          <div class="tl-row-content">
            <div class="tl-task-main">
              <div class="tl-milestone-icon-wrap">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="#ec4899"><polygon points="12 2 22 12 12 22 2 12"/></svg>
              </div>
              <div class="tl-task-info">
                <span class="tl-task-title">${item.title || item.name}</span>
                <div class="tl-task-meta">
                  <span class="tl-task-type milestone-type">Milestone</span>
                  ${dateDisplay ? `<span class="tl-task-date ${isOverdue ? 'overdue' : ''}">${dateDisplay}</span>` : ''}
                </div>
              </div>
            </div>
            <div class="tl-task-right">
              ${assigneeAvatar}
              ${isCritical ? '<span class="tl-critical-indicator" title="Critical Path">⚡</span>' : ''}
            </div>
          </div>
        </div>
      `;
    }

    // Task row - Advanced Linear.app clone
    return `
      <div class="tl-list-row task ${statusClass} ${isCritical ? 'critical' : ''} ${isSelected ? 'selected' : ''} ${isOverdue ? 'overdue' : ''}" 
           data-id="${item.id}" 
           data-index="${idx}"
           onclick="selectTimelineTask(event, '${item.id}', ${projectIndex})">
        ${priorityBar}
        <div class="tl-row-content">
          <div class="tl-task-main">
            <div class="tl-status-icon-wrap" title="${statusData.label}">
              ${statusData.icon}
            </div>
            <div class="tl-task-info">
              <div class="tl-task-title-row">
                <span class="tl-task-title ${statusClass === 'done' || statusClass === 'completed' ? 'completed' : ''}">${item.title || item.name}</span>
                ${item.identifier || item.id ? `<span class="tl-task-id">${item.identifier || item.id.slice(0, 8)}</span>` : ''}
              </div>
              <div class="tl-task-meta">
                ${dateDisplay ? `
                  <span class="tl-task-date ${isOverdue ? 'overdue' : ''}">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                    ${dateDisplay}
                  </span>
                ` : ''}
                ${labelsHtml}
                ${item.estimate ? `<span class="tl-task-estimate">${item.estimate}h</span>` : ''}
                ${item.dependsOn && item.dependsOn.length > 0 ? `<span class="tl-task-deps" title="${item.dependsOn.length} dependencies"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg></span>` : ''}
              </div>
            </div>
          </div>
          <div class="tl-task-right">
            ${priority !== 'none' ? `
              <div class="tl-priority-icon" style="color: ${priorityData.color};" title="${priorityData.label} priority">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                  <path d="M12 3v14M5 10l7-7 7 7"/>
                </svg>
              </div>
            ` : ''}
            ${assigneeAvatar}
            ${isCritical ? '<span class="tl-critical-indicator" title="Critical Path">⚡</span>' : ''}
          </div>
        </div>
      </div>
    `;
  }).join('');
}

function formatStatus(status) {
  return status.replace(/-|_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

// Gantt Bars (right panel)
function renderGanttBars(tasks, milestones, dates, projectIndex) {
  const allItems = [
    ...tasks.map(t => ({ ...t, type: 'task' })),
    ...milestones.map(m => ({ ...m, type: 'milestone' }))
  ].filter(item => {
    if (timelineState.showDone) return true;
    return item.status !== 'completed' && item.status !== 'done';
  });

  if (allItems.length === 0) return '';

  allItems.sort((a, b) => new Date(a.startDate || a.dueDate || 0) - new Date(b.startDate || b.dueDate || 0));

  const startDate = dates[0];
  const totalDays = dates.length;
  const colWidth = 100 / totalDays;
  const rowHeight = 44;

  return allItems.map((item, idx) => {
    const itemStart = new Date(item.startDate || item.dueDate || new Date());
    const itemEnd = new Date(item.endDate || item.dueDate || itemStart);

    if (!item.endDate && !item.dueDate) {
      itemEnd.setDate(itemEnd.getDate() + 3);
    }

    const startPos = Math.max(0, daysBetween(startDate, itemStart));
    const duration = Math.max(1, daysBetween(itemStart, itemEnd) + 1);
    const left = startPos * colWidth;
    const width = Math.min(duration * colWidth, 100 - left);
    const top = idx * rowHeight + 4;
    const progress = item.progress || 0;
    const statusClass = (item.status || 'todo').toLowerCase().replace(/\s+/g, '-');

    if (item.type === 'milestone') {
      return `
        <div class="tl-bar-row" data-id="${item.id}" style="top: ${top}px">
          <div class="tl-milestone-marker" style="left: ${left}%">
            <div class="tl-diamond">
              <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><polygon points="12 2 22 12 12 22 2 12"/></svg>
            </div>
            <span class="tl-milestone-label">${item.name || item.title}</span>
          </div>
        </div>
      `;
    }

    return `
      <div class="tl-bar-row" data-id="${item.id}" style="top: ${top}px">
        <div class="tl-bar ${statusClass}" 
             style="left: ${left}%; width: ${width}%;"
             data-task-id="${item.id}"
             onclick="openTaskDetailModal(${projectIndex}, '${item.id}')">
          <div class="tl-bar-resize left" data-dir="left"></div>
          <span class="tl-bar-label">${item.title || item.name}</span>
          <div class="tl-bar-resize right" data-dir="right"></div>
        </div>
      </div>
    `;
  }).join('');
}

/**
 * Render today line indicator on the timeline
 * @param {Date[]} dates - Array of dates in the timeline
 * @param {number} [colWidth] - Column width in pixels (optional, uses percentage if not provided)
 * @returns {string} HTML string for the today indicator
 */
function renderTodayLine(dates, colWidth) {
  const todayIdx = dates.findIndex(d => isToday(d));
  if (todayIdx === -1) return '';

  // Support both percentage (when colWidth not provided) and pixel positioning
  const leftPos = colWidth
    ? (todayIdx * colWidth) + (colWidth / 2)
    : (todayIdx * (100 / dates.length)) + ((100 / dates.length) / 2);
  const unit = colWidth ? 'px' : '%';

  return `
    <div class="tl-today-indicator" style="left: ${leftPos}${unit}">
      <div class="tl-today-badge">Today</div>
      <div class="tl-today-line"></div>
    </div>
  `;
}

// Enhanced Gantt Bars - ADVANCED Linear.app Clone with task labels and full details
function renderEnhancedGanttBars(tasks, milestones, dates, projectIndex, colWidth, criticalPath) {
  const allItems = [
    ...tasks.map(t => ({ ...t, type: 'task' })),
    ...milestones.map(m => ({ ...m, type: 'milestone' }))
  ].filter(item => {
    if (timelineState.showDone) return true;
    return item.status !== 'completed' && item.status !== 'done';
  });

  if (allItems.length === 0) return '';

  allItems.sort((a, b) => new Date(a.startDate || a.dueDate || 0) - new Date(b.startDate || b.dueDate || 0));

  const startDate = normalizeToLocalMidnight(dates[0]);
  const rowHeight = 72; // Taller rows for Linear-style swimlanes
  const criticalSet = new Set(criticalPath);
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Status colors for bars
  const statusColors = {
    'backlog': { bg: '#27272a', border: '#3f3f46', text: '#a1a1aa' },
    'todo': { bg: '#3f3f46', border: '#52525b', text: '#d4d4d8' },
    'in-progress': { bg: '#0369a1', border: '#0284c7', text: '#ffffff' },
    'in_progress': { bg: '#0369a1', border: '#0284c7', text: '#ffffff' },
    'review': { bg: '#6d28d9', border: '#7c3aed', text: '#ffffff' },
    'done': { bg: '#059669', border: '#10b981', text: '#ffffff' },
    'completed': { bg: '#059669', border: '#10b981', text: '#ffffff' },
    'blocked': { bg: '#b91c1c', border: '#dc2626', text: '#ffffff' },
    'cancelled': { bg: '#3f3f46', border: '#52525b', text: '#71717a' }
  };

  // Priority colors
  const priorityColors = {
    urgent: '#ef4444',
    high: '#f97316',
    medium: '#eab308',
    low: '#6b7280'
  };

  return allItems.map((item, idx) => {
    const itemStart = normalizeToLocalMidnight(item.startDate || item.dueDate || new Date());
    let itemEnd = normalizeToLocalMidnight(item.endDate || item.dueDate || itemStart);

    if (!item.endDate && !item.dueDate) {
      itemEnd = new Date(itemStart);
      itemEnd.setDate(itemEnd.getDate() + 7); // Default 7 days duration
    }

    const startPos = Math.max(0, daysBetween(startDate, itemStart));
    const duration = Math.max(1, daysBetween(itemStart, itemEnd) + 1);
    const left = startPos * colWidth;
    const minBarWidth = 80; // Minimum width to show label
    const width = Math.max(minBarWidth, duration * colWidth - 4);
    const top = idx * rowHeight + 16;
    const progress = item.progress || 0;
    const statusKey = (item.status || 'todo').toLowerCase().replace(/\s+/g, '-');
    const statusClass = statusKey;
    const isCritical = criticalSet.has(item.id);
    const isSelected = timelineState.selectedTaskIds.includes(item.id);
    const priority = item.priority || 'none';
    const statusColor = statusColors[statusKey] || statusColors.todo;

    // Check if overdue
    const isOverdue = itemEnd < today && statusClass !== 'done' && statusClass !== 'completed';

    // Custom color support
    const hasCustomColor = item.color && item.color !== null;
    const barBgColor = hasCustomColor ? item.color : statusColor.bg;
    const barBorderColor = hasCustomColor ? item.color : statusColor.border;

    // Truncate label for display
    const taskTitle = item.title || item.name || '';
    const maxLabelChars = Math.floor(width / 8); // Approximate chars that fit
    const displayLabel = taskTitle.length > maxLabelChars ? taskTitle.slice(0, maxLabelChars - 2) + '…' : taskTitle;

    // Calculate days remaining or overdue
    const daysFromNow = daysBetween(today, itemEnd);
    const daysText = isOverdue
      ? `${Math.abs(daysFromNow)}d overdue`
      : daysFromNow === 0
        ? 'Due today'
        : daysFromNow === 1
          ? 'Due tomorrow'
          : `${daysFromNow}d left`;

    // Format date range for tooltip
    const formatDate = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const dateRange = `${formatDate(itemStart)} - ${formatDate(itemEnd)}`;

    // Assignee initial
    const assigneeInitial = item.assignee ? item.assignee.charAt(0).toUpperCase() : '';
    const assigneeColor = item.assignee ? getAvatarColor(item.assignee) : '#52525b';

    if (item.type === 'milestone') {
      // Enhanced milestone marker with more details
      return `
        <div class="tl-bar-row" data-id="${item.id}" style="top: ${top}px; height: ${rowHeight}px;">
          <div class="tl-milestone-marker enhanced ${isCritical ? 'critical' : ''} ${isSelected ? 'selected' : ''}" 
               style="left: ${left + colWidth / 2}px;"
               data-task-id="${item.id}"
               title="${taskTitle} - ${formatDate(itemEnd)}"
               draggable="true"
               onmousedown="startMilestoneDrag(event, '${item.id}', ${projectIndex})"
               onclick="selectTimelineTask(event, '${item.id}', ${projectIndex})">
            <div class="tl-diamond-wrap">
              <div class="tl-diamond ${isCritical ? 'critical' : ''}"></div>
            </div>
            <div class="tl-milestone-details">
              <span class="tl-milestone-title">${taskTitle}</span>
              <span class="tl-milestone-date">${formatDate(itemEnd)}</span>
            </div>
          </div>
        </div>
      `;
    }

    // Generate milestones for this task (if any are defined within the task's date range)
    const taskMilestones = (item.milestones || []).map((ms, msIdx) => {
      const msDate = normalizeToLocalMidnight(ms.date || itemEnd);
      const msDays = daysBetween(startDate, msDate);
      const msLeft = msDays * colWidth + colWidth / 2;
      return `
        <div class="tl-inline-milestone" style="left: ${msLeft}px;">
          <div class="tl-mini-diamond"></div>
        </div>
      `;
    }).join('');

    // Advanced task bar with label, assignee, and indicators
    return `
      <div class="tl-bar-row" data-id="${item.id}" style="top: ${top}px; height: ${rowHeight}px;">
        <div class="tl-bar-wrapper ${statusClass} ${isCritical ? 'critical-path' : ''} ${isSelected ? 'selected' : ''} ${isOverdue ? 'overdue' : ''}"
             style="left: ${left}px; width: ${width}px;"
             title="${taskTitle}&#10;${dateRange}&#10;${daysText}"
             data-task-id="${item.id}"
             data-start-date="${item.startDate || ''}"
             data-end-date="${item.endDate || ''}"
             onclick="selectTimelineTask(event, '${item.id}', ${projectIndex})"
             ondblclick="editTimelineTask(${projectIndex}, '${item.id}')">
          
          <!-- Hover Quick Actions -->
          <div class="tl-bar-quick-actions">
            <button class="tl-bar-quick-btn tl-bar-complete-btn" 
                    onclick="event.stopPropagation(); toggleTimelineTaskComplete('${item.id}', ${projectIndex})"
                    title="Mark ${statusClass === 'done' || statusClass === 'completed' ? 'incomplete' : 'complete'}">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <polyline points="20 6 9 17 4 12"/>
              </svg>
            </button>
            <button class="tl-bar-quick-btn tl-bar-edit-btn" 
                    onclick="event.stopPropagation(); openQuickEditTaskModal('${item.id}', ${projectIndex})"
                    title="Edit task">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
              </svg>
            </button>
          </div>
          
          <!-- Priority indicator line -->
          ${priority !== 'none' && priorityColors[priority] ? `
            <div class="tl-bar-priority-line" style="background: ${priorityColors[priority]};"></div>
          ` : ''}
          
          <!-- Task label outside the bar -->
          <span class="tl-bar-label" style="color: ${statusColor.text};">${displayLabel}</span>
          
          <!-- Main bar body -->
          <div class="tl-bar-body" style="background: ${barBgColor}; border-color: ${barBorderColor};">
            <!-- Resize handle left -->
            <div class="tl-bar-resize left" data-dir="left"></div>
            
            <!-- Progress indicator -->
            ${progress > 0 ? `<div class="tl-bar-progress-fill" style="width: ${progress}%;"></div>` : ''}
            
            <!-- Bar content -->
            <div class="tl-bar-content">
              <!-- Right side indicators -->
              <div class="tl-bar-indicators">
                ${item.dependsOn && item.dependsOn.length > 0 ? `
                  <span class="tl-bar-dep-icon" title="${item.dependsOn.length} dependencies">
                    <svg width="10" height="10" viewBox="0 0 24 24" fill="currentColor"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6M15 3h6v6M10 14L21 3"/></svg>
                  </span>
                ` : ''}
                ${isCritical ? `
                  <span class="tl-bar-critical-icon" title="Critical path">⚡</span>
                ` : ''}
                ${assigneeInitial ? `
                  <span class="tl-bar-assignee" style="background: ${assigneeColor};" title="${item.assignee}">${assigneeInitial}</span>
                ` : ''}
              </div>
            </div>
            
            <!-- Resize handle right -->
            <div class="tl-bar-resize right" data-dir="right"></div>
          </div>
          
          <!-- Overdue indicator -->
          ${isOverdue ? `<div class="tl-bar-overdue-indicator" title="${daysText}"></div>` : ''}
        </div>
        ${taskMilestones}
      </div>
    `;
  }).join('');
}

// Month Headers
function generateMonthHeaders(dates) {
  const months = [];
  let currentMonth = null;
  let startIdx = 0;

  dates.forEach((date, idx) => {
    const monthKey = `${date.getFullYear()}-${date.getMonth()}`;
    if (monthKey !== currentMonth) {
      if (currentMonth !== null) {
        months.push({
          name: dates[startIdx].toLocaleDateString('en-US', { month: 'short' }),
          span: idx - startIdx,
          year: dates[startIdx].getFullYear()
        });
      }
      currentMonth = monthKey;
      startIdx = idx;
    }
    if (idx === dates.length - 1) {
      months.push({
        name: date.toLocaleDateString('en-US', { month: 'short' }),
        span: idx - startIdx + 1,
        year: date.getFullYear()
      });
    }
  });

  return months.map(m => `
    <div class="tl-month-cell" style="flex: ${m.span}">
      ${m.name} ${m.year}
    </div>
  `).join('');
}

// Utility Functions
function getAvatarColor(name) {
  const colors = ['#f97316', '#8b5cf6', '#10b981', '#ec4899', '#3b82f6', '#14b8a6'];
  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  return colors[Math.abs(hash) % colors.length];
}

function getTimelineDateRange() {
  const current = new Date(timelineState.currentDate);
  let start, end;

  switch (timelineState.viewMode) {
    case 'day':
      start = new Date(current);
      start.setDate(start.getDate() - 3);
      end = new Date(current);
      end.setDate(end.getDate() + 10);
      break;
    case 'week':
      start = new Date(current);
      start.setDate(start.getDate() - (start.getDay() || 7) + 1 - 7);
      end = new Date(start);
      end.setDate(end.getDate() + 21);
      break;
    case 'month':
      start = new Date(current.getFullYear(), current.getMonth() - 1, 1);
      end = new Date(current.getFullYear(), current.getMonth() + 2, 0);
      break;
    case 'quarter':
      const quarterStart = Math.floor(current.getMonth() / 3) * 3;
      start = new Date(current.getFullYear(), quarterStart, 1);
      end = new Date(current.getFullYear(), quarterStart + 3, 0);
      break;
    default:
      start = new Date(current);
      start.setDate(start.getDate() - 7);
      end = new Date(current);
      end.setDate(end.getDate() + 14);
  }

  return { start, end };
}

function generateDateColumns(start, end) {
  const dates = [];
  const current = new Date(start);
  while (current <= end) {
    dates.push(new Date(current));
    current.setDate(current.getDate() + 1);
  }
  return dates;
}

function getDayLetter(date) {
  return date.toLocaleDateString('en-US', { weekday: 'short' }).charAt(0);
}

function isToday(date) {
  const today = new Date();
  return date.toDateString() === today.toDateString();
}

function isWeekend(date) {
  return date.getDay() === 0 || date.getDay() === 6;
}

function formatDateRange(start, end) {
  const startStr = start.toLocaleDateString('en-US', { day: 'numeric', month: 'short' });
  const endStr = end.toLocaleDateString('en-US', { day: 'numeric', month: 'short' });
  return `${startStr} – ${endStr}`;
}

function daysBetween(date1, date2) {
  // Normalize dates to avoid timezone issues
  const d1 = normalizeToLocalMidnight(date1);
  const d2 = normalizeToLocalMidnight(date2);
  return Math.round((d2 - d1) / (1000 * 60 * 60 * 24));
}

// Helper to normalize dates properly avoiding timezone issues
function normalizeToLocalMidnight(dateInput) {
  if (!dateInput) return new Date();

  let date;
  if (typeof dateInput === 'string') {
    // Parse date string as local date (not UTC)
    const parts = dateInput.split('T')[0].split('-');
    if (parts.length === 3) {
      date = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    } else {
      date = new Date(dateInput);
    }
  } else {
    date = new Date(dateInput);
  }

  date.setHours(0, 0, 0, 0);
  return date;
}

// Global drag state to persist across re-renders
let _tlDragState = {
  draggedBar: null,
  dragStartX: 0,
  originalLeft: 0,
  originalWidth: 0,
  resizeDir: null,
  projectIndex: null,
  dates: [],
  colWidth: 40
};

// Cleanup previous listeners
function cleanupTimelineListeners() {
  if (window._tlMouseMoveHandler) {
    document.removeEventListener('mousemove', window._tlMouseMoveHandler);
  }
  if (window._tlMouseUpHandler) {
    document.removeEventListener('mouseup', window._tlMouseUpHandler);
  }
}

// Enhanced Interactions with zoom, pan, and keyboard
function initEnhancedTimelineInteractions(projectIndex, dates, colWidth) {
  const chartBody = document.getElementById('tlChartBody');
  const rightPanel = document.getElementById('tlRightPanel');
  const ganttWrap = document.getElementById('tlGanttWrap');

  if (!chartBody) return;

  // Store current context in global state
  _tlDragState.projectIndex = projectIndex;
  _tlDragState.dates = dates;
  _tlDragState.colWidth = colWidth;

  // Cleanup old listeners first
  cleanupTimelineListeners();

  // Bar dragging with snap-to-grid
  chartBody.onmousedown = function (e) {
    const bar = e.target.closest('.tl-bar');
    if (!bar) return;

    const resize = e.target.closest('.tl-bar-resize');
    if (resize) {
      _tlDragState.resizeDir = resize.dataset.dir;
      timelineState.isResizing = true;
    } else {
      timelineState.isDragging = true;
    }

    _tlDragState.draggedBar = bar;
    _tlDragState.dragStartX = e.clientX;
    _tlDragState.originalLeft = parseFloat(bar.style.left) || 0;
    _tlDragState.originalWidth = parseFloat(bar.style.width) || colWidth;
    bar.classList.add('dragging');
    e.preventDefault();
    e.stopPropagation();
  };

  // Global mousemove handler
  window._tlMouseMoveHandler = function (e) {
    if (!_tlDragState.draggedBar) return;

    const deltaX = e.clientX - _tlDragState.dragStartX;
    const cw = _tlDragState.colWidth;

    // Snap to grid (column width)
    const snappedDelta = Math.round(deltaX / cw) * cw;

    if (timelineState.isResizing) {
      if (_tlDragState.resizeDir === 'right') {
        const newWidth = Math.max(cw, _tlDragState.originalWidth + snappedDelta);
        _tlDragState.draggedBar.style.width = `${newWidth}px`;
      } else {
        const newLeft = Math.max(0, _tlDragState.originalLeft + snappedDelta);
        _tlDragState.draggedBar.style.left = `${newLeft}px`;
        _tlDragState.draggedBar.style.width = `${Math.max(cw, _tlDragState.originalWidth - snappedDelta)}px`;
      }
    } else {
      const maxLeft = _tlDragState.dates.length * cw - _tlDragState.originalWidth;
      _tlDragState.draggedBar.style.left = `${Math.max(0, Math.min(maxLeft, _tlDragState.originalLeft + snappedDelta))}px`;
    }

    // Show snap indicator
    updateSnapIndicator(_tlDragState.draggedBar, _tlDragState.dates, cw);
  };

  // Global mouseup handler
  window._tlMouseUpHandler = function () {
    if (_tlDragState.draggedBar) {
      _tlDragState.draggedBar.classList.remove('dragging');
      removeSnapIndicator();

      if (timelineState.isDragging || timelineState.isResizing) {
        const taskId = _tlDragState.draggedBar.dataset.taskId;
        const newLeft = parseFloat(_tlDragState.draggedBar.style.left) || 0;
        const newWidth = parseFloat(_tlDragState.draggedBar.style.width) || _tlDragState.colWidth;

        // Save dates before clearing state
        const savedDates = _tlDragState.dates;
        const savedColWidth = _tlDragState.colWidth;
        const savedProjectIndex = _tlDragState.projectIndex;

        // Clear state first to prevent re-renders from triggering
        _tlDragState.draggedBar = null;
        timelineState.isDragging = false;
        timelineState.isResizing = false;
        _tlDragState.resizeDir = null;

        // Then update the task
        updateTaskDatesPixel(savedProjectIndex, taskId, savedDates, newLeft, newWidth, savedColWidth);
        return;
      }

      _tlDragState.draggedBar = null;
      timelineState.isDragging = false;
      timelineState.isResizing = false;
      _tlDragState.resizeDir = null;
    }
  };

  document.addEventListener('mousemove', window._tlMouseMoveHandler);
  document.addEventListener('mouseup', window._tlMouseUpHandler);

  // Mouse wheel zoom
  if (rightPanel) {
    rightPanel.onwheel = function (e) {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        zoomTimeline(delta, projectIndex);
      }
    };
  }

  // Touch pinch zoom
  let lastTouchDistance = 0;
  if (rightPanel) {
    rightPanel.ontouchstart = function (e) {
      if (e.touches.length === 2) {
        lastTouchDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
      }
    };

    rightPanel.ontouchmove = function (e) {
      if (e.touches.length === 2) {
        const distance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        if (lastTouchDistance > 0) {
          const delta = (distance - lastTouchDistance) * 0.005;
          zoomTimeline(delta, projectIndex);
        }
        lastTouchDistance = distance;
      }
    };

    rightPanel.ontouchend = function () {
      lastTouchDistance = 0;
    };
  }
}

// Snap indicator for visual feedback
function updateSnapIndicator(bar, dates, colWidth) {
  let indicator = document.getElementById('tlSnapIndicator');
  if (!indicator) {
    indicator = document.createElement('div');
    indicator.id = 'tlSnapIndicator';
    indicator.className = 'tl-snap-indicator';
    document.getElementById('tlChartBody')?.appendChild(indicator);
  }

  const left = parseFloat(bar.style.left);
  const dayIdx = Math.round(left / colWidth);

  if (dates[dayIdx]) {
    indicator.textContent = dates[dayIdx].toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric'
    });
    indicator.style.left = `${left}px`;
    indicator.style.top = `${parseFloat(bar.closest('.tl-bar-row').style.top) - 24}px`;
    indicator.style.display = 'block';
  }
}

function removeSnapIndicator() {
  const indicator = document.getElementById('tlSnapIndicator');
  if (indicator) indicator.style.display = 'none';
}

// Keyboard shortcuts
function initTimelineKeyboardShortcuts(projectIndex) {
  // Remove existing listener to avoid duplicates
  document.removeEventListener('keydown', handleTimelineKeydown);

  // Store project index for the handler
  window._timelineProjectIndex = projectIndex;

  document.addEventListener('keydown', handleTimelineKeydown);
}

function handleTimelineKeydown(e) {
  // Don't handle if in input/textarea
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
    return;
  }

  // Check if we're in timeline view
  const timelineEl = document.querySelector('.timeline-linear');
  if (!timelineEl) return;

  const projectIndex = window._timelineProjectIndex ?? timelineState.lastProjectIndex;
  if (projectIndex === null || projectIndex === undefined) return;

  switch (e.key) {
    case 'ArrowLeft':
      e.preventDefault();
      navigateTimeline(-1, projectIndex);
      break;
    case 'ArrowRight':
      e.preventDefault();
      navigateTimeline(1, projectIndex);
      break;
    case 't':
    case 'T':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        navigateTimelineToday(projectIndex);
      }
      break;
    case 'd':
    case 'D':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        setTimelineViewMode('day', projectIndex);
      }
      break;
    case 'w':
    case 'W':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        setTimelineViewMode('week', projectIndex);
      }
      break;
    case 'm':
    case 'M':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        setTimelineViewMode('month', projectIndex);
      }
      break;
    case 'q':
    case 'Q':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        setTimelineViewMode('quarter', projectIndex);
      }
      break;
    case 'c':
    case 'C':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        toggleCriticalPath(projectIndex);
      }
      break;
    case 'r':
    case 'R':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        toggleTimelineResources(projectIndex);
      }
      break;
    case '+':
    case '=':
      e.preventDefault();
      zoomTimeline(0.1, projectIndex);
      break;
    case '-':
    case '_':
      e.preventDefault();
      zoomTimeline(-0.1, projectIndex);
      break;
    case '0':
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        resetTimelineZoom(projectIndex);
      }
      break;
    case '?':
      e.preventDefault();
      showTimelineKeyboardShortcuts();
      break;
    case 'Escape':
      timelineState.selectedTaskIds = [];
      const container = document.querySelector('.pd-content-scroll');
      if (container) renderTimelineView(projectIndex, container);
      break;
    case 'Delete':
    case 'Backspace':
      if (timelineState.selectedTaskIds.length > 0) {
        e.preventDefault();
        deleteSelectedTimelineTasks(projectIndex);
      }
      break;
  }
}

// Zoom presets for timeline
const TIMELINE_ZOOM_PRESETS = [0.15, 0.25, 0.5, 0.75, 1, 1.5, 2];

// Get zoom label for display
function getZoomLabel(zoom) {
  if (zoom <= 0.15) return '6 Months';
  if (zoom <= 0.25) return '3 Months';
  if (zoom <= 0.5) return '6 Weeks';
  if (zoom <= 0.75) return '1 Month';
  if (zoom <= 1) return '2 Weeks';
  if (zoom <= 1.5) return '1 Week';
  return 'Days';
}

// Smart zoom that snaps to presets
function zoomTimelineSmart(direction, projectIndex) {
  const currentIdx = TIMELINE_ZOOM_PRESETS.findIndex(z => z >= timelineState.zoom);
  let newIdx;

  if (direction > 0) {
    // Zoom in
    newIdx = Math.min(TIMELINE_ZOOM_PRESETS.length - 1, currentIdx + 1);
  } else {
    // Zoom out
    newIdx = Math.max(0, currentIdx - 1);
  }

  const newZoom = TIMELINE_ZOOM_PRESETS[newIdx];
  if (newZoom !== timelineState.zoom) {
    timelineState.zoom = newZoom;
    const container = document.querySelector('.pd-content-scroll');
    if (container) renderTimelineView(projectIndex, container);
  }
}

// Set specific zoom level
function setTimelineZoom(zoom, projectIndex) {
  timelineState.zoom = zoom;
  closeZoomDropdown();
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

// Toggle zoom dropdown
function toggleZoomDropdown(event) {
  event.stopPropagation();
  const dropdown = document.getElementById('tlZoomDropdown');
  if (dropdown) {
    dropdown.classList.toggle('show');

    // Close on outside click
    if (dropdown.classList.contains('show')) {
      setTimeout(() => {
        document.addEventListener('click', closeZoomDropdown, { once: true });
      }, 10);
    }
  }
}

function closeZoomDropdown() {
  const dropdown = document.getElementById('tlZoomDropdown');
  if (dropdown) dropdown.classList.remove('show');
}

// Zoom functions - Extended range for 6-month view
// Zoom levels: 0.15 (~6 months), 0.25 (~3 months), 0.5 (~6 weeks), 1 (default), 2 (detailed)
function zoomTimeline(delta, projectIndex) {
  const newZoom = Math.max(0.15, Math.min(2, timelineState.zoom + delta));
  if (newZoom !== timelineState.zoom) {
    timelineState.zoom = newZoom;
    const container = document.querySelector('.pd-content-scroll');
    if (container) renderTimelineView(projectIndex, container);
  }
}

function resetTimelineZoom(projectIndex) {
  timelineState.zoom = 1;
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

// Critical path toggle
function toggleCriticalPath(projectIndex) {
  timelineState.showCriticalPath = !timelineState.showCriticalPath;
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
  showToast(timelineState.showCriticalPath ? 'Critical path highlighted' : 'Critical path hidden');
}

// Task selection
function selectTimelineTask(event, taskId, projectIndex) {
  event.stopPropagation();

  if (event.ctrlKey || event.metaKey) {
    // Multi-select
    const idx = timelineState.selectedTaskIds.indexOf(taskId);
    if (idx > -1) {
      timelineState.selectedTaskIds.splice(idx, 1);
    } else {
      timelineState.selectedTaskIds.push(taskId);
    }
  } else if (event.shiftKey && timelineState.selectedTaskIds.length > 0) {
    // Range select - simplified, just add to selection
    timelineState.selectedTaskIds.push(taskId);
  } else {
    // Single select
    timelineState.selectedTaskIds = [taskId];
  }

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

// Delete selected tasks
function deleteSelectedTimelineTasks(projectIndex) {
  if (timelineState.selectedTaskIds.length === 0) return;

  if (!confirm(`Delete ${timelineState.selectedTaskIds.length} selected task(s)?`)) return;

  const projects = loadProjects();
  const project = projects[projectIndex];

  if (project.tasks) {
    project.tasks = project.tasks.filter(t => !timelineState.selectedTaskIds.includes(t.id));
  }
  if (project.milestones) {
    project.milestones = project.milestones.filter(m => !timelineState.selectedTaskIds.includes(m.id));
  }

  saveProjects(projects);
  timelineState.selectedTaskIds = [];

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
  showToast('Tasks deleted');
}

// Milestone dragging
function startMilestoneDrag(event, milestoneId, projectIndex) {
  event.preventDefault();
  const marker = event.currentTarget;
  const chartBody = document.getElementById('tlChartBody');
  if (!chartBody) return;

  const startX = event.clientX;
  const originalLeft = parseFloat(marker.style.left);

  marker.classList.add('dragging');

  function onMove(e) {
    const deltaX = e.clientX - startX;
    const colWidth = parseInt(getComputedStyle(document.getElementById('tlGanttWrap')).getPropertyValue('--col-width'));
    const snappedDelta = Math.round(deltaX / colWidth) * colWidth;
    marker.style.left = `${Math.max(0, originalLeft + snappedDelta)}px`;
  }

  function onUp(e) {
    marker.classList.remove('dragging');
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('mouseup', onUp);

    const colWidth = parseInt(getComputedStyle(document.getElementById('tlGanttWrap')).getPropertyValue('--col-width'));
    const newLeft = parseFloat(marker.style.left);

    // Update milestone date
    updateMilestoneDate(projectIndex, milestoneId, newLeft, colWidth);
  }

  document.addEventListener('mousemove', onMove);
  document.addEventListener('mouseup', onUp);
}

function updateMilestoneDate(projectIndex, milestoneId, leftPx, colWidth) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project || !project.milestones) return;

  const milestone = project.milestones.find(m => m.id === milestoneId);
  if (!milestone) return;

  const dateRange = getTimelineDateRange();
  const dates = generateDateColumns(dateRange.start, dateRange.end);
  // Clamp dayIdx to valid range
  const dayIdx = Math.max(0, Math.min(dates.length - 1, Math.round(leftPx / colWidth)));

  if (dates[dayIdx]) {
    milestone.dueDate = formatLocalDate(dates[dayIdx]);
    saveProjects(projects);
    showToast('Milestone moved');

    const container = document.querySelector('.pd-content-scroll');
    if (container) renderTimelineView(projectIndex, container);
  }
}

// Update task dates using pixel values
function updateTaskDatesPixel(projectIndex, taskId, dates, leftPx, widthPx, colWidth) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  const task = project.tasks?.find(t => t.id === taskId);
  if (!task) return;

  // Clamp startIdx to valid range
  const startIdx = Math.max(0, Math.min(dates.length - 1, Math.round(leftPx / colWidth)));
  const duration = Math.max(1, Math.round(widthPx / colWidth));

  if (dates[startIdx]) {
    // Use local date formatting to avoid timezone issues
    const startDate = dates[startIdx];
    task.startDate = formatLocalDate(startDate);

    // Calculate end date correctly
    const endIdx = Math.min(dates.length - 1, startIdx + duration - 1);
    if (dates[endIdx]) {
      task.endDate = formatLocalDate(dates[endIdx]);
    } else {
      // Fallback: calculate end date from start
      const endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + Math.max(0, duration - 1));
      task.endDate = formatLocalDate(endDate);
    }

    saveProjects(projects);
    showToast('Task updated');

    // Re-render to sync
    const container = document.querySelector('.pd-content-scroll');
    if (container) renderTimelineView(projectIndex, container);
  }
}

// Helper to format date as YYYY-MM-DD without timezone issues
function formatLocalDate(date) {
  const d = new Date(date);
  const year = d.getFullYear();
  const month = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

// Show keyboard shortcuts modal
function showTimelineKeyboardShortcuts() {
  const content = `
    <div class="tl-shortcuts-modal">
      <div class="shortcuts-grid">
        <div class="shortcut-section">
          <h4>Navigation</h4>
          <div class="shortcut-row"><kbd>←</kbd> <span>Previous period</span></div>
          <div class="shortcut-row"><kbd>→</kbd> <span>Next period</span></div>
          <div class="shortcut-row"><kbd>T</kbd> <span>Jump to today</span></div>
        </div>
        <div class="shortcut-section">
          <h4>View Modes</h4>
          <div class="shortcut-row"><kbd>D</kbd> <span>Day view</span></div>
          <div class="shortcut-row"><kbd>W</kbd> <span>Week view</span></div>
          <div class="shortcut-row"><kbd>M</kbd> <span>Month view</span></div>
          <div class="shortcut-row"><kbd>Q</kbd> <span>Quarter view</span></div>
        </div>
        <div class="shortcut-section">
          <h4>Zoom</h4>
          <div class="shortcut-row"><kbd>+</kbd> <span>Zoom in</span></div>
          <div class="shortcut-row"><kbd>-</kbd> <span>Zoom out</span></div>
          <div class="shortcut-row"><kbd>0</kbd> <span>Reset zoom</span></div>
          <div class="shortcut-row"><kbd>Ctrl</kbd>+<kbd>Scroll</kbd> <span>Mouse zoom</span></div>
        </div>
        <div class="shortcut-section">
          <h4>Display</h4>
          <div class="shortcut-row"><kbd>C</kbd> <span>Toggle critical path</span></div>
          <div class="shortcut-row"><kbd>R</kbd> <span>Toggle resources</span></div>
        </div>
        <div class="shortcut-section">
          <h4>Selection</h4>
          <div class="shortcut-row"><kbd>Click</kbd> <span>Select task</span></div>
          <div class="shortcut-row"><kbd>Ctrl</kbd>+<kbd>Click</kbd> <span>Multi-select</span></div>
          <div class="shortcut-row"><kbd>Esc</kbd> <span>Clear selection</span></div>
          <div class="shortcut-row"><kbd>Del</kbd> <span>Delete selected</span></div>
        </div>
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-primary" onclick="closeModal()">Got it</button>
      </div>
    </div>
  `;

  openModal('Keyboard Shortcuts', content, 'modal-medium');
}

// Sync scroll between task list panel and Gantt chart panel
const listBody = document.getElementById('tlListBody');
const chartBody = document.getElementById('tlChartBody');
const rightPanel = document.getElementById('tlRightPanel');

if (listBody && chartBody) {
  // Sync vertical scroll between list and chart
  listBody.addEventListener('scroll', () => {
    chartBody.scrollTop = listBody.scrollTop;
    timelineState.scrollTop = listBody.scrollTop;
  });
  chartBody.addEventListener('scroll', () => {
    listBody.scrollTop = chartBody.scrollTop;
    timelineState.scrollTop = chartBody.scrollTop;
    timelineState.scrollLeft = chartBody.scrollLeft;
  });

  // Restore saved scroll position
  if (timelineState.scrollTop > 0 || timelineState.scrollLeft > 0) {
    setTimeout(() => {
      listBody.scrollTop = timelineState.scrollTop;
      chartBody.scrollTop = timelineState.scrollTop;
      chartBody.scrollLeft = timelineState.scrollLeft;
    }, 50);
  }
}


// Helper to adjust color brightness for gradients
function adjustColorBrightness(hex, percent) {
  if (!hex) return '#8b5cf6';

  // Remove # if present
  hex = hex.replace('#', '');

  // Parse hex
  let r = parseInt(hex.substring(0, 2), 16);
  let g = parseInt(hex.substring(2, 4), 16);
  let b = parseInt(hex.substring(4, 6), 16);

  // Adjust brightness
  r = Math.min(255, Math.max(0, r + (r * percent / 100)));
  g = Math.min(255, Math.max(0, g + (g * percent / 100)));
  b = Math.min(255, Math.max(0, b + (b * percent / 100)));

  // Convert back to hex
  return `#${Math.round(r).toString(16).padStart(2, '0')}${Math.round(g).toString(16).padStart(2, '0')}${Math.round(b).toString(16).padStart(2, '0')}`;
}

function updateTaskDates(projectIndex, taskId, dates, leftPct, widthPct, colWidth) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  const task = project.tasks?.find(t => t.id === taskId);
  if (!task) return;

  const startIdx = Math.round(leftPct / colWidth);
  const duration = Math.round(widthPct / colWidth);

  if (dates[startIdx]) {
    task.startDate = dates[startIdx].toISOString().split('T')[0];
    const endDate = new Date(dates[startIdx]);
    endDate.setDate(endDate.getDate() + duration - 1);
    task.endDate = endDate.toISOString().split('T')[0];
    saveProjects(projects);
    showToast('Task updated');
  }
}

// Navigation & Toggle Functions
function setTimelineViewMode(mode, projectIndex) {
  timelineState.viewMode = mode;
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

function navigateTimeline(direction, projectIndex) {
  const days = { day: 7, week: 14, month: 30, quarter: 90 }[timelineState.viewMode] || 14;
  timelineState.currentDate.setDate(timelineState.currentDate.getDate() + (direction * days));
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

function navigateTimelineToday(projectIndex) {
  timelineState.currentDate = new Date();
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

function toggleTimelineResources(projectIndex) {
  timelineState.showResources = !timelineState.showResources;
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

// toggleDependencies removed - feature cleaned

function toggleShowDone(projectIndex) {
  timelineState.showDone = !timelineState.showDone;
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
}

function openTimelineSettings(projectIndex) {
  const content = `
    <div class="tl-settings-form">
      <div class="form-group">
        <label class="form-label">Default View</label>
        <select class="form-input" id="settingsDefaultView">
          <option value="day" ${timelineState.viewMode === 'day' ? 'selected' : ''}>Day</option>
          <option value="week" ${timelineState.viewMode === 'week' ? 'selected' : ''}>Week</option>
          <option value="month" ${timelineState.viewMode === 'month' ? 'selected' : ''}>Month</option>
          <option value="quarter" ${timelineState.viewMode === 'quarter' ? 'selected' : ''}>Quarter</option>
        </select>
      </div>
      <div class="form-group">
        <label class="tl-checkbox-label">
          <input type="checkbox" id="settingsShowResources" ${timelineState.showResources ? 'checked' : ''}>
          Show Resource Workload
        </label>
      </div>
      <div class="form-group">
        <label class="tl-checkbox-label">
          <input type="checkbox" id="settingsShowDependencies" ${timelineState.showDependencies ? 'checked' : ''}>
          Show Dependencies
        </label>
      </div>
      <div class="form-group">
        <label class="tl-checkbox-label">
          <input type="checkbox" id="settingsShowDone" ${timelineState.showDone ? 'checked' : ''}>
          Show Completed Tasks
        </label>
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="saveTimelineSettings(${projectIndex})">Save Settings</button>
      </div>
    </div>
  `;

  openModal('Timeline Settings', content);
}

function saveTimelineSettings(projectIndex) {
  timelineState.viewMode = document.getElementById('settingsDefaultView').value;
  timelineState.showResources = document.getElementById('settingsShowResources').checked;
  timelineState.showDependencies = document.getElementById('settingsShowDependencies').checked;
  timelineState.showDone = document.getElementById('settingsShowDone').checked;

  closeModal();
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineView(projectIndex, container);
  showToast('Settings saved');
}

function openAddTimelineTaskModal(projectIndex) {
  const today = new Date().toISOString().split('T')[0];
  const nextWeek = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

  const colorOptions = TIMELINE_TASK_COLORS.map(c =>
    `<button type="button" class="tl-color-swatch ${c.value === null ? 'default' : ''}" 
             data-color="${c.value || ''}" 
             style="${c.value ? `background: ${c.value};` : 'background: linear-gradient(135deg, #374151, #4b5563);'}"
             title="${c.name}"
             onclick="selectTaskColor(this)">
       ${c.value === null ? '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/></svg>' : ''}
     </button>`
  ).join('');

  const content = `
    <form onsubmit="handleAddTimelineTask(event, ${projectIndex})">
      <div class="form-group">
        <label class="form-label">Task Title</label>
        <input type="text" name="title" class="form-input" placeholder="e.g. Design homepage mockup" required>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Start Date</label>
          <input type="date" name="startDate" class="form-input" value="${today}" required>
        </div>
        <div class="form-group">
          <label class="form-label">End Date</label>
          <input type="date" name="endDate" class="form-input" value="${nextWeek}" required>
        </div>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Category</label>
          <select name="category" class="form-input">
            <option value="">Select category...</option>
            <option value="design">🎨 Design</option>
            <option value="development">💻 Development</option>
            <option value="marketing">📢 Marketing</option>
            <option value="content">📝 Content</option>
            <option value="animation">🎬 Animation</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">Status</label>
          <select name="status" class="form-input">
            <option value="todo">To Do</option>
            <option value="in-progress">In Progress</option>
            <option value="review">Review</option>
            <option value="done">Done</option>
          </select>
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Bar Color</label>
        <div class="tl-color-picker">
          ${colorOptions}
        </div>
        <input type="hidden" name="color" value="">
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Add Task</button>
      </div>
    </form>
  `;

  openModal('Add Timeline Task', content);
}

// Color picker helper
function selectTaskColor(element) {
  // Remove active from all swatches
  document.querySelectorAll('.tl-color-swatch').forEach(s => s.classList.remove('active'));
  // Add active to clicked
  element.classList.add('active');
  // Update hidden input
  const colorInput = document.querySelector('input[name="color"]');
  if (colorInput) {
    colorInput.value = element.dataset.color || '';
  }
}

async function handleAddTimelineTask(event, projectIndex) {
  event.preventDefault();
  const form = event.target;
  const projects = loadProjects();
  const project = projects[projectIndex];

  if (!project.tasks) project.tasks = [];

  const colorValue = form.color.value;

  const newTask = {
    id: 'task_' + Date.now(),
    title: form.title.value,
    startDate: form.startDate.value,
    endDate: form.endDate.value,
    category: form.category.value,
    status: form.status?.value || 'todo',
    color: colorValue || null,
    createdAt: new Date().toISOString()
  };

  project.tasks.push(newTask);
  saveProjects(projects);
  closeModal();

  // Sync to DB if authenticated
  if (window.LayerDB && window.LayerDB.isAuthenticated() && project.id) {
    try {
      await window.LayerDB.updateProject(project.id, { tasks: project.tasks });
    } catch (error) {
      console.error('Failed to sync timeline task to database:', error);
    }
  }

  const contentScroll = document.querySelector('.pd-content-scroll');
  if (contentScroll) {
    renderTimelineView(projectIndex, contentScroll);
  }
  showToast('Task added to timeline!');
}

// Context menu removed - use double-click to edit tasks

async function deleteTimelineTask(projectIndex, taskId) {
  const projects = loadProjects();
  const project = projects[projectIndex];

  if (project.tasks) {
    project.tasks = project.tasks.filter(t => t.id !== taskId);
    saveProjects(projects);

    // Sync to DB if authenticated
    if (window.LayerDB && window.LayerDB.isAuthenticated() && project.id) {
      try {
        await window.LayerDB.updateProject(project.id, { tasks: project.tasks });
      } catch (error) {
        console.error('Failed to sync timeline task deletion to database:', error);
      }
    }

    const contentScroll = document.querySelector('.pd-content-scroll');
    if (contentScroll) {
      renderTimelineView(projectIndex, contentScroll);
    }
    showToast('Task deleted');
  }
}

function editTimelineTask(projectIndex, taskId) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  const task = project?.tasks?.find(t => t.id === taskId);

  if (!task) {
    showToast('Task not found');
    return;
  }

  const colorOptions = TIMELINE_TASK_COLORS.map(c =>
    `<button type="button" class="tl-color-swatch ${(c.value === task.color) || (c.value === null && !task.color) ? 'active' : ''}" 
             data-color="${c.value || ''}" 
             style="${c.value ? `background: ${c.value};` : 'background: linear-gradient(135deg, #374151, #4b5563);'}"
             title="${c.name}"
             onclick="selectTaskColor(this)">
       ${c.value === null ? '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/></svg>' : ''}
     </button>`
  ).join('');

  const content = `
    <form onsubmit="handleEditTimelineTask(event, ${projectIndex}, '${taskId}')">
      <div class="form-group">
        <label class="form-label">Task Title</label>
        <input type="text" name="title" class="form-input" value="${task.title || ''}" required>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Start Date</label>
          <input type="date" name="startDate" class="form-input" value="${task.startDate || ''}" required>
        </div>
        <div class="form-group">
          <label class="form-label">End Date</label>
          <input type="date" name="endDate" class="form-input" value="${task.endDate || ''}" required>
        </div>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label class="form-label">Category</label>
          <select name="category" class="form-input">
            <option value="">Select category...</option>
            <option value="design" ${task.category === 'design' ? 'selected' : ''}>🎨 Design</option>
            <option value="development" ${task.category === 'development' ? 'selected' : ''}>💻 Development</option>
            <option value="marketing" ${task.category === 'marketing' ? 'selected' : ''}>📢 Marketing</option>
            <option value="content" ${task.category === 'content' ? 'selected' : ''}>📝 Content</option>
            <option value="animation" ${task.category === 'animation' ? 'selected' : ''}>🎬 Animation</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">Status</label>
          <select name="status" class="form-input">
            <option value="todo" ${task.status === 'todo' ? 'selected' : ''}>To Do</option>
            <option value="in-progress" ${task.status === 'in-progress' ? 'selected' : ''}>In Progress</option>
            <option value="review" ${task.status === 'review' ? 'selected' : ''}>Review</option>
            <option value="done" ${task.status === 'done' || task.status === 'completed' ? 'selected' : ''}>Done</option>
          </select>
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Bar Color</label>
        <div class="tl-color-picker">
          ${colorOptions}
        </div>
        <input type="hidden" name="color" value="${task.color || ''}">
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Save Changes</button>
      </div>
    </form>
  `;

  openModal('Edit Task', content);
}

function handleEditTimelineTask(event, projectIndex, taskId) {
  event.preventDefault();
  const form = event.target;
  const projects = loadProjects();
  const project = projects[projectIndex];
  const task = project?.tasks?.find(t => t.id === taskId);

  if (!task) {
    showToast('Task not found');
    closeModal();
    return;
  }

  task.title = form.title.value;
  task.startDate = form.startDate.value;
  task.endDate = form.endDate.value;
  task.category = form.category.value;
  task.status = form.status.value;
  task.color = form.color.value || null;

  saveProjects(projects);
  closeModal();

  const contentScroll = document.querySelector('.pd-content-scroll');
  if (contentScroll) {
    renderTimelineView(projectIndex, contentScroll);
  }
  showToast('Task updated');
}

// Quick color change from context menu
function changeTaskColor(projectIndex, taskId, color) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  const task = project?.tasks?.find(t => t.id === taskId);

  if (task) {
    task.color = color || null;
    saveProjects(projects);


    const contentScroll = document.querySelector('.pd-content-scroll');
    if (contentScroll) {
      renderTimelineView(projectIndex, contentScroll);
    }
    showToast('Color updated');
  }
}

function duplicateTimelineTask(projectIndex, taskId) {
  const projects = loadProjects();
  const project = projects[projectIndex];

  if (project.tasks) {
    const task = project.tasks.find(t => t.id === taskId);
    if (task) {
      const duplicate = {
        ...task,
        id: 'task_' + Date.now(),
        title: task.title + ' (copy)'
      };
      project.tasks.push(duplicate);
      saveProjects(projects);

      const contentScroll = document.querySelector('.pd-content-scroll');
      if (contentScroll) {
        renderTimelineView(projectIndex, contentScroll);
      }
      showToast('Task duplicated');
    }
  }
}

function openTaskDetailModal(projectIndex, taskId) {
  showComingSoonToast();
}

function toggleProjectStar(projectIndex) {
  const projects = loadProjects();
  if (projects[projectIndex]) {
    projects[projectIndex].starred = !projects[projectIndex].starred;
    saveProjects(projects);
    renderCurrentView();
  }
}

function showProjectQuickActions(projectIndex, event) {
  event.stopPropagation();
  showComingSoonToast();
}

function toggleSidebar() {
  const sidebar = document.getElementById('pdSidebar');
  const layout = document.querySelector('.pd-layout');
  const toggleBtn = document.getElementById('sidebarToggleBtn');
  
  if (sidebar && layout) {
    const isCollapsed = sidebar.classList.contains('collapsed');
    
    if (isCollapsed) {
      sidebar.classList.remove('collapsed');
      layout.classList.remove('sidebar-collapsed');
      toggleBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="3" y1="6" x2="21" y2="6"/>
          <line x1="3" y1="12" x2="21" y2="12"/>
          <line x1="3" y1="18" x2="21" y2="18"/>
        </svg>
      `;
      localStorage.setItem('pdSidebarCollapsed', 'false');
    } else {
      sidebar.classList.add('collapsed');
      layout.classList.add('sidebar-collapsed');
      toggleBtn.innerHTML = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="11 18 6 13 11 8"/>
          <polyline points="18 18 13 13 18 8"/>
        </svg>
      `;
      localStorage.setItem('pdSidebarCollapsed', 'true');
    }
  }
}

function copyProjectLink(projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (project) {
    const link = new URL(window.location.href);
    link.searchParams.set('project', project.id);
    navigator.clipboard.writeText(link.toString()).then(() => {
      showToast('Link copied to clipboard!');
    }).catch(() => {
      showToast('Failed to copy link');
    });
  }
}

function showToast(message) {
  const toast = document.createElement('div');
  toast.className = 'pd-toast';
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(() => {
    toast.classList.add('show');
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, 2000);
  }, 10);
}

// Folder Dropdown Functions
let currentFolderDropdown = null;

function openFolderDropdown(button) {
  // Close any existing dropdown
  closeFolderDropdown();
  
  // Create dropdown container if it doesn't exist
  let container = button.closest('.folder-dropdown-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'folder-dropdown-container';
    button.parentNode.insertBefore(container, button);
    container.appendChild(button);
  }
  
  // Create dropdown form
  const dropdown = document.createElement('div');
  dropdown.className = 'folder-dropdown-form';
  dropdown.innerHTML = `
    <div class="folder-dropdown-header">
      <h3 class="folder-dropdown-title">Create New Folder</h3>
      <p class="folder-dropdown-subtitle">Enter a name for your new folder</p>
    </div>
    <input 
      type="text" 
      class="folder-dropdown-input" 
      placeholder="Folder name" 
      id="folder-name-input"
      autocomplete="off"
      maxlength="100"
    >
    <div class="folder-dropdown-actions">
      <button type="button" class="folder-dropdown-btn cancel" onclick="closeFolderDropdown()">Cancel</button>
      <button type="button" class="folder-dropdown-btn create" onclick="createFolder()">Create</button>
    </div>
  `;
  
  container.appendChild(dropdown);
  currentFolderDropdown = dropdown;
  
  // Focus the input
  const input = dropdown.querySelector('#folder-name-input');
  setTimeout(() => {
    input.focus();
    input.select();
  }, 10);
  
  // Add event listeners
  document.addEventListener('click', handleFolderDropdownOutsideClick);
  input.addEventListener('keydown', handleFolderInputKeydown);
  
  // Prevent form submission on Enter in input
  input.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      createFolder();
    }
  });
}

function closeFolderDropdown() {
  if (currentFolderDropdown) {
    // Remove event listeners
    document.removeEventListener('click', handleFolderDropdownOutsideClick);
    const input = currentFolderDropdown.querySelector('#folder-name-input');
    if (input) {
      input.removeEventListener('keydown', handleFolderInputKeydown);
    }
    
    // Remove dropdown
    currentFolderDropdown.remove();
    currentFolderDropdown = null;
  }
}

function handleFolderDropdownOutsideClick(e) {
  if (currentFolderDropdown && !currentFolderDropdown.contains(e.target) && 
      !e.target.closest('.add-folder-btn')) {
    closeFolderDropdown();
  }
}

function handleFolderInputKeydown(e) {
  if (e.key === 'Escape') {
    closeFolderDropdown();
  }
}

async function createFolder() {
  console.log('Creating folder...');
  
  if (!currentFolderDropdown) return;
  
  const input = currentFolderDropdown.querySelector('#folder-name-input');
  const folderName = input.value.trim();
  
  if (!folderName) {
    showToast('Please enter a folder name');
    input.focus();
    return;
  }
  
  try {
    // Create folder data
    const folderData = {
      id: 'folder_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
      name: folderName,
      description: '',
      color: '#6366f1',
      icon: 'folder',
      space_id: null,
      is_favorite: false,
      created_at: new Date().toISOString()
    };
    
    console.log('Folder data to save:', folderData);
    
    // Save to database
    const savedFolder = await saveFolderToDB(folderData);
    
    console.log('Saved folder result:', savedFolder);
    
    if (savedFolder) {
      showToast(`Folder "${folderName}" created successfully!`);
      
      // Close the dropdown
      closeFolderDropdown();
      
      // Render folders in the placeholder
      await renderFoldersInPlaceholder();
    } else {
      throw new Error('Failed to save folder');
    }
  } catch (error) {
    console.error('Error creating folder:', error);
    showToast('Failed to create folder. Please try again.');
  }
}

function openAddMilestoneModal(projectIndex) {
  const content = `
    <form onsubmit="handleAddMilestone(event, ${projectIndex})">
      <div class="form-group">
        <label class="form-label">Milestone Name</label>
        <input type="text" name="name" class="form-input" placeholder="e.g. MVP Release" required>
      </div>
      <div class="form-group">
        <label class="form-label">Description (optional)</label>
        <textarea name="description" class="form-textarea" placeholder="Brief description..."></textarea>
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Add Milestone</button>
      </div>
    </form>
  `;
  openModal('Add Milestone', content);
}

async function renderFoldersInPlaceholder() {
  console.log('Rendering folders in placeholder...');
  
  const placeholder = document.querySelector('.folders-placeholder');
  if (!placeholder) return;

  try {
    // Load folders from database
    const folders = await loadFoldersFromDB();
    
    console.log('Folders loaded for rendering:', folders);
    
    if (folders && folders.length > 0) {
      // Clear the placeholder content
      placeholder.innerHTML = '';
      
      // Create folders container
      const foldersContainer = document.createElement('div');
      foldersContainer.className = 'folders-grid';
      
      // Add each folder
      folders.forEach(folder => {
        const folderElement = document.createElement('div');
        folderElement.className = 'folder-item';
        folderElement.innerHTML = `
          <div class="folder-icon" style="background-color: ${folder.color || '#6366f1'}">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
            </svg>
          </div>
          <div class="folder-name">${folder.name}</div>
          <div class="folder-actions">
            <button class="folder-action-btn" onclick="openFolder('${folder.id}')" title="Open folder">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
              </svg>
            </button>
            <button class="folder-action-btn delete" onclick="deleteFolder('${folder.id}')" title="Delete folder">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
              </svg>
            </button>
          </div>
        `;
        foldersContainer.appendChild(folderElement);
      });
      
      // Add the "Add Folder" button
      const addButtonContainer = document.createElement('div');
      addButtonContainer.className = 'folder-add-container';
      addButtonContainer.innerHTML = `
        <button class="add-folder-btn" onclick="openFolderDropdown(this)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M12 5v14M5 12h14"/>
          </svg>
          Add Folder
        </button>
      `;
      foldersContainer.appendChild(addButtonContainer);
      
      placeholder.appendChild(foldersContainer);
      console.log('Folders rendered successfully');
    } else {
      // Show empty state
      placeholder.innerHTML = `
        <div class="folder-icon-large">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
          </svg>
        </div>
        <div class="folders-text">Add new Folder to your Space</div>
        <button class="add-folder-btn" onclick="openFolderDropdown(this)">
          Add Folder
        </button>
      `;
      console.log('Empty state rendered');
    }
  } catch (error) {
    console.error('Error rendering folders:', error);
  }
}

async function deleteFolder(folderId) {
  if (!confirm('Are you sure you want to delete this folder and all its contents?')) {
    return;
  }
  
  try {
    // First delete all files in the folder
    await deleteFolderContents(folderId);
    
    // Then delete the folder itself
    const success = await deleteFolderFromDB(folderId);
    if (success) {
      showToast('Folder deleted successfully!');
      await renderFoldersInPlaceholder();
    } else {
      throw new Error('Failed to delete folder');
    }
  } catch (error) {
    console.error('Error deleting folder:', error);
    showToast('Failed to delete folder. Please try again.');
  }
}

async function openFolder(folderId) {
  console.log('Opening folder:', folderId);
  
  try {
    // Load folders and find the selected folder
    const folders = await loadFoldersFromDB();
    const folder = folders.find(f => f.id === folderId);
    
    if (!folder) {
      showToast('Folder not found');
      return;
    }
    
    // Show folder explorer view
    showFolderExplorer(folder);
  } catch (error) {
    console.error('Error opening folder:', error);
    showToast('Failed to open folder');
  }
}

function handleAddMilestone(event, projectIndex) {
  event.preventDefault();
  const form = event.target;
  const name = form.name.value.trim();
  const description = form.description.value.trim();

  const projects = loadProjects();
  if (!projects[projectIndex].milestones) {
    projects[projectIndex].milestones = [];
  }

  projects[projectIndex].milestones.push({
    id: Date.now(),
    name,
    description,
    progress: 0,
    total: 0
  });

  saveProjects(projects);
  closeModal();
  renderCurrentView();
}

function updateMilestoneName(projectIndex, milestoneIndex, newName) {
  const projects = loadProjects();
  if (projects[projectIndex]?.milestones?.[milestoneIndex]) {
    projects[projectIndex].milestones[milestoneIndex].name = newName.trim();
    saveProjects(projects);
  }
}

function showMilestoneMenu(projectIndex, milestoneIndex, event) {
  event.stopPropagation();
  showComingSoonToast();
}

function openAddResourceModal(button, projectIndex) {
  // Check if container already exists
  const existingContainer = document.getElementById(`resource-form-container-${projectIndex}`);
  if (existingContainer) {
    // Toggle visibility
    if (existingContainer.style.display === 'none') {
      existingContainer.style.display = 'block';
      // Focus the name input
      setTimeout(() => {
        const nameInput = existingContainer.querySelector('input[name="name"]');
        if (nameInput) nameInput.focus();
      }, 100);
    } else {
      existingContainer.style.display = 'none';
    }
    return;
  }

  // Get existing docs for the dropdown
  const docs = loadDocs();
  const docsOptions = docs.map(doc => `<option value="${doc.id}">${doc.title}</option>`).join('');

  // Create inline container
  const container = document.createElement('div');
  container.id = `resource-form-container-${projectIndex}`;
  container.className = 'pd-resource-form-container';
  container.innerHTML = `
    <form onsubmit="handleAddResource(event, ${projectIndex})">
      <div class="form-group">
        <label class="form-label">Resource Type</label>
        <div class="radio-group">
          <label class="radio-label">
            <input type="radio" name="resourceType" value="custom" checked onchange="toggleResourceType(${projectIndex})">
            Custom Resource
          </label>
          <label class="radio-label">
            <input type="radio" name="resourceType" value="existing" onchange="toggleResourceType(${projectIndex})">
            Link Existing Doc
          </label>
        </div>
      </div>
      
      <div id="custom-resource-fields-${projectIndex}">
        <div class="form-group">
          <label class="form-label">Resource Name</label>
          <input type="text" name="name" class="form-input" placeholder="e.g. Design Spec" required>
        </div>
        <div class="form-group">
          <label class="form-label">Link (optional)</label>
          <input type="url" name="link" class="form-input" placeholder="https://...">
        </div>
      </div>
      
      <div id="existing-doc-fields-${projectIndex}" style="display: none;">
        <div class="form-group">
          <label class="form-label">Select Document</label>
          <select name="existingDocId" class="form-input">
            <option value="">Choose a document...</option>
            ${docsOptions}
          </select>
        </div>
      </div>
      
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeResourceForm(${projectIndex})">Cancel</button>
        <button type="submit" class="btn btn-primary">Add Resource</button>
      </div>
    </form>
  `;

  // Insert container after the button
  const resourcesContainer = button.closest('.pd-resources');
  resourcesContainer.style.position = 'relative';
  resourcesContainer.appendChild(container);

  // Focus the name input
  setTimeout(() => {
    const nameInput = container.querySelector('input[name="name"]');
    if (nameInput) nameInput.focus();
  }, 100);
}

function toggleResourceType(projectIndex) {
  const container = document.getElementById(`resource-form-container-${projectIndex}`);
  const resourceType = container.querySelector('input[name="resourceType"]:checked').value;

  const customFields = document.getElementById(`custom-resource-fields-${projectIndex}`);
  const existingDocFields = document.getElementById(`existing-doc-fields-${projectIndex}`);

  if (resourceType === 'custom') {
    customFields.style.display = 'block';
    existingDocFields.style.display = 'none';
    container.querySelector('input[name="name"]').required = true;
    container.querySelector('select[name="existingDocId"]').required = false;
  } else {
    customFields.style.display = 'none';
    existingDocFields.style.display = 'block';
    container.querySelector('input[name="name"]').required = false;
    container.querySelector('select[name="existingDocId"]').required = true;
  }
}

// ============================================
// Auto-share documents with project team members
// ============================================

async function shareDocWithTeamMembers(docId, teamMembers) {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    console.log('User not authenticated, skipping auto-share');
    return;
  }

  try {
    // Get current document to see existing shares
    const docs = await window.LayerDB.loadDocs();
    const currentDoc = docs.find(d => d.id === docId);

    if (!currentDoc) {
      console.log('Document not found:', docId);
      return;
    }

    // Get existing shared users
    const existingShares = currentDoc.sharedWith || currentDoc.shared_with || [];
    const existingEmails = existingShares.map(user => user.email);

    // Filter team members who are not already shared with
    const newShares = teamMembers
      .filter(member => member && member !== 'You' && !existingEmails.includes(member))
      .map(email => ({
        email: email,
        name: email.split('@')[0], // Extract name from email
        avatar_url: null,
        role: 'viewer'
      }));

    if (newShares.length === 0) {
      console.log('All team members already have access');
      return;
    }

    // Combine existing shares with new shares
    const updatedShares = [...existingShares, ...newShares];

    // Update document with new shares
    const result = await window.LayerDB.updateDoc(docId, { shared_with: updatedShares });
    console.log('Auto-shared document with team members:', newShares, result);

    // Also update local cache for immediate UI consistency
    const localDocs = loadDocs();
    const localDocIndex = localDocs.findIndex(d => d.id === docId);
    if (localDocIndex !== -1) {
      localDocs[localDocIndex].sharedWith = updatedShares;
      localDocs[localDocIndex].shared_with = updatedShares;
      saveDocs(localDocs);
    }

  } catch (error) {
    console.error('Failed to auto-share document with team members:', error);
  }
}

function closeResourceForm(projectIndex) {
  const container = document.getElementById(`resource-form-container-${projectIndex}`);
  if (container) {
    container.style.display = 'none';
  }
}

function handleAddResource(event, projectIndex) {
  event.preventDefault();
  const form = event.target;
  const resourceType = form.resourceType.value;

  let name, link, docId;

  if (resourceType === 'custom') {
    name = form.name.value.trim();
    link = form.link.value.trim();
    docId = null;
  } else {
    docId = form.existingDocId.value;
    if (!docId) {
      showToast('Please select a document');
      return;
    }

    // Get document details
    const docs = loadDocs();
    const selectedDoc = docs.find(doc => doc.id === docId);
    if (!selectedDoc) {
      showToast('Selected document not found');
      return;
    }

    name = selectedDoc.title;
    link = null; // Will be generated as a link to the doc
  }

  const projects = loadProjects();
  if (!projects[projectIndex].resources) {
    projects[projectIndex].resources = [];
  }

  const resourceData = {
    name,
    link,
    docId,
    type: resourceType,
    addedAt: new Date().toISOString()
  };

  projects[projectIndex].resources.push(resourceData);
  saveProjects(projects);

  // Auto-share document with team members if it's an existing doc
  if (resourceType === 'existing' && docId) {
    const teamMembers = projects[projectIndex].teamMembers || [];
    shareDocWithTeamMembers(docId, teamMembers);
  }

  // Sync to database if authenticated
  if (window.LayerDB && window.LayerDB.isAuthenticated() && projects[projectIndex].id) {
    window.LayerDB.updateProject(projects[projectIndex].id, {
      resources: projects[projectIndex].resources
    }).then(result => {
      console.log('Resource saved to database:', result);
      showToast('Resource saved to project');
    }).catch(error => {
      console.error('Failed to save resource to database:', error);
      showToast('Failed to save resource to database', 'error');
    });
  } else {
    showToast('Resource added locally');
  }

  // Close the resource form
  closeResourceForm(projectIndex);

  renderCurrentView();
}

function removeProjectResource(projectIndex, resourceIndex) {
  const projects = loadProjects();
  if (projects[projectIndex]?.resources) {
    projects[projectIndex].resources.splice(resourceIndex, 1);
    saveProjects(projects);

    // Sync to database if authenticated
    if (window.LayerDB && window.LayerDB.isAuthenticated() && projects[projectIndex].id) {
      window.LayerDB.updateProject(projects[projectIndex].id, {
        resources: projects[projectIndex].resources
      }).then(result => {
        console.log('Resource removed from database:', result);
        showToast('Resource removed from project');
      }).catch(error => {
        console.error('Failed to remove resource from database:', error);
        showToast('Failed to remove resource from database', 'error');
      });
    } else {
      showToast('Resource removed');
    }

    renderCurrentView();
  }
}

function openAssignLeadModal(projectIndex) {
  showComingSoonToast();
}

function openLabelsModal(projectIndex) {
  showComingSoonToast();
}

function addCustomProperty(projectIndex) {
  showComingSoonToast();
}

function openActivityModal(projectIndex) {
  showComingSoonToast();
}

function showMorePropertiesMenu(projectIndex, event) {
  event.stopPropagation();
  showComingSoonToast();
}

function toggleStatusDropdown(projectIndex, event) {
  event.stopPropagation();
  showComingSoonToast();
}

function toggleUpdateReaction(projectIndex) {
  showComingSoonToast();
}

function openEditStartDateModal(projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  const currentDate = project.startDate || new Date().toISOString().split('T')[0];

  const content = `
    <form onsubmit="handleUpdateStartDate(event, ${projectIndex})">
      <div class="form-group">
        <label class="form-label">Start Date</label>
        <input type="date" name="startDate" class="form-input" value="${currentDate}" required>
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Update Date</button>
      </div>
    </form>
  `;
  openModal('Edit Start Date', content);
}

function handleUpdateStartDate(event, projectIndex) {
  event.preventDefault();
  const form = event.target;
  const newDate = form.startDate.value;

  const projects = loadProjects();
  if (projects[projectIndex]) {
    projects[projectIndex].startDate = newDate;
    saveProjects(projects);
  }
  closeModal();
  renderCurrentView();
}

// Progress chart rendering - Linear-style Professional Chart (Minimalistic)
function renderProgressChart(progressHistory, projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  const { total, completed, percentage } = calculateProgress(project?.columns || []);

  const chartWidth = 280;
  const chartHeight = 120;
  const padding = { top: 8, right: 8, bottom: 24, left: 8 };
  const graphWidth = chartWidth - padding.left - padding.right;
  const graphHeight = chartHeight - padding.top - padding.bottom;

  // Generate Linear-style data points based on actual project progress
  const dataPoints = generateLinearStyleData(project);
  const maxScope = Math.max(...dataPoints.map(d => d.scope), 1);

  // Stats for display - matching Linear's exact layout
  const currentData = dataPoints[dataPoints.length - 1];
  const firstData = dataPoints[0];
  const scopeTotal = currentData?.scope || total || 0;
  const scopeChange = firstData.scope > 0 ?
    Math.round(((currentData.scope - firstData.scope) / firstData.scope) * 100) : 0;
  const startedCount = currentData?.started || 0;
  const startedPercent = scopeTotal > 0 ? Math.round((startedCount / scopeTotal) * 100) : 0;
  const completedCount = currentData?.completed || completed || 0;
  const completedPercent = scopeTotal > 0 ? Math.round((completedCount / scopeTotal) * 100) : percentage;

  // Generate stepped/area paths for cleaner look
  const scopePath = generateSteppedLinePath(dataPoints, 'scope', graphWidth, graphHeight, maxScope, padding);
  const startedAreaPath = generateSteppedAreaPath(dataPoints, 'started', graphWidth, graphHeight, maxScope, padding);
  const completedAreaPath = generateSteppedAreaPath(dataPoints, 'completed', graphWidth, graphHeight, maxScope, padding);

  // Date labels
  const firstDate = dataPoints[0]?.date || '';
  const midDate = dataPoints[Math.floor(dataPoints.length / 2)]?.date || '';
  const lastDate = dataPoints[dataPoints.length - 1]?.date || '';

  return `
    <div class="linear-progress-chart" id="progressChart-${projectIndex}">
      <!-- Stats Header - Linear Style (Horizontal) -->
      <div class="chart-stats-row">
        <div class="chart-stat-block">
          <div class="stat-label-row">
            <span class="stat-dot scope-dot"></span>
            <span class="stat-label">Scope</span>
          </div>
          <div class="stat-value-row">
            <span class="stat-number">${scopeTotal}</span>
            <span class="stat-badge ${scopeChange >= 0 ? 'positive' : 'negative'}">${scopeChange >= 0 ? '+' : ''}${scopeChange}%</span>
          </div>
        </div>
        <div class="chart-stat-block">
          <div class="stat-label-row">
            <span class="stat-dot started-dot"></span>
            <span class="stat-label">Started</span>
          </div>
          <div class="stat-value-row">
            <span class="stat-number">${startedCount}</span>
            <span class="stat-percent">· ${startedPercent}%</span>
          </div>
        </div>
        <div class="chart-stat-block">
          <div class="stat-label-row">
            <span class="stat-dot completed-dot"></span>
            <span class="stat-label">Completed</span>
          </div>
          <div class="stat-value-row">
            <span class="stat-number">${completedCount}</span>
            <span class="stat-percent">· ${completedPercent}%</span>
          </div>
        </div>
      </div>
      
      <!-- SVG Chart - Clean Stacked Area Style -->
      <div class="chart-svg-container">
        <svg width="100%" height="${chartHeight}" viewBox="0 0 ${chartWidth} ${chartHeight}" preserveAspectRatio="xMidYMid meet" class="linear-chart-svg">
          <defs>
            <linearGradient id="scopeGradient-${projectIndex}" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="rgba(255,255,255,0.08)"/>
              <stop offset="100%" stop-color="rgba(255,255,255,0.02)"/>
            </linearGradient>
            <linearGradient id="startedGradient-${projectIndex}" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#fbbf24" stop-opacity="0.5"/>
              <stop offset="100%" stop-color="#fbbf24" stop-opacity="0.1"/>
            </linearGradient>
            <linearGradient id="completedGradient-${projectIndex}" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" stop-color="#8b5cf6" stop-opacity="0.7"/>
              <stop offset="100%" stop-color="#8b5cf6" stop-opacity="0.2"/>
            </linearGradient>
          </defs>
          
          <!-- Scope area (bottom layer - subtle) -->
          <path d="${generateSteppedAreaPath(dataPoints, 'scope', graphWidth, graphHeight, maxScope, padding)}" fill="url(#scopeGradient-${projectIndex})" stroke="rgba(255,255,255,0.15)" stroke-width="1"/>
          
          <!-- Started area (middle layer - yellow) -->
          <path d="${startedAreaPath}" fill="url(#startedGradient-${projectIndex})" stroke="#fbbf24" stroke-width="1.5"/>
          
          <!-- Completed area (top layer - purple) -->
          <path d="${completedAreaPath}" fill="url(#completedGradient-${projectIndex})" stroke="#8b5cf6" stroke-width="1.5"/>
          
          <!-- X-axis labels -->
          <text x="${padding.left}" y="${chartHeight - 4}" text-anchor="start" class="chart-date-label">${firstDate}</text>
          <text x="${chartWidth / 2}" y="${chartHeight - 4}" text-anchor="middle" class="chart-date-label">${midDate}</text>
          <text x="${chartWidth - padding.right}" y="${chartHeight - 4}" text-anchor="end" class="chart-date-label">${lastDate}</text>
        </svg>
      </div>
    </div>
  `;
}

// Generate stepped line path (no curves, just steps)
function generateSteppedLinePath(dataPoints, key, graphWidth, graphHeight, maxValue, padding) {
  if (dataPoints.length < 2) return '';

  let path = '';
  dataPoints.forEach((d, i) => {
    const x = padding.left + (i / (dataPoints.length - 1)) * graphWidth;
    const y = padding.top + graphHeight - ((d[key] || 0) / maxValue) * graphHeight;

    if (i === 0) {
      path = `M ${x} ${y}`;
    } else {
      const prevX = padding.left + ((i - 1) / (dataPoints.length - 1)) * graphWidth;
      path += ` H ${x} V ${y}`;
    }
  });

  return path;
}

// Generate stepped area path for gradient fill
function generateSteppedAreaPath(dataPoints, key, graphWidth, graphHeight, maxValue, padding) {
  if (dataPoints.length < 2) return '';

  const bottomY = padding.top + graphHeight;
  let path = `M ${padding.left} ${bottomY}`;

  dataPoints.forEach((d, i) => {
    const x = padding.left + (i / (dataPoints.length - 1)) * graphWidth;
    const y = padding.top + graphHeight - ((d[key] || 0) / maxValue) * graphHeight;

    if (i === 0) {
      path += ` L ${x} ${y}`;
    } else {
      path += ` H ${x} V ${y}`;
    }
  });

  // Close the path back to baseline
  const endX = padding.left + graphWidth;
  path += ` H ${endX} V ${bottomY} Z`;

  return path;
}

// Generate Linear-style data from project tasks
function generateLinearStyleData(project) {
  const points = [];
  const today = new Date();
  const columns = project?.columns || [];

  // Calculate current totals from columns
  let totalTasks = 0;
  let inProgressTasks = 0;
  let doneTasks = 0;

  columns.forEach((col, idx) => {
    const colTasks = col.tasks?.length || 0;
    totalTasks += colTasks;

    const title = (col.title || '').toLowerCase();
    if (title.includes('progress') || title.includes('doing') || title.includes('review')) {
      inProgressTasks += colTasks;
    }
    if (title.includes('done') || title.includes('complete') || title.includes('finished')) {
      doneTasks += colTasks;
    }
  });

  // If no "done" column detected, use last column
  if (doneTasks === 0 && columns.length > 0) {
    const lastCol = columns[columns.length - 1];
    doneTasks = lastCol.tasks?.length || 0;
  }

  // Ensure minimum values for visualization
  const baseScope = Math.max(totalTasks, 8);
  const baseStarted = inProgressTasks + doneTasks;
  const baseCompleted = doneTasks;

  // Generate 14 days of realistic progress data
  for (let i = 0; i < 14; i++) {
    const date = new Date(today);
    date.setDate(today.getDate() - 13 + i);
    const progress = i / 13;

    // Scope grows slightly over time
    const scope = Math.floor(baseScope * (0.8 + progress * 0.2));

    // Started and completed grow more progressively
    const started = Math.floor(baseStarted * Math.pow(progress, 0.7));
    const completed = Math.floor(baseCompleted * Math.pow(progress, 0.8));

    points.push({
      date: date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
      scope: scope,
      started: Math.min(started, scope),
      completed: Math.min(completed, started, scope)
    });
  }

  return points.length > 0 ? points : [{ date: 'Today', scope: 1, started: 0, completed: 0 }];
}

// Generate smooth data points from progress history (fallback)
function generateSmoothDataPoints(progressHistory) {
  const points = [];
  const today = new Date();

  for (let i = 0; i < 14; i++) {
    const date = new Date(today);
    date.setDate(today.getDate() - 13 + i);
    const progress = i / 13;
    const scopeBase = 200 + Math.floor(progress * 84);
    const completedBase = Math.floor(progress * 193 * 0.85);

    points.push({
      date: date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
      scope: scopeBase,
      completed: Math.min(completedBase, scopeBase)
    });
  }

  return points;
}

// Generate smooth bezier curve path
function generateSmoothPath(dataPoints, key, graphWidth, graphHeight, maxValue, padding) {
  if (dataPoints.length < 2) return '';

  const points = dataPoints.map((d, i) => ({
    x: padding.left + (i / (dataPoints.length - 1)) * graphWidth,
    y: padding.top + graphHeight - (d[key] / maxValue) * graphHeight
  }));

  let path = `M ${points[0].x} ${points[0].y}`;

  for (let i = 1; i < points.length; i++) {
    const prev = points[i - 1];
    const curr = points[i];
    const tension = 0.3;

    const cp1x = prev.x + (curr.x - prev.x) * tension;
    const cp1y = prev.y;
    const cp2x = curr.x - (curr.x - prev.x) * tension;
    const cp2y = curr.y;

    path += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${curr.x} ${curr.y}`;
  }

  return path;
}

// Generate area path for gradient fill
function generateAreaPath(dataPoints, key, graphWidth, graphHeight, maxValue, padding, chartHeight) {
  const linePath = generateSmoothPath(dataPoints, key, graphWidth, graphHeight, maxValue, padding);
  const startX = padding.left;
  const endX = padding.left + graphWidth;
  const bottomY = padding.top + graphHeight;

  return `${linePath} L ${endX} ${bottomY} L ${startX} ${bottomY} Z`;
}

// Generate grid lines
function generateGridLines(graphHeight, padding, chartWidth) {
  const lines = [];
  const numLines = 4;

  for (let i = 0; i <= numLines; i++) {
    const y = padding.top + (graphHeight / numLines) * i;
    lines.push(`<line x1="${padding.left}" y1="${y}" x2="${chartWidth - padding.right}" y2="${y}" stroke="rgba(255,255,255,0.06)" stroke-width="1"/>`);
  }

  return lines.join('');
}

// Generate date labels
function generateDateLabels(numPoints) {
  const labels = [];
  const today = new Date();
  const positions = [0, Math.floor(numPoints / 2), numPoints - 1];

  positions.forEach(i => {
    const date = new Date(today);
    date.setDate(today.getDate() - (numPoints - 1 - i));
    labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
  });

  return labels;
}

function generateMockProgressHistory() {
  return [
    { week: 1, completed: Math.floor(Math.random() * 5) + 2 },
    { week: 2, completed: Math.floor(Math.random() * 8) + 5 },
    { week: 3, completed: Math.floor(Math.random() * 10) + 8 },
    { week: 4, completed: Math.floor(Math.random() * 12) + 10 }
  ];
}

// Tooltip functions for the chart
function showChartTooltip(event, scope, completed, dateLabel) {
  const tooltip = event.target.closest('.chart-svg-container')?.querySelector('.chart-tooltip');
  if (!tooltip) return;

  const rect = event.target.closest('.chart-svg-container').getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  tooltip.querySelector('.tooltip-date').textContent = dateLabel;
  tooltip.querySelector('.scope-value').textContent = scope;
  tooltip.querySelector('.completed-value').textContent = completed;

  // Position tooltip
  const tooltipWidth = 140;
  let tooltipX = x + 10;
  if (tooltipX + tooltipWidth > rect.width) {
    tooltipX = x - tooltipWidth - 10;
  }

  tooltip.style.left = `${tooltipX}px`;
  tooltip.style.top = `${Math.max(10, y - 40)}px`;
  tooltip.classList.add('visible');

  // Show indicator line
  const chartId = tooltip.id.replace('chartTooltip-', 'chartIndicator-');
  const indicator = document.getElementById(chartId);
  if (indicator) {
    const point = event.target.closest('.chart-point-group');
    if (point) {
      const circle = point.querySelector('.scope-point');
      const cx = circle?.getAttribute('cx');
      if (cx) {
        indicator.setAttribute('x1', cx);
        indicator.setAttribute('x2', cx);
        indicator.style.display = 'block';
      }
    }
  }
}

function hideChartTooltip() {
  document.querySelectorAll('.chart-tooltip').forEach(t => t.classList.remove('visible'));
  document.querySelectorAll('[id^="chartIndicator-"]').forEach(i => i.style.display = 'none');
}

// Priority dropdown functions
function togglePriorityDropdown(projectIndex, event) {
  event.stopPropagation();
  const dropdown = document.getElementById('priorityDropdown-' + projectIndex);
  if (!dropdown) return;

  // Close other dropdowns
  document.querySelectorAll('.priority-dropdown.show').forEach(d => {
    if (d !== dropdown) d.classList.remove('show');
  });

  dropdown.classList.toggle('show');

  // Close on outside click
  if (dropdown.classList.contains('show')) {
    setTimeout(() => {
      document.addEventListener('click', closePriorityDropdown, { once: true });
    }, 10);
  }
}

function closePriorityDropdown() {
  document.querySelectorAll('.priority-dropdown.show').forEach(d => d.classList.remove('show'));
}

function setProjectPriority(projectIndex, priority) {
  const projects = loadProjects();
  if (projects[projectIndex]) {
    // Allow null/undefined for "No priority" - don't default to 'medium'
    projects[projectIndex].priority = priority;
    saveProjects(projects);
  }
  renderCurrentView();
}

// Target date editing
function openEditTargetDateModal(projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  const currentDate = project.targetDate || new Date().toISOString().split('T')[0];

  const content = `
    <form onsubmit="handleUpdateTargetDate(event, ${projectIndex})">
      <div class="form-group">
        <label class="form-label">Target Date</label>
        <input type="date" name="targetDate" class="form-input" value="${currentDate}" required>
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Update Date</button>
      </div>
    </form>
  `;
  openModal('Edit Target Date', content);
}

function handleUpdateTargetDate(event, projectIndex) {
  event.preventDefault();
  const form = event.target;
  const newDate = form.targetDate.value;

  const projects = loadProjects();
  if (projects[projectIndex]) {
    projects[projectIndex].targetDate = newDate;
    saveProjects(projects);
  }
  closeModal();
  renderCurrentView();
}

// Document upload
function handleProjectDocUpload(event, projectIndex) {
  const file = event.target.files[0];
  if (!file) return;

  const projects = loadProjects();
  if (!projects[projectIndex]) return;

  if (!projects[projectIndex].sharedDocuments) {
    projects[projectIndex].sharedDocuments = [];
  }

  projects[projectIndex].sharedDocuments.push({
    name: file.name,
    type: file.type,
    size: file.size,
    uploadedAt: new Date().toISOString()
  });

  saveProjects(projects);
  renderCurrentView();

  // Show toast
  const toast = document.createElement('div');
  toast.textContent = `"${file.name}" uploaded successfully!`;
  toast.style.cssText = 'position: fixed; bottom: 24px; right: 24px; padding: 12px 20px; background: var(--card); color: var(--foreground); border: 1px solid var(--border); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 9999;';
  document.body.appendChild(toast);
  setTimeout(() => toast.remove(), 3000);
}

function removeProjectDoc(projectIndex, docIndex) {
  const projects = loadProjects();
  if (projects[projectIndex] && projects[projectIndex].sharedDocuments) {
    projects[projectIndex].sharedDocuments.splice(docIndex, 1);
    saveProjects(projects);
    renderCurrentView();
  }
}

// Comments functions
window.isImportantComment = false;

function addProjectComment(projectIndex) {
  const input = document.getElementById(`projectComment-${projectIndex}`);
  if (!input || !input.value.trim()) return;

  const projects = loadProjects();
  if (!projects[projectIndex]) return;

  if (!projects[projectIndex].comments) {
    projects[projectIndex].comments = [];
  }

  projects[projectIndex].comments.unshift({
    author: 'You',
    message: input.value.trim(),
    isImportant: window.isImportantComment,
    time: new Date().toISOString(),
    reactions: 0,
    replies: []
  });

  saveProjects(projects);
  window.isImportantComment = false;
  renderCurrentView();
}

function replyToComment(projectIndex, commentIndex) {
  const reply = prompt('Your reply:');
  if (!reply || !reply.trim()) return;

  const projects = loadProjects();
  if (!projects[projectIndex] || !projects[projectIndex].comments[commentIndex]) return;

  if (!projects[projectIndex].comments[commentIndex].replies) {
    projects[projectIndex].comments[commentIndex].replies = [];
  }

  projects[projectIndex].comments[commentIndex].replies.push({
    author: 'You',
    message: reply.trim(),
    time: new Date().toISOString()
  });

  saveProjects(projects);
  renderCurrentView();
}

function reactToComment(projectIndex, commentIndex) {
  const projects = loadProjects();
  if (!projects[projectIndex] || !projects[projectIndex].comments[commentIndex]) return;

  projects[projectIndex].comments[commentIndex].reactions =
    (projects[projectIndex].comments[commentIndex].reactions || 0) + 1;

  saveProjects(projects);
  renderCurrentView();
}

function deleteProjectComment(projectIndex, commentIndex) {
  const projects = loadProjects();
  if (!projects[projectIndex] || !projects[projectIndex].comments) return;

  projects[projectIndex].comments.splice(commentIndex, 1);
  saveProjects(projects);
  renderCurrentView();
}

function toggleCommentImportant(projectIndex, commentIndex) {
  const projects = loadProjects();
  if (!projects[projectIndex] || !projects[projectIndex].comments[commentIndex]) return;

  projects[projectIndex].comments[commentIndex].isImportant =
    !projects[projectIndex].comments[commentIndex].isImportant;

  saveProjects(projects);
  renderCurrentView();
}

// Start project function
function startProject(projectIndex) {
  const projects = loadProjects();
  if (!projects[projectIndex]) return;

  projects[projectIndex].status = 'in-progress';
  projects[projectIndex].startedAt = new Date().toISOString();

  // Add an update to track the start
  if (!projects[projectIndex].updates) {
    projects[projectIndex].updates = [];
  }
  projects[projectIndex].updates.unshift({
    actor: 'You',
    action: 'Started the project',
    time: 'just now'
  });

  saveProjects(projects);
  renderCurrentView();
}

// Team invite modal
function openInviteMemberModal(projectIndex) {
  const content = `
    <form id="inviteMemberForm" onsubmit="handleInviteMember(event, ${projectIndex})">
      <div class="form-group">
        <label class="form-label">Email Address <span class="required">*</span></label>
        <input type="email" name="email" class="form-input" required placeholder="colleague@example.com">
      </div>
      <p style="font-size: 13px; color: var(--muted-foreground); margin-bottom: 16px;">
        An invitation email will be sent to join this project.
      </p>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Send Invitation</button>
      </div>
    </form>
  `;
  openModal('Invite Team Member', content);
}

async function handleInviteMember(event, projectIndex) {
  event.preventDefault();
  const form = event.target;
  const email = form.email.value.trim();

  if (!email) return;

  // Require authentication
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to invite members', 'error');
    return;
  }

  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project || !project.id) {
    showToast('Project not found', 'error');
    return;
  }

  const submitBtn = form.querySelector('button[type="submit"]');
  const originalText = submitBtn?.textContent;
  if (submitBtn) {
    submitBtn.disabled = true;
    submitBtn.textContent = 'Adding member...';
  }

  try {
    // Refresh user data to ensure we have the latest session
    console.log('Refreshing user session...');
    await window.LayerDB.refreshUser();

    const currentUser = window.LayerDB.getCurrentUser();
    console.log('Current user:', currentUser);

    if (!currentUser || !currentUser.id) {
      throw new Error('User not authenticated properly. Please sign in again.');
    }

    // Use the enhanced team member addition function
    console.log('Adding team member directly to project...');
    await window.LayerDB.addTeamMemberToProject(project.id, email);

    // Immediately update local state for instant UI feedback
    const projects = loadProjects();
    const localProject = projects[projectIndex];
    if (localProject && localProject.teamMembers) {
      // Add email to team members array if not already present
      if (!localProject.teamMembers.includes(email)) {
        localProject.teamMembers.push(email);
        saveProjects(projects);
        console.log('Updated local team members:', localProject.teamMembers);
      }
    }

    // Also create invitation record for tracking (optional)
    try {
      const { data: invitationData, error: inviteError } = await window.LayerDB.supabase
        .from('project_invitations')
        .insert({
          project_id: project.id,
          inviter_id: currentUser.id,
          invitee_email: email,
          status: 'accepted' // Since we're adding directly, mark as accepted
        })
        .select()
        .single();

      if (inviteError) {
        console.warn('Failed to create invitation record:', inviteError);
        // Continue anyway since the team member was added successfully
      } else {
        console.log('Invitation record created:', invitationData);
      }
    } catch (inviteRecordError) {
      console.warn('Error creating invitation record:', inviteRecordError);
    }

    // Show success message
    showToast(`Successfully added ${email} to the team!`, 'success');
    closeModal();

    // Refresh the team members display immediately for better UX
    if (currentView === 'project-detail') {
      refreshTeamMembersDisplay(projectIndex);
    } else {
      renderCurrentView();
    }

    // Re-initialize presence polling for the updated member list
    setTimeout(() => {
      const projects = loadProjects();
      const project = projects[projectIndex];
      if (project && project.id) {
        startPresencePolling(project.id, projectIndex);
      }
    }, 1000);

  } catch (error) {
    console.error('Error adding team member:', error);
    let errorMessage = 'Failed to add team member';

    if (error.message?.includes('already a team member')) {
      errorMessage = 'This user is already a team member';
    } else if (error.message?.includes('Not authenticated')) {
      errorMessage = 'Please sign in again';
    } else if (error.message) {
      errorMessage = error.message;
    }

    showToast(errorMessage, 'error');
  } finally {
    // Restore button state
    if (submitBtn && originalText) {
      submitBtn.disabled = false;
      submitBtn.textContent = originalText;
    }
  }
}

// Team chart helper functions
function getTeamColor(index) {
  const colors = [
    '#6366f1', // Indigo
    '#10b981', // Emerald  
    '#f59e0b', // Amber
    '#ef4444', // Red
    '#8b5cf6', // Violet
    '#06b6d4', // Cyan
    '#ec4899', // Pink
    '#84cc16', // Lime
  ];
  return colors[index % colors.length];
}

function generateTeamChartData(project, teamMembers) {
  // Generate simulated performance data based on project tasks
  const data = [];
  const numWeeks = 5;

  teamMembers.forEach((member, memberIndex) => {
    const memberData = [];
    let baseValue = 20 + Math.random() * 30;

    for (let week = 0; week < numWeeks; week++) {
      // Add some variation and upward trend
      const variation = (Math.random() - 0.3) * 25;
      const trend = week * 8;
      const value = Math.min(100, Math.max(5, baseValue + variation + trend));
      memberData.push(Math.round(value));
      baseValue = value;
    }
    data.push(memberData);
  });

  return data;
}

// Column management handlers
function handleAddColumn(projectIndex) {
  // Find the kanban header where the button is located
  const kanbanHeader = document.querySelector(`[data-project-index="${projectIndex}"], .tl-kanban-header`);
  
  // Look for a more specific selector
  const parentContainer = document.querySelector(`.pd-tab[data-tab="kanban"][data-project-index="${projectIndex}"]`) || 
                        document.querySelector('.tl-kanban-header');
  
  // Find the add column button container
  const addButton = parentContainer.querySelector('.tl-kanban-add-col-btn');
  
  // Hide the original button temporarily
  addButton.style.display = 'none';
  
  // Create input field for column name
  const inputField = document.createElement('input');
  inputField.type = 'text';
  inputField.placeholder = 'Enter column name...';
  inputField.className = 'tl-kanban-col-input';
  inputField.value = 'New Column';
  
  // Style the input to match the button
  inputField.style.padding = '8px 12px';
  inputField.style.marginLeft = '10px';
  inputField.style.border = '1px solid var(--border)';
  inputField.style.borderRadius = '6px';
  inputField.style.backgroundColor = 'var(--background)';
  inputField.style.color = 'var(--foreground)';
  inputField.style.fontSize = '14px';
  
  // Insert input field next to the button
  addButton.parentNode.insertBefore(inputField, addButton.nextSibling);
  
  // Focus the input field and select the text
  inputField.focus();
  inputField.select();
  
  // Handle input submission
  inputField.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
      const columnName = inputField.value;
      if (columnName && columnName.trim()) {
        // Save the current active tab before re-render
        const activeTab = document.querySelector('.pd-tab.active');
        const currentTabName = activeTab ? activeTab.dataset.tab : 'overview';
        
        addColumnToProject(projectIndex, columnName.trim());
        
        renderCurrentView();
        
        // Restore the active tab if we're in project detail view and timeline was active
        if (currentTabName === 'timeline' && typeof switchProjectTab === 'function') {
          requestAnimationFrame(() => {
            switchProjectTab('timeline', projectIndex);
          });
        }
      } else {
        // Remove the input and show the button again if empty
        inputField.remove();
        addButton.style.display = 'inline-flex';
      }
    }
  });
  
  // Handle cancel on blur if empty
  inputField.addEventListener('blur', function() {
    if (!inputField.value.trim()) {
      inputField.remove();
      addButton.style.display = 'inline-flex';
    }
  });
  
  // Handle escape key to cancel
  inputField.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      inputField.remove();
      addButton.style.display = 'inline-flex';
    }
  });
}

function handleDeleteColumn(projectIndex, columnIndex) {
  const projects = loadProjects();
  const column = projects[projectIndex]?.columns[columnIndex];

  if (!column) return;

  if (column.tasks.length > 0) {
    if (!confirm(`Delete "${column.title}" column? It contains ${column.tasks.length} task(s) that will also be deleted.`)) {
      return;
    }
  }

  // Save the current active tab before re-render
  const activeTab = document.querySelector('.pd-tab.active');
  const currentTabName = activeTab ? activeTab.dataset.tab : 'overview';

  deleteColumnFromProject(projectIndex, columnIndex);

  renderCurrentView();

  // Restore the active tab if we're in project detail view and timeline was active
  if (currentTabName === 'timeline' && typeof switchProjectTab === 'function') {
    requestAnimationFrame(() => {
      switchProjectTab('timeline', projectIndex);
    });
  }
}

function handleRenameColumn(projectIndex, columnIndex, newTitle) {
  if (newTitle && newTitle.trim()) {
    renameColumn(projectIndex, columnIndex, newTitle.trim());
  }
}

function renderCreateProjectModalContent() {
  const today = new Date().toISOString().split('T')[0];

  return `
    <form id="createProjectForm" onsubmit="handleCreateProjectSubmit(event)">
      <div class="form-group">
        <label class="form-label">Project name</label>
        <input type="text" name="name" class="form-input" placeholder="e.g. Layer v2 - New UI & Realtime" required>
      </div>
      
      <div class="form-group">
        <label class="form-label">Target due date</label>
        <input type="date" name="targetDate" class="form-input" value="${today}" required>
      </div>
      
      <div class="form-group">
        <label class="form-label">Notes (optional)</label>
        <textarea name="description" class="form-textarea" placeholder="Add notes..."></textarea>
      </div>
      
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Create project</button>
      </div>
    </form>
  `;
}

function openCreateProjectModal() {
  openModal('Create new project', renderCreateProjectModalContent());
}

async function handleCreateProjectSubmit(event) {
  event.preventDefault();
  const form = event.target;
  const formData = new FormData(form);

  const name = formData.get('name');
  const targetDate = formData.get('targetDate');
  const description = formData.get('description');

  if (name.trim() && targetDate) {
    closeModal();
    await addProject({
      name: name.trim(),
      status: 'todo',
      startDate: new Date().toISOString().split('T')[0],
      targetDate,
      description: description.trim()
    });
    renderCurrentView();
  }
}

async function openProjectDetail(index) {
  selectedProjectIndex = index;

  // Update presence to show user is watching this project
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    const projects = loadProjects();
    const project = projects[index];
    if (project && project.id) {
      try {
        await window.LayerDB.updatePresence(true, project.id);
        // Start polling for member presence updates
        startPresencePolling(project.id, index);
      } catch (error) {
        console.error('Failed to update presence:', error);
      }
    }
  }

  renderCurrentView();

  // Restore sidebar collapsed state after render
  setTimeout(() => {
    restorePdSidebarState();
  }, 10);
}

// Poll for member presence updates
let presencePollInterval = null;
function startPresencePolling(projectId, projectIndex) {
  // Clear existing interval
  if (presencePollInterval) {
    clearInterval(presencePollInterval);
  }

  // Update presence immediately
  updateMemberPresence(projectId, projectIndex);

  // Poll every 5 seconds
  presencePollInterval = setInterval(() => {
    updateMemberPresence(projectId, projectIndex);
  }, 5000);
}

// Generate vibrant color based on name
function getNameColor(name) {
  // Vibrant color palette
  const colors = [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
    '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
    '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2'
  ];

  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  return colors[Math.abs(hash) % colors.length];
}

// Get initials with first letter of first and last name
function getMemberAvatarInitialsWithFullNames(member) {
  if (member === 'You' || member === getCurrentUserName()) {
    return getCurrentUserInitials();
  }

  // Split name by spaces and take first letter of first and last name
  const parts = member.trim().split(' ');
  if (parts.length >= 2) {
    return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
  }
  return member.charAt(0).toUpperCase();
}

// Helper function to get member avatar initials
function getMemberAvatarInitials(member) {
  if (member === 'You' || member === getCurrentUserName()) {
    return getCurrentUserInitials();
  }
  return member.charAt(0).toUpperCase();
}

// Helper function to get member display name
function getMemberDisplayName(member) {
  if (member === 'You' || member === getCurrentUserName()) {
    return getCurrentUserName();
  }
  return member;
}

// Helper function to get current user initials
function getCurrentUserInitials() {
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    const user = window.LayerDB.getCurrentUser();
    if (user) {
      const name = user.user_metadata?.name || user.email?.split('@')[0] || 'U';
      return name.substring(0, 2).toUpperCase();
    }
  }
  return 'U';
}

// Helper function to get current user name
function getCurrentUserName() {
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    const user = window.LayerDB.getCurrentUser();
    if (user) {
      return user.user_metadata?.name || user.email?.split('@')[0] || 'You';
    }
  }
  return 'You';
}

// Enhanced member presence update with avatar loading
async function updateMemberPresence(projectId, projectIndex) {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) return;

  try {
    const members = await window.LayerDB.getProjectMembersPresence(projectId);
    const projects = loadProjects();
    const project = projects[projectIndex];
    if (!project) return;

    const teamMembers = project.teamMembers || ['You'];

    // Update status indicators and avatars
    teamMembers.forEach(async (member, idx) => {
      const statusEl = document.getElementById(`memberStatus-${projectIndex}-${idx}`);
      const avatarEl = document.getElementById(`memberAvatar-${projectIndex}-${idx}`);

      if (avatarEl) {
        // Load Google avatar if available
        await loadMemberAvatar(member, avatarEl, projectIndex, idx);
      }

      if (statusEl) {
        // Check if member is online and watching
        const memberPresence = members.find(m => {
          // Match by email or name
          const memberEmail = m.profiles?.email;
          const memberName = m.profiles?.name;

          if (member === 'You' || member === getCurrentUserName()) {
            const currentUser = window.LayerDB.getCurrentUser();
            return currentUser && (
              memberEmail === currentUser.email ||
              memberName === currentUser.user_metadata?.name
            );
          }

          // For other members, match by name or email prefix
          return memberName === member ||
            (memberEmail && memberEmail.split('@')[0].replace(/[._]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) === member);
        });

        if (memberPresence) {
          statusEl.innerHTML = `<span class="status-dot online" title="Online - Watching"></span>`;
        } else {
          statusEl.innerHTML = `<span class="status-dot offline" title="Offline"></span>`;
        }
      }
    });
  } catch (error) {
    console.error('Failed to update member presence:', error);
  }
}

// Load member avatar from Google
async function loadMemberAvatar(memberName, avatarElement, projectIndex, memberIndex) {
  try {
    // For current user
    if (memberName === 'You' || memberName === getCurrentUserName()) {
      if (window.LayerDB && window.LayerDB.isAuthenticated()) {
        const profile = await window.LayerDB.getProfile();
        if (profile?.avatar_url) {
          avatarElement.innerHTML = `<img src="${profile.avatar_url}" alt="${memberName}" onerror="this.style.display='none';this.parentElement.innerHTML='${getMemberAvatarInitials(memberName)}';">`;
          return;
        }
      }
    }

    // For other members, try to find their profile from project members
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      // Try to get project members and find matching profile
      const projects = loadProjects();
      const project = projects[projectIndex];

      if (project && project.teamMembers) {
        // Look for member in project followers
        try {
          const followers = await window.LayerDB.getProjectFollowers(project.id);
          const memberFollower = followers.find(f => {
            const followerName = f.follower_name || f.name || '';
            const followerEmail = f.follower_email || f.email || '';
            const emailPrefix = followerEmail.split('@')[0].replace(/[._]/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

            return followerName === memberName || emailPrefix === memberName;
          });

          if (memberFollower && memberFollower.follower_avatar) {
            avatarElement.innerHTML = `<img src="${memberFollower.follower_avatar}" alt="${memberName}" onerror="this.style.display='none';this.parentElement.innerHTML='${getMemberAvatarInitials(memberName)}';">`;
            return;
          }
        } catch (followersError) {
          console.debug('Could not fetch followers for avatar:', followersError);
        }
      }
    }

    // For other members, try to find their profile from all users
    // This would require a more comprehensive user lookup
    // For now, fall back to initials
    avatarElement.innerHTML = getMemberAvatarInitials(memberName);
  } catch (error) {
    console.warn('Failed to load avatar for member:', memberName, error);
    avatarElement.innerHTML = getMemberAvatarInitials(memberName);
  }
}

function closeProjectDetail() {
  selectedProjectIndex = null;
  currentView = 'activity';
  setActiveNav('activity');

  // Stop presence polling
  if (presencePollInterval) {
    clearInterval(presencePollInterval);
    presencePollInterval = null;
  }

  // Update presence to show user is no longer watching
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    window.LayerDB.updatePresence(true, null).catch(console.error);
  }
  renderCurrentView();
}

async function handleDeleteProject(index) {
  if (confirm('Delete this project permanently?')) {
    await deleteProject(index);
    renderCurrentView();
  }
}

async function handleDeleteProjectFromDetail(index) {
  // Check if user is owner before allowing deletion
  if (!isProjectOwner(index)) {
    showNotification('Only the project owner can delete this project', 'error');
    return;
  }

  if (confirm('Delete this project permanently? This cannot be undone.')) {
    try {
      await deleteProject(index);
      showNotification('Project deleted successfully', 'success');
      closeProjectDetail();
    } catch (error) {
      console.error('Error deleting project:', error);
      showNotification(error.message || 'Failed to delete project', 'error');
    }
  }
}

function handleUpdateProjectName(index, name) {
  updateProject(index, { name: name || 'Untitled' });
}

function handleUpdateProjectDescription(index, description) {
  updateProject(index, { description: description || '' });
}

// Helper to save and restore kanban, pd-main, and tl-gantt-wrapper scroll positions
function saveKanbanScrollPosition() {
  const kanban = document.querySelector('.pd-kanban');
  const pdMain = document.querySelector('.pd-main');
  const ganttWrapper = document.querySelector('.tl-gantt-wrapper');
  return {
    kanban: kanban ? { left: kanban.scrollLeft, top: kanban.scrollTop } : null,
    pdMain: pdMain ? { left: pdMain.scrollLeft, top: pdMain.scrollTop } : null,
    ganttWrapper: ganttWrapper ? { left: ganttWrapper.scrollLeft, top: ganttWrapper.scrollTop } : null
  };
}

function restoreKanbanScrollPosition(scrollPos) {
  if (scrollPos) {
    requestAnimationFrame(() => {
      const kanban = document.querySelector('.pd-kanban');
      const pdMain = document.querySelector('.pd-main');
      const ganttWrapper = document.querySelector('.tl-gantt-wrapper');
      if (kanban && scrollPos.kanban) {
        kanban.scrollLeft = scrollPos.kanban.left;
        kanban.scrollTop = scrollPos.kanban.top;
      }
      if (pdMain && scrollPos.pdMain) {
        pdMain.scrollLeft = scrollPos.pdMain.left;
        pdMain.scrollTop = scrollPos.pdMain.top;
      }
      if (ganttWrapper && scrollPos.ganttWrapper) {
        ganttWrapper.scrollLeft = scrollPos.ganttWrapper.left;
        ganttWrapper.scrollTop = scrollPos.ganttWrapper.top;
      }
    });
  }
}

async function handleToggleProjectTask(projectIndex, columnIndex, taskIndex, event) {
  // Prevent event bubbling that could trigger tab switches or other handlers
  if (event) {
    event.stopPropagation();
  }

  const scrollPos = saveKanbanScrollPosition();

  // Save the current active tab before re-render
  const activeTab = document.querySelector('.pd-tab.active');
  const currentTabName = activeTab ? activeTab.dataset.tab : 'overview';

  const projects = loadProjects();
  const task = projects[projectIndex]?.columns[columnIndex]?.tasks[taskIndex];
  if (task) {
    task.done = !task.done;
    saveProjects(projects);

    // Sync to DB if authenticated
    if (window.LayerDB && window.LayerDB.isAuthenticated() && projects[projectIndex].id) {
      try {
        await window.LayerDB.updateProject(projects[projectIndex].id, { columns: projects[projectIndex].columns });
      } catch (error) {
        console.error('Failed to sync task toggle to database:', error);
      }
    }
  }

  // Re-render the current view
  renderCurrentView();

  // Restore the active tab if we're in project detail view and timeline was active
  if (currentTabName === 'timeline' && typeof switchProjectTab === 'function') {
    // Use requestAnimationFrame to ensure DOM is ready
    requestAnimationFrame(() => {
      switchProjectTab('timeline', projectIndex);
      restoreKanbanScrollPosition(scrollPos);
    });
  } else {
    restoreKanbanScrollPosition(scrollPos);
  }
}

function handleDeleteProjectTask(projectIndex, columnIndex, taskIndex, event) {
  // Prevent event bubbling that could trigger tab switches
  if (event) {
    event.stopPropagation();
  }

  // Save the current active tab before re-render
  const activeTab = document.querySelector('.pd-tab.active');
  const currentTabName = activeTab ? activeTab.dataset.tab : 'overview';

  if (confirm('Delete this task?')) {
    const scrollPos = saveKanbanScrollPosition();
    const projects = loadProjects();
    if (projects[projectIndex]?.columns[columnIndex]?.tasks[taskIndex]) {
      projects[projectIndex].columns[columnIndex].tasks.splice(taskIndex, 1);
      saveProjects(projects);
    }
    renderCurrentView();
    restoreKanbanScrollPosition(scrollPos);

    // Restore the active tab if we're in project detail view and timeline was active
    if (currentTabName === 'timeline' && typeof switchProjectTab === 'function') {
      requestAnimationFrame(() => {
        switchProjectTab('timeline', projectIndex);
      });
    }
  }
}

function handleAddProjectTaskKeypress(event, projectIndex, columnIndex) {
  // Prevent event bubbling that could trigger tab switches
  if (event) {
    event.stopPropagation();
  }

  // Save the current active tab before re-render
  const activeTab = document.querySelector('.pd-tab.active');
  const currentTabName = activeTab ? activeTab.dataset.tab : 'overview';

  if (event.key === 'Enter') {
    const input = event.target;
    const title = input.value.trim();
    if (title) {
      const scrollPos = saveKanbanScrollPosition();
      addTaskToColumn(projectIndex, columnIndex, title);
      input.value = '';
      renderCurrentView();
      restoreKanbanScrollPosition(scrollPos);

      // Restore the active tab if we're in project detail view and timeline was active
      if (currentTabName === 'timeline' && typeof switchProjectTab === 'function') {
        requestAnimationFrame(() => {
          switchProjectTab('timeline', projectIndex);
        });
      }
    }
  }
}

function handleAddTaskToColumn(projectIndex, columnIndex, event) {
  // Prevent event bubbling that could trigger tab switches
  if (event) {
    event.stopPropagation();
  }

  // Save the current active tab before re-render
  const activeTab = document.querySelector('.pd-tab.active');
  const currentTabName = activeTab ? activeTab.dataset.tab : 'overview';

  // Find the column body where the input should be added
  const columnElement = event.target.closest('.tl-kanban-column');
  const taskListContainer = columnElement.querySelector('.tl-kanban-col-tasks');
  
  // Clear any existing input fields
  const existingInputs = taskListContainer.querySelectorAll('.tl-kanban-task-input');
  existingInputs.forEach(input => input.remove());
  
  // Create input field for task title
  const inputField = document.createElement('input');
  inputField.type = 'text';
  inputField.placeholder = 'Enter task title...';
  inputField.className = 'tl-kanban-task-input';
  inputField.style.width = 'calc(100% - 20px)';
  inputField.style.padding = '8px';
  inputField.style.margin = '10px';
  inputField.style.border = '1px solid var(--border)';
  inputField.style.borderRadius = '6px';
  inputField.style.backgroundColor = 'var(--background)';
  inputField.style.color = 'var(--foreground)';
  
  // Focus the input field
  inputField.focus();
  
  // Handle input submission
  inputField.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
      const title = inputField.value;
      if (title && title.trim()) {
        const scrollPos = saveKanbanScrollPosition ? saveKanbanScrollPosition() : null;
        addTaskToColumn(projectIndex, columnIndex, title.trim());
        renderCurrentView();
        if (scrollPos && restoreKanbanScrollPosition) {
          restoreKanbanScrollPosition(scrollPos);
        }
        
        // Restore the active tab if we're in project detail view and timeline was active
        if (currentTabName === 'timeline' && typeof switchProjectTab === 'function') {
          requestAnimationFrame(() => {
            switchProjectTab('timeline', projectIndex);
          });
        }
      } else {
        // Remove the input if empty
        taskListContainer.removeChild(inputField);
      }
    }
  });
  
  // Add cancel on blur if empty
  inputField.addEventListener('blur', function() {
    if (!inputField.value.trim()) {
      taskListContainer.removeChild(inputField);
    }
  });
  
  // Insert input field at the top of the task list
  taskListContainer.insertBefore(inputField, taskListContainer.firstChild);
}

function showComingSoonToast() {
  // Create toast element
  const toast = document.createElement('div');
  toast.textContent = 'Sorryyy this feature is not available at the moment. Coming soon...❤';
  toast.style.position = 'fixed';
  toast.style.bottom = '24px';
  toast.style.right = '24px';
  toast.style.padding = '12px 20px';
  toast.style.backgroundColor = 'var(--card)';
  toast.style.color = 'var(--foreground)';
  toast.style.border = '1px solid var(--border)';
  toast.style.borderRadius = '12px';
  toast.style.boxShadow = '0 10px 25px rgba(0,0,0,0.2)';
  toast.style.fontSize = '14px';
  toast.style.zIndex = '1000';
  toast.style.opacity = '0';
  toast.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
  toast.style.transform = 'translateY(20px)';

  document.body.appendChild(toast);

  // Fade in
  setTimeout(() => {
    toast.style.opacity = '1';
    toast.style.transform = 'translateY(0)';
  }, 100);

  // Auto remove after 4 seconds
  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(20px)';
    setTimeout(() => toast.remove(), 300);
  }, 4000);
}



/* ============================================
   Layer - Teams View (ClickUp-Inspired Chat & Collaboration)
   ============================================ */

// Team View State
let teamCurrentChannel = 'general';
let teamCurrentTab = 'chat';
let teamChannels = [
  { id: 'general', name: 'General', type: 'channel', unread: 0, icon: 'hash' },
  { id: 'welcome', name: 'Welcome', type: 'channel', unread: 2, icon: 'hash' },
  { id: 'announcements', name: 'Announcements', type: 'channel', unread: 0, icon: 'megaphone' }
];
let teamDirectMessages = [];
let teamGroups = [];
let teamMessages = {
  'general': [
    { id: 1, user: 'System', avatar: 'S', content: 'Welcome to #General! This is the main channel for team discussions.', time: '10:00 AM', isSystem: true }
  ],
  'welcome': [
    { id: 1, user: 'System', avatar: 'S', content: 'Welcome to Layer! Start chatting with your team.', time: '9:00 AM', isSystem: true }
  ],
  'announcements': []
};
let teamFollowers = [
  { id: 'f-1', name: 'You', avatar: 'YU', isOwner: true }
];
let pendingFollowRequests = [];

function renderTeamView() {
  // Clean up any existing subscriptions first (in case view is re-rendered)
  if (window.cleanupTeamMembersSubscription) {
    window.cleanupTeamMembersSubscription();
  }

  // Render immediately with default/cached data for instant loading
  const initialHTML = `
    <div class="team-chat-layout">
      <!-- Chat Sidebar -->
      <aside class="team-chat-sidebar">
        <div class="team-chat-sidebar-header">
          <div class="team-chat-title">
            <span>Chat</span>
          </div>
          <div class="team-chat-header-actions">
            <button class="team-icon-btn" onclick="openTeamSearchModal()" title="Search">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/>
              </svg>
            </button>
            <div class="team-create-dropdown-wrapper">
              <button class="team-icon-btn team-create-btn" onclick="toggleTeamCreateDropdown()" title="Create">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                  <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                </svg>
                <svg class="dropdown-chevron-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M6 9l6 6 6-6"/>
                </svg>
              </button>
              <div class="team-create-dropdown" id="teamCreateDropdown">
                <button class="team-create-item" onclick="openCreateMessageModal(); closeTeamCreateDropdown();">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                  </svg>
                  <div>
                    <span class="create-item-title">Message</span>
                    <span class="create-item-desc">Start a direct conversation</span>
                  </div>
                </button>
                <button class="team-create-item" onclick="openCreateChannelModal(); closeTeamCreateDropdown();">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 9h16M4 15h16M10 3L8 21M16 3l-2 18"/>
                  </svg>
                  <div>
                    <span class="create-item-title">Channel</span>
                    <span class="create-item-desc">Conversations on specific topics</span>
                  </div>
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Channel List -->
        <div class="team-chat-list">
          ${teamChannels.map(channel => `
            <button class="team-chat-item ${teamCurrentChannel === channel.id ? 'active' : ''}" onclick="selectTeamChannel('${channel.id}')">
              <div class="team-chat-item-icon ${channel.icon === 'megaphone' ? 'megaphone' : ''}">
                ${channel.icon === 'hash' ? '#' :
      channel.icon === 'megaphone' ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;"><path d="m3 11 18-5v12L3 14v-3z"/><path d="M11.6 16.8a3 3 0 1 1-5.8-1.6"/></svg>' : '#'}
              </div>
              <span class="team-chat-item-name">${channel.name}</span>
              ${channel.unread > 0 ? `<span class="team-chat-unread">${channel.unread}</span>` : ''}
            </button>
          `).join('')}
          
          <!-- Direct Messages Section -->
          <div class="team-chat-section-divider">
            <span>Direct Messages</span>
            <button class="team-icon-btn-sm" onclick="openCreateMessageModal()" title="New Message">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14M5 12h14"/>
              </svg>
            </button>
          </div>
          
          ${teamDirectMessages.map(dm => `
            <button class="team-chat-item dm ${teamCurrentChannel === dm.id ? 'active' : ''}" 
              onclick="selectTeamChannel('${dm.id}')"
              oncontextmenu="showDMContextMenu(event, '${dm.id}', '${dm.partnerId}', '${dm.name.replace(/'/g, "\\'")}')">
              <div class="team-dm-avatar ${dm.status}">
                ${dm.avatar && dm.avatar.includes('/') ?
          `<img src="${dm.avatar}" alt="${dm.name}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">` :
          `<span>${dm.avatar || dm.name.charAt(0)}</span>`
        }
                <span class="team-dm-status-dot"></span>
              </div>
              <span class="team-chat-item-name">${dm.name}</span>
              ${dm.unread > 0 ? `<span class="team-chat-unread">${dm.unread}</span>` : ''}
            </button>
          `).join('')}
          
          <!-- Groups Section -->
          <div class="team-chat-section-divider">
            <span>Groups</span>
            <button class="team-icon-btn-sm" onclick="openCreateGroupModal()" title="Create Group">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14M5 12h14"/>
              </svg>
            </button>
          </div>
          
          ${teamGroups.map(group => `
            <button class="team-chat-item group" onclick="selectTeamGroup('${group.id}')">
              <div class="team-group-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                  <circle cx="9" cy="7" r="4"/>
                  <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                  <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                </svg>
              </div>
              <div class="team-group-info">
                <span class="team-chat-item-name">${group.name}</span>
                ${group.linkedProject ? `<span class="team-group-project">🔗 ${group.linkedProject}</span>` : ''}
              </div>
              <span class="team-group-members">${group.members}</span>
            </button>
          `).join('')}
        </div>
      </aside>
      
      <!-- Main Chat Area -->
      <main class="team-chat-main">
        ${renderTeamChatHeader()}
        ${renderTeamChatContent()}
        ${renderTeamMessageInput()}
      </main>
      
      <!-- Members/Followers Panel -->
      <aside class="team-members-panel" id="teamMembersPanel">
        <div class="team-panel-header">
          <span>Team Members</span>
          <button class="team-panel-close" onclick="toggleTeamMembersPanel()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>
        <div class="team-loading-container">
          <div class="team-logo-loader">
            <svg class="logo-loader-animated" width="64" height="64" viewBox="0 0 128 128" fill="none" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <linearGradient id="teamLogoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                  <stop offset="0%" stop-color="#7c3aed" />
                  <stop offset="100%" stop-color="#5b21b6" />
                </linearGradient>
              </defs>
              <rect class="logo-layer logo-layer-1" x="38" y="38" width="52" height="52" rx="16" fill="url(#teamLogoGradient)" opacity="0.28" />
              <rect class="logo-layer logo-layer-2" x="38" y="54" width="52" height="36" rx="14" fill="url(#teamLogoGradient)" opacity="0.55" />
              <rect class="logo-layer logo-layer-3" x="38" y="70" width="52" height="20" rx="10" fill="url(#teamLogoGradient)" />
              <rect class="logo-layer logo-layer-4" x="38" y="38" width="20" height="52" rx="10" fill="url(#teamLogoGradient)" />
            </svg>
          </div>
          <p class="team-loading-text">Loading team members...</p>
        </div>
      </aside>
    </div>
  `;

  // Load async data in the background and update UI when ready
  setTimeout(async () => {
    try {
      // Load pending follow requests if user is authenticated
      if (window.LayerDB && window.LayerDB.isAuthenticated()) {
        try {
          pendingFollowRequests = await window.LayerDB.getPendingFollowRequests();
          console.log('Loaded pending follow requests:', pendingFollowRequests);
        } catch (error) {
          console.error('Failed to load pending follow requests:', error);
          pendingFollowRequests = [];
        }
      } else {
        console.log('User not authenticated, clearing pending requests');
        pendingFollowRequests = [];
      }

      // Load team members panel HTML (await the async function)
      const teamMembersPanelHTML = await renderTeamMembersPanel();

      // Load Direct Messages from Supabase
      if (window.LayerDB && window.LayerDB.isAuthenticated()) {
        try {
          const dms = await window.LayerDB.getDirectMessages();
          // Only update if we got results, otherwise might be offline or error
          if (dms) {
            teamDirectMessages = dms;

            // 🚀 BACKGROUND LOAD: Preload all DM messages for instant access
            console.log('🔄 Starting background load of all DM messages...');
            preloadAllDMMessages();
          }
        } catch (error) {
          console.error('Failed to load DMs:', error);
        }
      }

      // Update the team members panel with loaded data
      const teamMembersPanel = document.getElementById('teamMembersPanel');
      if (teamMembersPanel && currentView === 'team') {
        teamMembersPanel.innerHTML = teamMembersPanelHTML;
      }

      // Re-render sidebar to show loaded DMs
      if (currentView === 'team') {
        updateTeamSidebar();
      }

      // Update active states for chat items after rendering
      updateTeamChatArea();

      // Initialize real-time subscription for team members
      if (window.initializeTeamMembersSubscription) {
        window.initializeTeamMembersSubscription();
      }

      // Initialize global DM listener
      if (typeof setupGlobalDMListener === 'function') {
        setupGlobalDMListener();
      }

      // Setup realtime subscriptions for all DM conversations
      if (typeof setupAllDMSubscriptions === 'function') {
        await setupAllDMSubscriptions();
      }

      // Start global background polling for all DM conversations
      startGlobalDMPolling();

      // Initialize Presence System (Heartbeat & UI Updates)
      if (typeof initializePresenceSystem === 'function') {
        await initializePresenceSystem();
        // Delay fetch slightly to ensure DOM is ready
        setTimeout(fetchInitialPresence, 500);
      }

      // Request notification permissions
      requestNotificationPermission();
    } catch (error) {
      console.error('Error loading team data in background:', error);
    }
  }, 0);

  return initialHTML;
}

// Helper to update just the sidebar list without full re-render
function updateTeamSidebar() {
  const sidebarList = document.querySelector('.team-chat-list');
  if (sidebarList) {
    sidebarList.innerHTML = `
          ${teamChannels.map(channel => `
            <button class="team-chat-item ${teamCurrentChannel === channel.id ? 'active' : ''}" onclick="selectTeamChannel('${channel.id}')">
              <div class="team-chat-item-icon ${channel.icon === 'megaphone' ? 'megaphone' : ''}">
                ${channel.icon === 'hash' ? '#' :
        channel.icon === 'megaphone' ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;"><path d="m3 11 18-5v12L3 14v-3z"/><path d="M11.6 16.8a3 3 0 1 1-5.8-1.6"/></svg>' : '#'}
              </div>
              <span class="team-chat-item-name">${channel.name}</span>
              ${channel.unread > 0 ? `<span class="team-chat-unread">${channel.unread}</span>` : ''}
            </button>
          `).join('')}
          
          <!-- Direct Messages Section -->
          <div class="team-chat-section-divider">
            <span>Direct Messages</span>
            <button class="team-icon-btn-sm" onclick="openCreateMessageModal()" title="New Message">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14M5 12h14"/>
              </svg>
            </button>
          </div>
          
          ${teamDirectMessages.map(dm => `
            <button class="team-chat-item dm ${teamCurrentChannel === dm.id ? 'active' : ''}" 
              onclick="selectTeamChannel('${dm.id}')"
              oncontextmenu="showDMContextMenu(event, '${dm.id}', '${dm.partnerId}', '${dm.name.replace(/'/g, "\\'")}')">
              <div class="team-dm-avatar ${dm.status}">
                ${(dm.avatar && dm.avatar.includes('/')) || dm.avatarUrl ?
            `<img src="${dm.avatarUrl || dm.avatar}" alt="${dm.name}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">` :
            `<span>${dm.avatar || dm.name.charAt(0)}</span>`
          }
                <span class="team-dm-status-dot"></span>
              </div>
              <span class="team-chat-item-name">${dm.name}</span>
              ${dm.unread > 0 ? `<span class="team-chat-unread">${dm.unread}</span>` : ''}
            </button>
          `).join('')}
          
          <!-- Groups Section -->
          <div class="team-chat-section-divider">
            <span>Groups</span>
            <button class="team-icon-btn-sm" onclick="openCreateGroupModal()" title="Create Group">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14M5 12h14"/>
              </svg>
            </button>
          </div>
          
          ${teamGroups.map(group => `
            <button class="team-chat-item group" onclick="selectTeamGroup('${group.id}')">
              <div class="team-group-icon">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                  <circle cx="9" cy="7" r="4"/>
                  <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                  <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                </svg>
              </div>
              <div class="team-group-info">
                <span class="team-chat-item-name">${group.name}</span>
                ${group.linkedProject ? `<span class="team-group-project">🔗 ${group.linkedProject}</span>` : ''}
              </div>
              <span class="team-group-members">${group.members}</span>
            </button>
          `).join('')}
    `;
  }
}

function renderTeamChatHeader() {
  const channel = teamChannels.find(c => c.id === teamCurrentChannel) ||
    teamDirectMessages.find(d => d.id === teamCurrentChannel);
  const channelName = channel ? channel.name : 'General';
  const isChannel = channel?.type === 'channel';

  return `
    <header class="team-chat-header">
      <div class="team-chat-header-left">
        <div class="team-channel-name">
          ${isChannel ? '#' : ''} ${channelName}
        </div>
        <button class="team-header-action-btn" title="More options">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/>
          </svg>
        </button>
        <button class="team-header-action-btn star" title="Star channel">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
          </svg>
        </button>
      </div>
      
      <nav class="team-chat-tabs">
        <button class="team-tab ${teamCurrentTab === 'chat' ? 'active' : ''}" onclick="setTeamTab('chat')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <path d="M4 9h16M4 15h16M10 3L8 21M16 3l-2 18"/>
          </svg>
          Channel
        </button>
        <button class="team-tab ${teamCurrentTab === 'list' ? 'active' : ''}" onclick="setTeamTab('list')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/>
            <line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/>
          </svg>
          List
        </button>
        <button class="team-tab ${teamCurrentTab === 'board' ? 'active' : ''}" onclick="setTeamTab('board')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/>
          </svg>
          Board
        </button>
        <button class="team-tab ${teamCurrentTab === 'calendar' ? 'active' : ''}" onclick="setTeamTab('calendar')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/>
          </svg>
          Calendar
        </button>
        <button class="team-tab ${teamCurrentTab === 'whiteboard' ? 'active' : ''}" onclick="setTeamTab('whiteboard')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/>
          </svg>
          Whiteboard
        </button>
        <button class="team-tab add-view" onclick="addTeamView()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
            <path d="M12 5v14M5 12h14"/>
          </svg>
          View
        </button>
      </nav>
      
      <div class="team-chat-header-right">
        <button class="team-header-btn" onclick="toggleAutomation()" title="Automate">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
            <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
          </svg>
          <span class="badge-count">1</span>
        </button>
        <button class="team-header-btn ai-btn" onclick="openTeamAI()" title="Ask AI">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
            <path d="M12 3L14.5 9L21 11.5L14.5 14L12 20L9.5 14L3 11.5L9.5 9L12 3Z"/>
          </svg>
          Ask AI
        </button>
        <button class="team-header-btn share-btn" onclick="openTeamShareModal()" title="Share">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
            <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/>
            <polyline points="16 6 12 2 8 6"/>
            <line x1="12" y1="2" x2="12" y2="15"/>
          </svg>
          Share
        </button>
        <button class="team-icon-btn" onclick="toggleTeamMembersPanel()" title="Toggle members panel">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
            <circle cx="9" cy="7" r="4"/>
            <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
            <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
          </svg>
        </button>
      </div>
    </header>
  `;
}

function renderTeamChatContent() {
  if (teamCurrentTab === 'list') {
    return renderTeamListTabContent();
  }

  const messages = teamMessages[teamCurrentChannel] || [];
  const channel = teamChannels.find(c => c.id === teamCurrentChannel) ||
    teamDirectMessages.find(d => d.id === teamCurrentChannel);
  const channelName = channel ? channel.name : 'General';
  const isDM = channel?.type === 'dm' || teamCurrentChannel?.startsWith('dm-');

  if (messages.length === 0) {
    // For DM conversations, show a simple welcome message
    if (isDM) {
      return `
        <div class="team-chat-content">
          <div class="team-chat-welcome">
            <div class="team-welcome-main" style="text-align: center;">
              <h2>Direct Message with ${channelName}</h2>
              <p>Start your conversation by sending a message below.</p>
            </div>
          </div>
        </div>
      `;
    }

    // For channels, show the full welcome screen with all features
    return `
      <div class="team-chat-content">
        <div class="team-chat-welcome">
          <div class="team-welcome-bookmark">
            <div class="bookmark-icons">
              <span class="bookmark-icon green">📌</span>
              <span class="bookmark-icon orange">📝</span>
            </div>
            <span>Bookmark tasks, add notes, and more</span>
          </div>
          
          <div class="team-welcome-main">
            <h2>Chat in #${channelName}</h2>
            <p>Collaborate seamlessly across tasks and conversations. Start chatting with your team or connect tasks to stay on top of your work.</p>
            
            <div class="team-welcome-actions">
              <button class="team-welcome-btn outline" onclick="openAddPeopleModal()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
                  <path d="M12 5v14M5 12h14"/>
                </svg>
                Add People
              </button>
              <button class="team-welcome-btn outline slack" onclick="importFromSlack()">
                <svg viewBox="0 0 24 24" fill="currentColor" style="width:18px;height:18px;">
                  <path d="M5.042 15.165a2.528 2.528 0 0 1-2.52 2.523A2.528 2.528 0 0 1 0 15.165a2.527 2.527 0 0 1 2.522-2.52h2.52v2.52zM6.313 15.165a2.527 2.527 0 0 1 2.521-2.52 2.527 2.527 0 0 1 2.521 2.52v6.313A2.528 2.528 0 0 1 8.834 24a2.528 2.528 0 0 1-2.521-2.522v-6.313zM8.834 5.042a2.528 2.528 0 0 1-2.521-2.52A2.528 2.528 0 0 1 8.834 0a2.528 2.528 0 0 1 2.521 2.522v2.52H8.834zM8.834 6.313a2.528 2.528 0 0 1 2.521 2.521 2.528 2.528 0 0 1-2.521 2.521H2.522A2.528 2.528 0 0 1 0 8.834a2.528 2.528 0 0 1 2.522-2.521h6.312zM18.956 8.834a2.528 2.528 0 0 1 2.522-2.521A2.528 2.528 0 0 1 24 8.834a2.528 2.528 0 0 1-2.522 2.521h-2.522V8.834zM17.688 8.834a2.528 2.528 0 0 1-2.523 2.521 2.527 2.527 0 0 1-2.52-2.521V2.522A2.527 2.527 0 0 1 15.165 0a2.528 2.528 0 0 1 2.523 2.522v6.312zM15.165 18.956a2.528 2.528 0 0 1 2.523 2.522A2.528 2.528 0 0 1 15.165 24a2.527 2.527 0 0 1-2.52-2.522v-2.522h2.52zM15.165 17.688a2.527 2.527 0 0 1-2.52-2.523 2.526 2.526 0 0 1 2.52-2.52h6.313A2.527 2.527 0 0 1 24 15.165a2.528 2.528 0 0 1-2.522 2.523h-6.313z"/>
                </svg>
                Import from Slack
              </button>
            </div>
            
            <div class="team-welcome-features">
              <button class="team-feature-card" onclick="openTrackTasksModal()">
                <div class="feature-icon blue">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <line x1="3" y1="9" x2="21" y2="9"/>
                    <line x1="9" y1="21" x2="9" y2="9"/>
                  </svg>
                </div>
                <div class="feature-text">
                  <span class="feature-title">Track Tasks</span>
                  <span class="feature-desc">Manage tasks, bugs, people, and more</span>
                </div>
              </button>
              
              <button class="team-feature-card" onclick="openAddDocModal()">
                <div class="feature-icon green">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="16" y1="13" x2="8" y2="13"/>
                    <line x1="16" y1="17" x2="8" y2="17"/>
                  </svg>
                </div>
                <div class="feature-text">
                  <span class="feature-title">Add Doc</span>
                  <span class="feature-desc">Take notes or create detailed documents</span>
                </div>
              </button>
              
            </div>
          </div>
        </div>
      </div>
    `;
  }

  return `
    <div class="team-chat-content">
      <div class="team-messages-list">
        ${messages.map(msg => `
          <div class="team-message ${msg.isSystem ? 'system' : ''}" data-message-id="${msg.id}" oncontextmenu="showMessageContextMenu(event, '${msg.id}', '${msg.user_id}', '${msg.channel_type}')">
            <div class="team-message-avatar">
              ${(msg.avatar && msg.avatar.toString().includes('/')) || msg.avatarUrl ?
      `<img src="${msg.avatarUrl || msg.avatar}" alt="${msg.user}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">` :
      `<span>${msg.initial || msg.avatar || msg.user.charAt(0)}</span>`
    }
            </div>
            <div class="team-message-body">
              <div class="team-message-header">
                <span class="team-message-user">${msg.user}</span>
                <span class="team-message-time">${msg.time}</span>
              </div>
              <div class="team-message-content">
                ${msg.content}
                <button class="team-message-reaction-trigger" onclick="toggleReactionPicker('${msg.id}')" title="Add reaction">
                  😊
                </button>
                <div class="team-reaction-picker" id="reaction-picker-${msg.id}">
                  <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '👍')">👍</button>
                  <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '❤️')">❤️</button>
                  <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '😂')">😂</button>
                  <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '😮')">😮</button>
                  <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '😢')">😢</button>
                  <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '😡')">😡</button>
                  <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '🎉')">🎉</button>
                  <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '🔥')">🔥</button>
                </div>
                ${msg.reactions && Object.keys(msg.reactions).length > 0 ? `
                  <div class="team-message-reactions">
                    ${Object.entries(msg.reactions).map(([emoji, users]) => {
      const currentUser = window.LayerDB?.getCurrentUser();
      const hasReacted = users.includes(currentUser?.id);
      return `
                        <button class="team-message-reaction ${hasReacted ? 'reacted' : ''}" 
                                onclick="addReaction('${msg.id}', '${emoji}')"
                                title="${users.length > 0 ? `${users.length} user${users.length > 1 ? 's' : ''} reacted` : 'React'}">
                          <span class="team-message-reaction-emoji">${emoji}</span>
                          <span class="team-message-reaction-count">${users.length}</span>
                        </button>
                      `;
    }).join('')}
                  </div>
                ` : ''}
              </div>
            </div>
          </div>
        `).join('')}
      </div>
    </div>
  `;
}

function renderTeamMessageInput() {
  const channel = teamChannels.find(c => c.id === teamCurrentChannel);
  const channelName = channel ? channel.name : 'General';

  return `
    <div class="team-message-input-container">
      <div class="team-message-input-wrapper">
        <div class="team-input-toolbar">
          <button class="toolbar-btn add" title="Add attachment">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 5v14M5 12h14"/>
            </svg>
          </button>
          <div class="toolbar-divider"></div>
          <div class="message-type-dropdown">
            <button class="toolbar-btn message-type" onclick="toggleMessageTypeDropdown()">
              Message
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;">
                <path d="M6 9l6 6 6-6"/>
              </svg>
            </button>
          </div>
          <button class="toolbar-btn" title="Attach file">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/>
            </svg>
          </button>
          <button class="toolbar-btn" title="Mention">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="4"/><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"/>
            </svg>
          </button>
          <button class="toolbar-btn" title="Emoji">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/><path d="M8 14s1.5 2 4 2 4-2 4-2"/><line x1="9" y1="9" x2="9.01" y2="9"/><line x1="15" y1="9" x2="15.01" y2="9"/>
            </svg>
          </button>
          <button class="toolbar-btn" title="GIF">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/>
            </svg>
          </button>
          <button class="toolbar-btn" title="File">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/>
            </svg>
          </button>
        </div>
        
        <div class="team-input-area">
          <input type="text" class="team-message-input" placeholder="Write to ${channelName}, press 'space' for AI, '/' for commands" id="teamMessageInput" onkeydown="handleTeamMessageKeydown(event)">
        </div>
        
        <div class="team-input-actions">
          <button class="team-send-btn" onclick="sendTeamMessage()" title="Send message">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  `;
}

async function renderTeamMembersPanel() {
  // Load real team members data
  let realFollowers = [];
  let realPendingRequests = [];
  let currentUserInfo = null;

  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      const currentUser = window.LayerDB.getCurrentUser();
      currentUserInfo = {
        id: currentUser?.id,
        email: currentUser?.email,
        name: currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0] || 'User',
        avatar_url: currentUser?.user_metadata?.avatar_url
      };

      console.log('🔍 Current user info:', currentUserInfo);

      const followers = await window.LayerDB.getFollowers();
      console.log('🔍 Raw followers data from DB:', followers);

      realFollowers = followers.filter(f => f.status === 'accepted');
      console.log('🔍 Filtered accepted followers:', realFollowers);

      realPendingRequests = await window.LayerDB.getPendingFollowRequests();
      console.log('🔍 Pending follow requests:', realPendingRequests);
    } catch (error) {
      console.error('Error loading team members:', error);
    }
  }

  // Create the current user as the owner
  let ownerItem = [];
  if (currentUserInfo) {
    ownerItem = [{
      id: 'current-user',
      name: currentUserInfo.name,
      email: currentUserInfo.email,
      avatar_url: currentUserInfo.avatar_url,
      isOwner: true
    }];
  } else {
    // Fallback for unauthenticated users
    ownerItem = [{
      id: 'f-1',
      name: 'You',
      avatar: 'YU',
      isOwner: true
    }];
  }

  // Combine owner with real followers (properly extract the OTHER person's info)
  const teamMembers = [];

  // Add the current user as owner
  teamMembers.push(...ownerItem);

  // Process each follower relationship to extract the OTHER person
  const seenUserIds = new Set([currentUserInfo?.id]); // Track to avoid duplicates

  realFollowers.forEach(f => {
    // Determine who the "other" person is in this relationship
    let otherPerson = null;

    if (f.follower_id === currentUserInfo?.id) {
      // Current user is the follower, so show the person they're following
      otherPerson = {
        id: f.following_id,
        name: f.following_profile?.name || f.following_profile?.email?.split('@')[0] || 'Unknown',
        email: f.following_profile?.email || '',
        avatar_url: f.following_profile?.avatar_url || '',
        status: f.status
      };
    } else if (f.following_id === currentUserInfo?.id) {
      // Current user is being followed, so show the follower
      otherPerson = {
        id: f.follower_id,
        name: f.follower_profile?.name || f.follower_profile?.email?.split('@')[0] || 'Unknown',
        email: f.follower_profile?.email || '',
        avatar_url: f.follower_profile?.avatar_url || '',
        status: f.status
      };
    }

    // Add to team members if we haven't seen this user yet
    if (otherPerson && otherPerson.id && !seenUserIds.has(otherPerson.id)) {
      seenUserIds.add(otherPerson.id);
      teamMembers.push(otherPerson);
      console.log('✅ Added team member:', otherPerson);
    } else if (otherPerson) {
      console.log('⚠️ Skipped duplicate or invalid user:', otherPerson);
    }
  });

  const displayFollowers = teamMembers;
  console.log('🔍 Final displayFollowers array:', displayFollowers);

  const displayPending = realPendingRequests.length > 0 ? realPendingRequests : pendingFollowRequests;

  return `
    <div class="team-panel-header">
      <span>Team Members</span>
      <button class="team-panel-close" onclick="toggleTeamMembersPanel()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    
    <div class="team-panel-tabs">
      <button class="team-panel-tab" onclick="toggleInvitesPanel(this)" style="position:relative;">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
          <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
          <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
        </svg>
        Invites <span class="tab-count" id="invitesCount">${realPendingRequests.length}</span>
      </button>
    </div>
    
    <!-- Invites dropdown (hidden by default) -->
    <div class="team-invites-dropdown" id="invitesDropdownPanel" style="display:none;">
      <div class="invites-dropdown-header">
        <span>Pending Invitations</span>
      </div>
      <div class="invites-dropdown-list" id="invitesDropdownList">
        ${realPendingRequests.length === 0 ? `
          <div class="invites-empty">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:32px;height:32px;color:var(--muted-foreground);margin-bottom:8px;">
              <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/>
              <path d="M13.73 21a2 2 0 0 1-3.46 0"/>
            </svg>
            <p style="color:var(--muted-foreground);font-size:13px;">No pending invitations</p>
          </div>
        ` : realPendingRequests.map(request => {
    const profile = request.follower_profile || {};
    const name = profile.name || profile.email?.split('@')[0] || 'Unknown';
    const email = profile.email || '';
    const initial = name.charAt(0).toUpperCase();

    return `
          <div class="invite-dropdown-item" data-request-id="${request.id}">
            <div class="invite-dropdown-avatar">
              ${profile.avatar_url ? `<img src="${profile.avatar_url}" alt="${name}">` : `<span>${initial}</span>`}
            </div>
            <div class="invite-dropdown-info">
              <span class="invite-dropdown-name">${name}</span>
              <span class="invite-dropdown-email">${email}</span>
              <span class="invite-dropdown-time">${formatTimeAgo(request.created_at)}</span>
            </div>
            <div class="invite-dropdown-actions">
              <button class="invite-accept-btn" onclick="event.stopPropagation(); acceptInvite('${request.follower_id}')" title="Accept">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" style="width:14px;height:14px;"><path d="M5 13l4 4L19 7"/></svg>
                Accept
              </button>
              <button class="invite-reject-btn" onclick="event.stopPropagation(); rejectInvite('${request.follower_id}')" title="Decline">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;"><path d="M18 6L6 18M6 6l12 12"/></svg>
              </button>
            </div>
          </div>
          `;
  }).join('')}
      </div>
    </div>
    
    <div class="team-panel-search">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
        <circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/>
      </svg>
      <input type="text" placeholder="Search people or invite by email" class="team-search-input" onkeyup="searchTeamMembers(this.value)">
    </div>
    
    <div class="team-panel-section">
      <span class="section-label">TEAM MEMBERS</span>
      <div class="team-add-people-dropdown-wrapper">
        <button class="team-add-people-btn" onclick="toggleAddPeopleDropdown()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <path d="M12 5v14M5 12h14"/>
          </svg>
          Add People
        </button>
        <div class="team-add-people-dropdown" id="addPeopleDropdown" style="display: none;">
          <div class="dropdown-content">
            <div class="dropdown-header">
              <h4>Add People to Team</h4>
              <button class="dropdown-close" onclick="toggleAddPeopleDropdown()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
                  <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
              </button>
            </div>
            <div class="dropdown-body">
              <div class="form-group">
                <label>Email Address</label>
                <input type="email" id="dropdownInviteEmail" placeholder="colleague@example.com" class="form-input" autocomplete="email">
                <small class="form-help">Enter the email address of a registered user to add them</small>
              </div>
              <div class="form-group">
                <label>Custom Message (Optional)</label>
                <textarea id="dropdownInviteMessage" placeholder="Hey! I'd like to collaborate with you on Layer..." class="form-textarea" rows="2"></textarea>
              </div>
              <div class="form-actions">
                <button class="btn btn-primary" onclick="addPeopleFromDropdown()">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:6px;">
                    <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
                  </svg>
                  Send Invitation
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="team-followers-list" id="teamMembersList">
      ${displayFollowers.map(f => {
    const email = f.following_email || f.follower_email || f.email || '';
    const name = f.following_name || f.follower_name || f.name || email.split('@')[0] || 'Unknown';
    const avatar = f.following_avatar || f.follower_avatar || f.avatar_url || '';
    const initial = name.charAt(0).toUpperCase();
    const userId = f.id || '';

    // Determine status (mock logic for now: owner is online, others offline unless data says otherwise)
    // If we had real presence data, we'd use f.presence_status here
    const isOnline = f.isOwner || f.status === 'online';
    const statusClass = isOnline ? 'online' : 'offline';

    // Get last active status for the user
    const presenceData = userPresenceMap.get(userId);
    const lastSeen = presenceData?.last_seen ? new Date(presenceData.last_seen).toLocaleDateString() : 'Recently';
    const isActive = presenceData?.is_online;
    
    // Determine status text based on presence
    const statusText = isActive ? 'Online' : `Last seen: ${lastSeen}`;
    const statusClassFinal = isActive ? 'online' : 'offline';

    return `
          <div class="team-follower-item" 
               data-email="${email}" 
               data-user-id="${userId}"
               data-user-name="${name}"
               ${!f.isOwner ? `oncontextmenu="showTeamMemberContextMenu(event, '${userId}', '${email}', '${name.replace(/'/g, "\\'")}'); return false;"` : ''}
               style="cursor: ${f.isOwner ? 'default' : 'pointer'}">
            <div class="team-follower-avatar-wrapper">
              <div class="team-follower-avatar">
                ${avatar ? `<img src="${avatar}" alt="${name}">` : `<span>${initial}</span>`}
              </div>
              <div class="team-follower-status ${statusClassFinal}" title="${isActive ? 'Online' : 'Offline'}"></div>
            </div>
            <div class="team-follower-info">
              <span class="team-follower-name">${name}</span>
              ${f.isOwner ? '' : `<span class="team-follower-email">${statusText}</span>`}
            </div>
            ${f.isOwner ? '<span class="team-owner-badge">Owner</span>' : ''}
            ${!f.isOwner ? `<button class="conversation-button" title="Start conversation" onclick="startTeamConversation('${userId}', '${name.replace(/'/g, "\\'")}', '${email}')">
              <svg viewBox="0 0 24 24">
                <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                <path d="M12 8v4l3 3"/>
              </svg>
            </button>` : ''}
          </div>
        `;
  }).join('')}
      ${displayFollowers.length === 0 ? `
        <div class="team-empty-state">
          <p>No team members yet</p>
          <button class="btn btn-sm btn-primary" onclick="openAddPeopleModal()">Add People</button>
        </div>
      ` : ''}
    </div>
    
    <!-- Pending Follow Requests -->
    ${displayPending.length > 0 ? `
      <div class="team-panel-section">
        <span class="section-label">PENDING REQUESTS (${displayPending.length})</span>
      </div>
      <div class="team-pending-requests">
        ${displayPending.map(request => {
    const profile = request.follower_profile || request.inviter_profile || {};
    const name = profile.name || profile.email?.split('@')[0] || 'Unknown';
    const email = profile.email || request.invitee_email || request.following_email || '';
    const initial = name.charAt(0).toUpperCase();

    return `
          <div class="team-request-item" data-request-id="${request.id}">
            <div class="team-request-avatar">
              ${profile.avatar_url ? `<img src="${profile.avatar_url}" alt="${name}">` : `<span>${initial}</span>`}
            </div>
            <div class="team-request-info">
              <span class="team-request-name">${name}</span>
              <span class="team-request-email">${email}</span>
              <span class="team-request-time">${formatTimeAgo(request.created_at)}</span>
            </div>
            <div class="team-request-actions">
              <button class="btn btn-sm btn-success" onclick="acceptInvite('${request.follower_id}')" title="Accept">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                  <path d="M5 13l4 4L19 7"/>
                </svg>
              </button>
              <button class="btn btn-sm btn-danger" onclick="rejectInvite('${request.follower_id}')" title="Reject">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                  <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
              </button>
            </div>
          </div>
        `;
  }).join('')}
      </div>
    ` : ''}
  `;
}

function switchTeamPanelTab(tab) {
  // Switch between members and access tabs
  document.querySelectorAll('.team-panel-tab').forEach(t => t.classList.remove('active'));
  event.target.closest('.team-panel-tab').classList.add('active');
  // TODO: Implement tab switching logic
}

async function checkInviteNotifications() {
  // Switch to the invites tab
  document.querySelectorAll('.team-panel-tab').forEach(t => t.classList.remove('active'));
  event.target.closest('.team-panel-tab').classList.add('active');

  // Load pending invitations/requests
  let pendingRequests = [];
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      pendingRequests = await window.LayerDB.getPendingFollowRequests();
      console.log('Loaded pending invitations:', pendingRequests);
    } catch (error) {
      console.error('Failed to load pending invitations:', error);
      pendingRequests = [];
    }
  }

  // Update the invites count
  const invitesCountElement = document.getElementById('invitesCount');
  if (invitesCountElement) {
    invitesCountElement.textContent = pendingRequests.length;
  }

  // Toggle the invites dropdown/content container
  toggleInvitesDropdown(pendingRequests);
}

// Toggle invites dropdown/content container
function toggleInvitesDropdown(requests) {
  // Remove any existing invites dropdown
  const existingDropdown = document.getElementById('invitesDropdownContainer');
  if (existingDropdown) {
    existingDropdown.remove();
  }

  // If no requests, show message directly
  if (requests.length === 0) {
    showNotification('You have no pending team invitations at this time.', 'info');
    return;
  }

  // Create dropdown container
  const dropdownContainer = document.createElement('div');
  dropdownContainer.id = 'invitesDropdownContainer';
  dropdownContainer.className = 'team-invites-dropdown';

  // Generate content
  const content = `
    <div class="dropdown-content">
      <div class="dropdown-header">
        <h4>Pending Team Invitations (${requests.length})</h4>
      </div>
      <div class="dropdown-body">
        <div class="invite-list">
          ${requests.map(request => `
            <div class="invite-item" data-request-id="${request.id}">
              <div class="invite-info">
                <div class="invite-sender">${request.follower_email || request.email || 'Unknown User'}</div>
                <div class="invite-date">${new Date(request.created_at).toLocaleDateString()}</div>
              </div>
              <div class="invite-actions">
                <button class="btn btn-sm btn-primary" onclick="acceptInvite('${request.id}', '${request.follower_id || request.id}')">
                  Accept
                </button>
                <button class="btn btn-sm btn-secondary" onclick="rejectInvite('${request.id}', '${request.follower_id || request.id}')">
                  Decline
                </button>
              </div>
            </div>
          `).join('')}
        </div>
      </div>
    </div>
  `;

  dropdownContainer.innerHTML = content;

  // Insert after the invites tab button
  const invitesTab = event.target.closest('.team-panel-tab');
  if (invitesTab) {
    invitesTab.parentNode.insertBefore(dropdownContainer, invitesTab.nextSibling);
  }

  // Close dropdown when clicking outside
  setTimeout(() => {
    document.addEventListener('click', function closeDropdown(e) {
      if (!dropdownContainer.contains(e.target) && !e.target.closest('.team-panel-tab')) {
        dropdownContainer.remove();
        document.removeEventListener('click', closeDropdown);
      }
    });
  }, 10);
}

function showInviteNotificationsModal(requests) {
  const modalContent = `
    <div class="invite-notifications-modal">
      <h3>Pending Team Invitations (${requests.length})</h3>
      <div class="invite-list">
        ${requests.map(request => `
          <div class="invite-item" data-request-id="${request.id}">
            <div class="invite-info">
              <div class="invite-sender">${request.follower_email || request.email || 'Unknown User'}</div>
              <div class="invite-date">${new Date(request.created_at).toLocaleDateString()}</div>
            </div>
            <div class="invite-actions">
              <button class="btn btn-sm btn-primary" onclick="acceptInvite('${request.id}', '${request.follower_id || request.id}')">
                Accept
              </button>
              <button class="btn btn-sm btn-secondary" onclick="rejectInvite('${request.id}', '${request.follower_id || request.id}')">
                Decline
              </button>
            </div>
          </div>
        `).join('')}
      </div>
    </div>
  `;

  openModal('Team Invitations', modalContent);
}

// Toggle the invites dropdown panel
function toggleInvitesPanel(btn) {
  const panel = document.getElementById('invitesDropdownPanel');
  if (!panel) return;
  const isVisible = panel.style.display !== 'none';
  panel.style.display = isVisible ? 'none' : 'block';
  if (btn) btn.classList.toggle('active', !isVisible);
}

// ============================================
// Real-time Subscription Management for Team Members Panel
// ============================================

let followersSubscriptionChannel = null;

// Initialize real-time subscription for followers
async function initializeTeamMembersSubscription() {
  // Clean up any existing subscription first
  cleanupTeamMembersSubscription();

  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return;
  }

  console.log('🔄 Initializing real-time subscription for team members...');

  // Subscribe to followers table changes
  followersSubscriptionChannel = window.LayerDB.subscribeToFollowers(async (payload) => {
    console.log('📨 Followers table changed:', payload);

    // Refresh the team members panel
    const panel = document.getElementById('teamMembersPanel');
    if (panel) {
      panel.innerHTML = await renderTeamMembersPanel();
      console.log('✅ Team members panel refreshed automatically');
    }
  });
}

// Clean up subscription when panel is closed or user signs out
function cleanupTeamMembersSubscription() {
  if (followersSubscriptionChannel && window.LayerDB) {
    console.log('🧹 Cleaning up team members subscription...');
    window.LayerDB.unsubscribeFromFollowers(followersSubscriptionChannel);
    followersSubscriptionChannel = null;
  }
}

// Make functions globally available
window.initializeTeamMembersSubscription = initializeTeamMembersSubscription;
window.cleanupTeamMembersSubscription = cleanupTeamMembersSubscription;

async function acceptInvite(followerUserId) {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) return;
  try {
    console.log('🔄 Accepting follow request from:', followerUserId);

    await window.LayerDB.acceptFollowRequest(followerUserId);

    console.log('✅ Follow request accepted, refreshing panel...');

    // Wait a moment for the database to update
    await new Promise(resolve => setTimeout(resolve, 300));

    // Refresh the entire team members panel to show the newly accepted member
    const panel = document.getElementById('teamMembersPanel');
    if (panel) {
      panel.innerHTML = await renderTeamMembersPanel();
    }

    showNotification('Invite accepted! Member added to your team.', 'success');
  } catch (error) {
    console.error('Failed to accept invite:', error);
    showNotification('Failed to accept invite. Please try again.', 'error');
  }
}

async function rejectInvite(followerUserId) {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) return;
  try {
    console.log('🔄 Rejecting follow request from:', followerUserId);

    await window.LayerDB.rejectFollowRequest(followerUserId);

    console.log('✅ Follow request rejected, refreshing panel...');

    // Wait a moment for the database to update
    await new Promise(resolve => setTimeout(resolve, 300));

    // Refresh the panel
    const panel = document.getElementById('teamMembersPanel');
    if (panel) {
      panel.innerHTML = await renderTeamMembersPanel();
    }

  } catch (error) {
    console.error('Failed to reject invite:', error);
    showNotification('Failed to decline invite.', 'error');
  }
}

// ============================================
// Presence System (Online/Offline Status)
// ============================================
let userPresenceMap = new Map(); // Stores { userId: { is_online, last_seen } }
let presenceHeartbeatInterval = null;
let presenceUpdateInterval = null;

async function initializePresenceSystem() {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) return;

  const currentUser = window.LayerDB.getCurrentUser();
  console.log('🟢 Initializing Presence System...');

  // 1. Subscribe to Realtime Updates
  if (window.LayerRealtime) {
    window.LayerRealtime.subscribeToUserPresence((payload) => {
      const { new: newRecord, eventType } = payload;
      if (eventType === 'INSERT' || eventType === 'UPDATE') {
        userPresenceMap.set(newRecord.user_id, {
          is_online: newRecord.is_online,
          last_seen: newRecord.last_seen
        });
        // Immediate UI update for this user
        updateUserPresenceUI(newRecord.user_id, newRecord.is_online, newRecord.last_seen);
      }
    });
  }

  // 2. Start Heartbeat (Send "I am alive" every 30s)
  if (presenceHeartbeatInterval) clearInterval(presenceHeartbeatInterval);

  // Initial heartbeat
  window.LayerDB.updatePresence(true);

  presenceHeartbeatInterval = setInterval(() => {
    window.LayerDB.updatePresence(true);
  }, 30000);

  // 3. Start UI Update Loop (Every 1s as requested)
  // This checks for stale last_seen and updates avatars
  if (presenceUpdateInterval) clearInterval(presenceUpdateInterval);

  presenceUpdateInterval = setInterval(() => {
    updateAllPresenceUI();
  }, 1000);
}

// Update specific user UI
function updateUserPresenceUI(userId, isOnline, lastSeen) {
  // Find all avatar wrappers for this user
  const userItems = document.querySelectorAll(`.team-follower-item[data-user-id="${userId}"]`);

  userItems.forEach(item => {
    const statusDot = item.querySelector('.team-follower-status');
    if (statusDot) {
      // Determine if actually online based on recency (e.g. within 60s)
      const lastSeenTime = new Date(lastSeen).getTime();
      const now = Date.now();
      const isRecent = (now - lastSeenTime) < 60000; // 1 minute timeout

      const actuallyOnline = isOnline && isRecent;

      // Update class
      if (actuallyOnline) {
        statusDot.classList.remove('offline');
        statusDot.classList.add('online');
        statusDot.title = 'Online';
      } else {
        statusDot.classList.remove('online');
        statusDot.classList.add('offline');
        statusDot.title = 'Offline';
      }
    }
  });

  // Also update DM avatars for this user
  updateDMAvatarStatus(userId, isOnline, lastSeen);
}

// Update DM avatar status
function updateDMAvatarStatus(userId, isOnline, lastSeen) {
  // Find DM items for this user by checking the onclick attribute for partnerId
  const dmItems = document.querySelectorAll('.team-chat-item.dm');

  dmItems.forEach(item => {
    const onclickAttr = item.getAttribute('onclick');
    if (onclickAttr && onclickAttr.includes(`'${userId}'`)) {
      const dmAvatar = item.querySelector('.team-dm-avatar');
      if (dmAvatar) {
        // Determine if actually online based on recency
        const lastSeenTime = new Date(lastSeen).getTime();
        const now = Date.now();
        const isRecent = (now - lastSeenTime) < 60000; // 1 minute timeout

        const actuallyOnline = isOnline && isRecent;

        // Update class on the avatar container
        dmAvatar.classList.remove('online', 'offline', 'away');
        if (actuallyOnline) {
          dmAvatar.classList.add('online');
        } else {
          dmAvatar.classList.add('offline');
        }
      }
    }
  });
}

// Update all DM avatars based on presence map
function updateAllDMAvatars() {
  const dmItems = document.querySelectorAll('.team-chat-item.dm');

  dmItems.forEach(item => {
    const onclickAttr = item.getAttribute('onclick');
    if (onclickAttr) {
      // Extract partnerId from onclick attribute
      const match = onclickAttr.match(/showDMContextMenu\(event, '[^']+', '([^']+)',/);
      if (match && match[1]) {
        const partnerId = match[1];
        const presence = userPresenceMap.get(partnerId);

        const dmAvatar = item.querySelector('.team-dm-avatar');
        if (dmAvatar) {
          if (presence) {
            // Determine if actually online based on recency
            const lastSeenTime = new Date(presence.last_seen).getTime();
            const now = Date.now();
            const isRecent = (now - lastSeenTime) < 60000; // 1 minute timeout

            const actuallyOnline = presence.is_online && isRecent;

            // Update class on the avatar container
            dmAvatar.classList.remove('online', 'offline', 'away');
            if (actuallyOnline) {
              dmAvatar.classList.add('online');
            } else {
              dmAvatar.classList.add('offline');
            }
          } else {
            // No presence data, assume offline
            dmAvatar.classList.remove('online', 'offline', 'away');
            dmAvatar.classList.add('offline');
          }
        }
      }
    }
  });
}

// Loop through all visible users and update based on map
function updateAllPresenceUI() {
  // Get all visible user items
  const userItems = document.querySelectorAll('.team-follower-item[data-user-id]');

  userItems.forEach(item => {
    const userId = item.getAttribute('data-user-id');
    if (userId === 'current-user' || userId === window.LayerDB?.getCurrentUser()?.id) {
      // Always online for self
      const statusDot = item.querySelector('.team-follower-status');
      if (statusDot) {
        statusDot.classList.remove('offline');
        statusDot.classList.add('online');
      }
      return;
    }

    const presence = userPresenceMap.get(userId);
    if (presence) {
      updateUserPresenceUI(userId, presence.is_online, presence.last_seen);
    } else {
      // If no data, assume offline (default)
    }
  });

  // Also update all DM avatars
  updateAllDMAvatars();
}

// Initial fetch of presence for loaded users
async function fetchInitialPresence() {
  const userItems = document.querySelectorAll('.team-follower-item[data-user-id]');
  const userIds = Array.from(userItems)
    .map(item => item.getAttribute('data-user-id'))
    .filter(id => id && id !== 'current-user');

  if (userIds.length > 0 && window.LayerDB?.getUsersPresence) {
    const presenceData = await window.LayerDB.getUsersPresence(userIds);
    presenceData.forEach(p => {
      userPresenceMap.set(p.user_id, {
        is_online: p.is_online,
        last_seen: p.last_seen
      });
    });
    updateAllPresenceUI();
  }
}


// ============================================
// Team Member Context Menu
// ============================================

async function startTeamConversation(userId, name, email) {
  // Generate consistent channel ID for DM (dm-MIN_ID-MAX_ID)
  // But our supabase-client logic for getDirectMessages returns partnerId. 
  // We need a consistent way to generate ID.
  // Actually, we can just use 'dm-' + userId as a local temporary ID if we don't have the official channel ID from DB yet.
  // But wait, the DB `team_chat_messages` stores `channel_id`. We need a convention.
  // Let's use `dm-${[currentUserId, userId].sort().join('-')}`

  const currentUser = window.LayerDB.getCurrentUser();
  if (!currentUser) {
    showToast('You must be logged in to start a conversation', 'error');
    return;
  }

  // Ensure consistent ID generation by using lowercase
  const participants = [currentUser.id.toLowerCase(), userId.toLowerCase()].sort();
  const channelId = `dm-${participants.join('-')}`;

  // Check if this DM is already in our specific list
  let existingDM = teamDirectMessages.find(dm => dm.partnerId === userId || dm.id === channelId);

  if (!existingDM) {
    // Optimistically add to list
    existingDM = {
      id: channelId,
      partnerId: userId,
      name: name,
      email: email,
      type: 'dm',
      unread: 0,
      status: 'offline', // will update
      avatar: null // will update if we fetch profile
    };
    teamDirectMessages.unshift(existingDM);

    // Force sidebar update to show new DM immediately
    updateTeamSidebar();

    // Close any open modals
    if (typeof closeModal === 'function') closeModal();
  }

  // Select the channel
  // This will trigger updateTeamChatArea() which re-renders the list
  await selectTeamChannel(channelId);

  // Close context menu
  const menu = document.querySelector('.team-member-context-menu');
  if (menu) menu.remove();
}

function showTeamMemberContextMenu(event, userId, email, name) {
  event.preventDefault();
  event.stopPropagation();

  // Remove any existing context menus
  const existingMenus = document.querySelectorAll('.team-member-context-menu');
  existingMenus.forEach(menu => menu.remove());

  // Create context menu
  const contextMenu = document.createElement('div');
  contextMenu.className = 'team-member-context-menu';
  contextMenu.innerHTML = `
    <div class="context-menu-header">
      <div class="context-menu-user-name">${name}</div>
      <div class="context-menu-user-email">${email}</div>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="startTeamConversation('${userId}', '${name.replace(/'/g, "\\'")}', '${email}')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
      </svg>
      <span>Start Conversation</span>
    </div>
    <div class="context-menu-item" onclick="muteTeamMember('${userId}', '${name.replace(/'/g, "\\'")}')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M11 5L6 9H2v6h4l5 4V5z"/>
        <line x1="23" y1="9" x2="17" y2="15"/>
        <line x1="17" y1="9" x2="23" y2="15"/>
      </svg>
      <span>Mute</span>
    </div>
    <div class="context-menu-item danger" onclick="unfollowTeamMember('${userId}', '${email}', '${name.replace(/'/g, "\\'")}')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
        <circle cx="8.5" cy="7" r="4"/>
        <line x1="18" y1="8" x2="23" y2="13"/>
        <line x1="23" y1="8" x2="18" y2="13"/>
      </svg>
      <span>Unfollow</span>
    </div>
  `;

  document.body.appendChild(contextMenu);

  // Position the context menu
  const menuRect = contextMenu.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  let left = event.clientX;
  let top = event.clientY;

  // Adjust if menu goes off screen
  if (left + menuRect.width > viewportWidth) {
    left = viewportWidth - menuRect.width - 10;
  }
  if (top + menuRect.height > viewportHeight) {
    top = viewportHeight - menuRect.height - 10;
  }

  contextMenu.style.left = `${left}px`;
  contextMenu.style.top = `${top}px`;

  // Close menu when clicking outside
  setTimeout(() => {
    document.addEventListener('click', function closeContextMenu(e) {
      if (!contextMenu.contains(e.target)) {
        contextMenu.remove();
        document.removeEventListener('click', closeContextMenu);
      }
    });
  }, 10);
}

async function muteTeamMember(userId, name) {
  // Close context menu
  const contextMenu = document.querySelector('.team-member-context-menu');
  if (contextMenu) contextMenu.remove();

  // TODO: Implement mute functionality
  // For now, just show a notification
  showNotification(`Mute feature coming soon for ${name}!`, 'info');

  console.log('🔇 Muting user:', userId, name);
}

async function unfollowTeamMember(userId, email, name) {
  // Close context menu
  const contextMenu = document.querySelector('.team-member-context-menu');
  if (contextMenu) contextMenu.remove();

  // Confirm before unfollowing
  if (!confirm(`Are you sure you want to unfollow ${name}? They will be removed from your team members.`)) {
    return;
  }

  try {
    console.log('🔄 Unfollowing user:', userId, email);

    if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
      showNotification('Please sign in to unfollow users', 'error');
      return;
    }

    // Unfollow the user
    await window.LayerDB.unfollowUser(userId);

    console.log('✅ Unfollowed user, refreshing panel...');

    // Wait a moment for the database to update
    await new Promise(resolve => setTimeout(resolve, 300));

    // Refresh the team members panel
    const panel = document.getElementById('teamMembersPanel');
    if (panel) {
      panel.innerHTML = await renderTeamMembersPanel();
    }

    // Also remove from DM list if present?
    // Maybe better to refresh the whole view
    // renderTeamView(); // logic for full refresh might be needed

    showNotification(`You unfollowed ${name}`, 'success');
  } catch (error) {
    console.error('Failed to unfollow user:', error);
    showNotification('Failed to unfollow user. Please try again.', 'error');
  }
}

// DM Context Menu
function showDMContextMenu(event, dmId, partnerId, partnerName) {
  event.preventDefault(); // Prevent default browser menu

  // Remove existing context menu
  const existingMenu = document.querySelector('.team-dm-context-menu');
  if (existingMenu) existingMenu.remove();

  // Create context menu element
  const contextMenu = document.createElement('div');
  contextMenu.className = 'team-member-context-menu team-dm-context-menu'; // Reuse styles

  contextMenu.innerHTML = `
    <div class="context-menu-header">
      <span>${partnerName}</span>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="muteTeamMember('${partnerId}', '${partnerName.replace(/'/g, "\\'")}')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M11 5L6 9H2v6h4l5 4V5z"/>
        <line x1="23" y1="9" x2="17" y2="15"/>
        <line x1="17" y1="9" x2="23" y2="15"/>
      </svg>
      <span>Mute</span>
    </div>
    <div class="context-menu-item danger" onclick="clearLocalDMChat('${dmId}', '${partnerName.replace(/'/g, "\\'")}')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <polyline points="3 6 5 6 21 6"></polyline>
        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
      </svg>
      <span>Delete Conversation</span>
    </div>
    <div class="context-menu-item danger" onclick="unfollowTeamMember('${partnerId}', '', '${partnerName.replace(/'/g, "\\'")}')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
        <circle cx="8.5" cy="7" r="4"/>
        <line x1="18" y1="8" x2="23" y2="13"/>
        <line x1="23" y1="8" x2="18" y2="13"/>
      </svg>
      <span>Unfollow</span>
    </div>
  `;

  document.body.appendChild(contextMenu);

  // Position the context menu
  const menuRect = contextMenu.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  let left = event.clientX;
  let top = event.clientY;

  // Adjust if menu goes off screen
  if (left + menuRect.width > viewportWidth) {
    left = viewportWidth - menuRect.width - 10;
  }
  if (top + menuRect.height > viewportHeight) {
    top = viewportHeight - menuRect.height - 10;
  }

  contextMenu.style.left = `${left}px`;
  contextMenu.style.top = `${top}px`;

  // Close menu when clicking outside
  setTimeout(() => {
    document.addEventListener('click', function closeContextMenu(e) {
      if (!contextMenu.contains(e.target)) {
        contextMenu.remove();
        document.removeEventListener('click', closeContextMenu);
      }
    });
  }, 10);
}

// Clear DM Chat Handler
async function clearLocalDMChat(dmId, partnerName) {
  // Close context menu
  const contextMenu = document.querySelector('.team-dm-context-menu');
  if (contextMenu) contextMenu.remove();

  if (!confirm(`Are you sure you want to PERMANENTLY delete this entire conversation with ${partnerName}? This will remove it for EVERYONE and cannot be undone.`)) {
    return;
  }

  try {
    if (window.LayerDB && window.LayerDB.clearDMChat) {
      await window.LayerDB.clearDMChat(dmId);

      // Clear local messages
      teamMessages[dmId] = [];

      // Remove from DM list entirely
      teamDirectMessages = teamDirectMessages.filter(dm => dm.id !== dmId);

      // Update sidebar
      updateTeamSidebar();

      // If we were viewing this DM, switch to something else (e.g., General)
      if (teamCurrentChannel === dmId) {
        if (teamChannels.length > 0) {
          selectTeamChannel(teamChannels[0].id);
        } else {
          // Fallback if no channels
          document.querySelector('.team-chat-main').innerHTML = '<div class="team-chat-welcome">Select a channel</div>';
        }
      }

      showNotification('Conversation deleted permanently', 'success');
    } else {
      showNotification('Database connection not available', 'error');
    }
  } catch (error) {
    console.error('Failed to clear chat:', error);
    showNotification('Failed to delete conversation. Please try again.', 'error');
  }
}

// Message Context Menu
function showMessageContextMenu(event, messageId, messageUserId, channelType) {
  event.preventDefault(); // Prevent default browser menu

  // Remove existing context menu
  const existingMenu = document.querySelector('.context-menu');
  if (existingMenu) existingMenu.remove();

  // Check if message belongs to current user or if it's a DM where user can modify
  const isCurrentUserMessage = messageUserId === window.currentUserProfile?.id;
  const isDM = channelType === 'dm';

  // Create context menu element
  const contextMenu = document.createElement('div');
  contextMenu.className = 'context-menu';

  // Build menu items based on permissions
  let menuItems = '';

  // Delete option - only for user's own messages
  if (isCurrentUserMessage) {
    menuItems += `
      <div class="context-menu-item delete" onclick="deleteMessage('${messageId}')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="3 6 5 6 21 6"></polyline>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </svg>
        <span>Delete Message</span>
      </div>
    `;
  }

  // Add divider if both options are available
  if (menuItems) {
    menuItems += '<div class="context-menu-divider"></div>';
  }

  // Favorite option - available for any message
  menuItems += `
    <div class="context-menu-item favorite" onclick="toggleMessageFavorite('${messageId}')">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
      </svg>
      <span>Toggle Favorite</span>
    </div>
  `;

  contextMenu.innerHTML = menuItems;

  document.body.appendChild(contextMenu);

  // Position the context menu
  const menuRect = contextMenu.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  let left = event.clientX;
  let top = event.clientY;

  // Adjust if menu goes off screen
  if (left + menuRect.width > viewportWidth) {
    left = viewportWidth - menuRect.width - 10;
  }
  if (top + menuRect.height > viewportHeight) {
    top = viewportHeight - menuRect.height - 10;
  }

  contextMenu.style.left = `${left}px`;
  contextMenu.style.top = `${top}px`;

  // Close menu when clicking outside
  setTimeout(() => {
    document.addEventListener('click', function closeContextMenu(e) {
      if (!contextMenu.contains(e.target)) {
        contextMenu.remove();
        document.removeEventListener('click', closeContextMenu);
      }
    });
  }, 10);
}

// Delete a message
async function deleteMessage(messageId) {
  try {
    // Remove the context menu
    const contextMenu = document.querySelector('.context-menu');
    if (contextMenu) contextMenu.remove();

    if (!confirm('Are you sure you want to delete this message? This action cannot be undone.')) {
      return;
    }

    if (window.LayerDB && window.LayerDB.deleteTeamMessage) {
      await window.LayerDB.deleteTeamMessage(messageId);
      
      // Remove the message from the local cache
      if (teamMessages[teamCurrentChannel]) {
        teamMessages[teamCurrentChannel] = teamMessages[teamCurrentChannel].filter(msg => msg.id !== messageId);
      }
      
      // Refresh the chat display
      updateChatContentOnly();
      
      showNotification('Message deleted', 'success');
    } else {
      showNotification('Database connection not available', 'error');
    }
  } catch (error) {
    console.error('Failed to delete message:', error);
    showNotification('Failed to delete message. Please try again.', 'error');
  }
}

// Toggle message favorite status
async function toggleMessageFavorite(messageId) {
  try {
    // Remove the context menu
    const contextMenu = document.querySelector('.context-menu');
    if (contextMenu) contextMenu.remove();

    if (window.LayerDB && window.LayerDB.toggleMessageFavorite) {
      const result = await window.LayerDB.toggleMessageFavorite(messageId);
      
      // Update the local message cache
      if (teamMessages[teamCurrentChannel]) {
        const messageIndex = teamMessages[teamCurrentChannel].findIndex(msg => msg.id === messageId);
        if (messageIndex !== -1) {
          teamMessages[teamCurrentChannel][messageIndex].is_favorite = result.is_favorite;
        }
      }
      
      // Refresh the chat display
      updateChatContentOnly();
      
      showNotification(result.is_favorite ? 'Message favorited' : 'Message unfavorited', 'success');
    } else {
      showNotification('Database connection not available', 'error');
    }
  } catch (error) {
    console.error('Failed to toggle favorite:', error);
    showNotification(error.message || 'Failed to toggle favorite. Please try again.', 'error');
  }
}

// Make functions globally available
window.showTeamMemberContextMenu = showTeamMemberContextMenu;
window.showDMContextMenu = showDMContextMenu;
window.showMessageContextMenu = showMessageContextMenu;
window.deleteMessage = deleteMessage;
window.toggleMessageFavorite = toggleMessageFavorite;
window.startTeamConversation = startTeamConversation;
window.muteTeamMember = muteTeamMember;
window.unfollowTeamMember = unfollowTeamMember;
window.clearLocalDMChat = clearLocalDMChat;

function showNotification(message, type = 'info') {
  // Create notification element
  const notification = document.createElement('div');
  notification.className = `notification notification-${type}`;
  notification.textContent = message;

  // Add basic styling
  Object.assign(notification.style, {
    position: 'fixed',
    top: '20px',
    right: '20px',
    padding: '12px 20px',
    borderRadius: '8px',
    color: 'white',
    fontWeight: '500',
    zIndex: '10000',
    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
    maxWidth: '300px',
    wordWrap: 'break-word'
  });

  // Set background color based on type
  const colors = {
    success: '#10b981',
    error: '#ef4444',
    info: '#3b82f6',
    warning: '#f59e0b'
  };
  notification.style.backgroundColor = colors[type] || colors.info;

  // Add to document
  document.body.appendChild(notification);

  // Remove after 3 seconds
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 3000);
}

function searchTeamMembers(query) {
  const items = document.querySelectorAll('.team-follower-item');
  const searchTerm = query.toLowerCase();

  items.forEach(item => {
    const email = item.dataset.email || '';
    const name = item.querySelector('.team-follower-name')?.textContent || '';
    const matches = email.toLowerCase().includes(searchTerm) || name.toLowerCase().includes(searchTerm);
    item.style.display = matches ? '' : 'none';
  });
}

// Team View Helper Functions
// Helper to update just the chat area without full re-render
function updateTeamChatArea() {
  const chatMain = document.querySelector('.team-chat-main');
  if (chatMain) {
    chatMain.innerHTML = renderTeamChatHeader() + renderTeamChatContent() + (teamCurrentTab === 'chat' ? renderTeamMessageInput() : '');
  }

  // Update sidebar active states
  document.querySelectorAll('.team-chat-item').forEach(item => {
    item.classList.remove('active');
  });

  // Find and activate the current channel/DM
  document.querySelectorAll('.team-chat-item').forEach(item => {
    const onclick = item.getAttribute('onclick') || '';

    // Check if this item's onclick matches the current channel
    // Handle both regular format and DM format
    if (onclick.includes("'" + teamCurrentChannel + "'") ||
      onclick.includes('"' + teamCurrentChannel + '"')) {
      item.classList.add('active');
      console.log('✅ Activated chat item:', teamCurrentChannel);
    }
  });

  // Initialize enhanced scroll manager
  initChatScrollManager();
}

async function selectTeamChannel(channelId) {
  // Normalize channel ID to lowercase for consistency
  channelId = channelId ? channelId.toLowerCase() : channelId;
  teamCurrentChannel = channelId;

  // Clear any existing polling from previous channel
  if (window.teamChatPollInterval) {
    clearInterval(window.teamChatPollInterval);
    window.teamChatPollInterval = null;
    console.log('🛑 Cleared previous polling interval');
  }

  // Determine channel type (case-insensitive finding)
  const channel = teamChannels.find(c => c.id.toLowerCase() === channelId) ||
    teamDirectMessages.find(d => d.id.toLowerCase() === channelId);
  const channelType = channel?.type || 'channel';

  // IDEMPOTENT: Clear unread count locally
  if (channel) {
    channel.unread = 0;
  }

  // Mark as read in DB (fire and forget)
  if (window.LayerDB && window.LayerDB.markChatAsRead) {
    window.LayerDB.markChatAsRead(channelId).catch(err => console.error('Failed to mark read:', err));
  }

  // Load messages from database FIRST before updating UI
  await loadTeamMessages(channelId, channelType);

  // Update chat area AFTER messages are loaded (prevents welcome screen flash)
  updateTeamChatArea();

  // Setup realtime subscription
  await setupTeamChatRealtime(channelId);

  if (teamCurrentTab === 'chat') {
    // Update chat content only (smoother) - this ensures the latest messages are shown
    updateChatContentOnly();

    // Always scroll to bottom when switching to a channel to show latest messages
    setTimeout(() => {
      if (chatScrollManager) {
        chatScrollManager.scrollToBottom(false); // Use immediate scroll (non-smooth) for better UX when switching tabs
      }
    }, 100); // Small delay to ensure content is rendered
  }

  // START POLLING (Enhanced Real-time Updates)
  // Clear any existing poll
  if (window.teamChatPollInterval) {
    clearInterval(window.teamChatPollInterval);
  }

  // Poll every 500ms for truly real-time updates (reduced from 1000ms)
  window.teamChatPollInterval = setInterval(async () => {
    // Only poll if we are viewing this channel
    if (teamCurrentChannel === channelId) {
      try {
        // Load messages silently
        const prevLength = teamMessages[channelId]?.length || 0;
        await loadTeamMessages(channelId, channelType);
        const newLength = teamMessages[channelId]?.length || 0;

        if (newLength !== prevLength) {
          console.log(`🔄 Active channel poll detected ${newLength - prevLength} new messages, updating UI`);

          // Force update of the message list
          const messagesList = document.querySelector('.team-messages-list');
          if (messagesList) {
            // Update only the messages list to preserve focus and scroll
            updateChatContentOnly();
          } else {
            // Fallback if messages list doesn't exist
            updateTeamChatArea();
          }
        }
      } catch (error) {
        console.error('❌ Error in active channel polling:', error);

        // Don't stop polling on error, just log it
        // The polling will continue and hopefully recover
      }
    } else {
      // Stop polling when we leave the channel
      clearInterval(window.teamChatPollInterval);
      console.log('🛑 Stopped active channel polling for:', channelId);
    }
  }, 500); // Reduced to 500ms for faster updates
}

// Advanced Chat Scroll Manager
class ChatScrollManager {
  constructor() {
    this.isAtBottom = true;
    this.isUserScrolling = false;
    this.scrollTimeout = null;
    this.markReadTimeout = null;
    this.messagesList = null;
    this.lastScrollHeight = 0;
    this.newMessageCount = 0;
    this.scrollToBottomBtn = null;
  }

  init(messagesListSelector = '.team-messages-list') {
    this.messagesList = document.querySelector(messagesListSelector);
    if (!this.messagesList) return;

    // Create scroll to bottom button
    this.createScrollToBottomButton();

    // Initial scroll to bottom
    this.scrollToBottom(false);

    // Add scroll event listeners
    this.messagesList.addEventListener('scroll', this.handleScroll.bind(this));
    this.messagesList.addEventListener('wheel', this.handleWheel.bind(this));
    this.messagesList.addEventListener('touchmove', this.handleTouch.bind(this));
  }

  createScrollToBottomButton() {
    // Remove existing button if any
    const existingBtn = document.querySelector('.scroll-to-bottom-btn');
    if (existingBtn) {
      existingBtn.remove();
    }

    // Create new button
    this.scrollToBottomBtn = document.createElement('button');
    this.scrollToBottomBtn.className = 'scroll-to-bottom-btn';
    this.scrollToBottomBtn.innerHTML = `
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="6 9 12 15 18 9"></polyline>
      </svg>
      <span class="new-message-count" style="display: none;">0</span>
    `;
    this.scrollToBottomBtn.addEventListener('click', () => {
      this.scrollToBottom(true);
      this.newMessageCount = 0;
      this.updateScrollButton();
    });

    // Add to chat content container
    const chatContent = this.messagesList.closest('.team-chat-content');
    if (chatContent) {
      chatContent.style.position = 'relative';
      chatContent.appendChild(this.scrollToBottomBtn);
    }
  }

  updateScrollButton() {
    if (!this.scrollToBottomBtn) return;

    const countElement = this.scrollToBottomBtn.querySelector('.new-message-count');

    if (this.newMessageCount > 0 && !this.isAtBottom) {
      this.scrollToBottomBtn.classList.add('visible');
      countElement.style.display = 'flex';
      countElement.textContent = this.newMessageCount > 99 ? '99+' : this.newMessageCount;
    } else {
      this.scrollToBottomBtn.classList.remove('visible');
      countElement.style.display = 'none';
    }
  }

  handleScroll() {
    if (!this.messagesList) return;

    const { scrollTop, scrollHeight, clientHeight } = this.messagesList;
    const threshold = 100; // 100px from bottom
    this.isAtBottom = scrollHeight - scrollTop - clientHeight <= threshold;

    // Clear new message indicator if user scrolls to bottom
    if (this.isAtBottom) {
      this.messagesList.classList.remove('has-new-messages');
      this.newMessageCount = 0;
      this.updateScrollButton();
    }

    // Mark visible messages as read when scrolling (with debouncing)
    clearTimeout(this.markReadTimeout);
    this.markReadTimeout = setTimeout(() => {
      this.markVisibleMessagesAsRead();
    }, 500); // Debounce to avoid too many DB calls

    // Detect if user is actively scrolling
    clearTimeout(this.scrollTimeout);
    this.isUserScrolling = true;

    this.scrollTimeout = setTimeout(() => {
      this.isUserScrolling = false;
    }, 150);
  }

  handleWheel() {
    this.isUserScrolling = true;
    clearTimeout(this.scrollTimeout);
    this.scrollTimeout = setTimeout(() => {
      this.isUserScrolling = false;
    }, 150);
  }

  handleTouch() {
    this.isUserScrolling = true;
    clearTimeout(this.scrollTimeout);
    this.scrollTimeout = setTimeout(() => {
      this.isUserScrolling = false;
    }, 150);
  }

  scrollToBottom(smooth = true) {
    if (!this.messagesList) return;

    if (smooth && !this.isUserScrolling) {
      this.messagesList.scrollTo({
        top: this.messagesList.scrollHeight,
        behavior: 'smooth'
      });
    } else if (!smooth) {
      this.messagesList.scrollTop = this.messagesList.scrollHeight;
    }

    this.isAtBottom = true;
    this.messagesList.classList.remove('has-new-messages');
    this.newMessageCount = 0;
    this.updateScrollButton();
  }

  addNewMessage() {
    if (!this.messagesList) return;

    const wasAtBottom = this.isAtBottom;
    const currentHeight = this.messagesList.scrollHeight;

    // Increment new message count
    this.newMessageCount++;

    // Add new message indicator if user is not at bottom
    if (!wasAtBottom && !this.isUserScrolling) {
      this.messagesList.classList.add('has-new-messages');
    }

    // Auto-scroll if user was at bottom or if this is the first message
    if (wasAtBottom || this.lastScrollHeight === 0) {
      setTimeout(() => {
        this.scrollToBottom(true);
      }, 50); // Small delay for content to render
    } else {
      // Update scroll button to show new message count
      this.updateScrollButton();
    }

    this.lastScrollHeight = currentHeight;
  }

  // Mark visible messages as read when user scrolls to them
  async markVisibleMessagesAsRead() {
    if (!this.messagesList || !window.LayerDB || !teamCurrentChannel) return;

    // Only mark as read for DMs
    const channel = teamDirectMessages.find(dm => dm.id === teamCurrentChannel);
    if (!channel) return;

    try {
      // Get all message elements
      const messageElements = this.messagesList.querySelectorAll('.team-message[data-message-id]');
      
      // Find messages that are currently visible (in viewport)
      const visibleMessages = [];
      const rect = this.messagesList.getBoundingClientRect();
      const viewTop = rect.top;
      const viewBottom = rect.bottom;

      messageElements.forEach(element => {
        const msgRect = element.getBoundingClientRect();
        const isVisible = (msgRect.top <= viewBottom) && (msgRect.bottom >= viewTop);
        
        if (isVisible) {
          const messageId = element.getAttribute('data-message-id');
          if (messageId) {
            visibleMessages.push(messageId);
          }
        }
      });

      // Mark visible messages as read in the database
      let hasChanges = false;
      if (visibleMessages.length > 0) {
        for (const messageId of visibleMessages) {
          // Update the message in local state to mark as read
          const channelId = teamCurrentChannel;
          if (teamMessages[channelId]) {
            const message = teamMessages[channelId].find(msg => msg.id === messageId);
            if (message && !message.isRead) {
              message.isRead = true; // Update local state
              hasChanges = true;
              
              // Update in database
              await window.LayerDB.markMessageAsRead(messageId);
            }
          }
        }
        
        // Update UI to reflect new read status only if there were changes
        if (hasChanges) {
          updateChatContentOnly();
        }
      }
    } catch (error) {
      console.error('Error marking messages as read:', error);
    }
  }

  destroy() {
    if (this.messagesList) {
      this.messagesList.removeEventListener('scroll', this.handleScroll.bind(this));
      this.messagesList.removeEventListener('wheel', this.handleWheel.bind(this));
      this.messagesList.removeEventListener('touchmove', this.handleTouch.bind(this));
    }

    if (this.scrollToBottomBtn) {
      this.scrollToBottomBtn.remove();
    }

    clearTimeout(this.scrollTimeout);
    clearTimeout(this.markReadTimeout);
  }
}

// Global chat scroll manager instance
let chatScrollManager = null;

// Initialize chat scroll manager
function initChatScrollManager() {
  if (chatScrollManager) {
    chatScrollManager.destroy();
  }
  chatScrollManager = new ChatScrollManager();
  chatScrollManager.init();
}

// Message Reactions Functions
function toggleReactionPicker(messageId) {
  // Close all other pickers first
  document.querySelectorAll('.team-reaction-picker').forEach(picker => {
    if (picker.id !== `reaction-picker-${messageId}`) {
      picker.classList.remove('show');
    }
  });

  // Toggle current picker
  const picker = document.getElementById(`reaction-picker-${messageId}`);
  if (picker) {
    picker.classList.toggle('show');
  }

  // Close picker when clicking outside
  document.addEventListener('click', function closePicker(e) {
    if (!e.target.closest('.team-message') && !e.target.closest('.team-reaction-picker')) {
      picker.classList.remove('show');
      document.removeEventListener('click', closePicker);
    }
  });
}

async function addReaction(messageId, emoji) {
  const currentUser = window.LayerDB?.getCurrentUser();
  if (!currentUser) {
    console.error('User not authenticated');
    return;
  }

  // Find the message in the current channel
  const messages = teamMessages[teamCurrentChannel] || [];
  const message = messages.find(m => m.id === messageId);
  if (!message) {
    console.error('Message not found:', messageId);
    return;
  }

  // Initialize reactions if not present
  if (!message.reactions) {
    message.reactions = {};
  }

  // Initialize emoji reactions if not present
  if (!message.reactions[emoji]) {
    message.reactions[emoji] = [];
  }

  const userId = currentUser.id;
  const userIndex = message.reactions[emoji].indexOf(userId);

  if (userIndex > -1) {
    // Remove reaction
    message.reactions[emoji].splice(userIndex, 1);
    if (message.reactions[emoji].length === 0) {
      delete message.reactions[emoji];
    }
    console.log(`Removed reaction ${emoji} from message ${messageId}`);
  } else {
    // Add reaction
    message.reactions[emoji].push(userId);
    console.log(`Added reaction ${emoji} to message ${messageId}`);
  }

  // Save to localStorage
  if (typeof saveMessageReactions === 'function') {
    saveMessageReactions(messageId, message.reactions);
  }

  // Update UI
  updateTeamChatArea();

  // Save to database (fire and forget for now)
  if (window.LayerDB && window.LayerDB.updateMessageReaction) {
    window.LayerDB.updateMessageReaction(messageId, emoji, message.reactions[emoji] || [])
      .catch(err => console.error('Failed to save reaction:', err));
  }

  // Close reaction picker
  const picker = document.getElementById(`reaction-picker-${messageId}`);
  if (picker) {
    picker.classList.remove('show');
  }
}

// Enhanced message creation with reactions support
function createMessageWithReactions(messageData) {
  return {
    ...messageData,
    reactions: messageData.reactions || {}
  };
}

// Update message with reactions from database
function updateMessageReactions(messageId, reactions) {
  const messages = teamMessages[teamCurrentChannel] || [];
  const message = messages.find(m => m.id === messageId);
  if (message) {
    message.reactions = reactions;
    updateTeamChatArea();
  }
}

// Global click handler to close reaction pickers
document.addEventListener('click', function (e) {
  if (!e.target.closest('.team-message-reaction-trigger') &&
    !e.target.closest('.team-reaction-picker') &&
    !e.target.closest('.team-message-reaction')) {
    document.querySelectorAll('.team-reaction-picker').forEach(picker => {
      picker.classList.remove('show');
    });
  }
});

// Enhanced update function that only updates the message list
// keeping header and input intact (preserves focus)
function updateChatContentOnly() {
  const messagesList = document.querySelector('.team-messages-list');
  if (messagesList) {
    const messages = teamMessages[teamCurrentChannel] || [];
    const channel = teamChannels.find(c => c.id === teamCurrentChannel) ||
      teamDirectMessages.find(d => d.id === teamCurrentChannel);

    // Store current scroll position and whether we're at bottom
    const wasAtBottom = chatScrollManager ? chatScrollManager.isAtBottom : true;
    const scrollHeight = messagesList.scrollHeight;

    // Generate only the messages HTML
    const messagesHTML = messages.map(msg => `
      <div class="team-message ${msg.isSystem ? 'system' : ''}" data-message-id="${msg.id}">
        <div class="team-message-avatar">
          ${(msg.avatar && msg.avatar.toString().includes('/')) || msg.avatarUrl ?
        `<img src="${msg.avatarUrl || msg.avatar}" alt="${msg.user}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">` :
        `<span>${msg.initial || msg.avatar || msg.user.charAt(0)}</span>`
      }
        </div>
        <div class="team-message-body">
          <div class="team-message-header">
            <span class="team-message-user">${msg.user}</span>
            <span class="team-message-time">${msg.time}</span>
          </div>
          <div class="team-message-content">
            ${msg.content}
            ${!msg.isSystem ? `
              <button class="team-message-reaction-trigger" onclick="toggleReactionPicker('${msg.id}')" title="Add reaction">
                😊
              </button>
              <div class="team-reaction-picker" id="reaction-picker-${msg.id}">
                <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '👍')">👍</button>
                <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '❤️')">❤️</button>
                <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '😂')">😂</button>
                <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '😮')">😮</button>
                <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '😢')">😢</button>
                <button class="team-reaction-emoji-btn" onclick="addReaction('${msg.id}', '😡')">😡</button>
              </div>
            ` : ''}
            ${msg.reactions && Object.keys(msg.reactions).length > 0 ? `
              <div class="team-message-reactions">
                ${Object.entries(msg.reactions).map(([emoji, users]) => `
                  <span class="team-reaction" onclick="toggleReaction('${msg.id}', '${emoji}')">
                    ${emoji} ${users.length}
                  </span>
                `).join('')}
              </div>
            ` : ''}
          </div>
          ${!msg.isSystem ? `
            <div class="team-message-status">
              ${msg.userId === window.currentUser?.id ? `
                ${msg.isRead ? 
                  `<span class="message-status seen" title="Seen">✓✓</span>` : 
                  `<span class="message-status received" title="Received">✓</span>`
                }
              ` : `
                <!-- Status for received messages could go here if needed -->
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `).join('');

    // Update only the innerHTML of the messages list
    messagesList.innerHTML = messagesHTML;

    // Re-initialize reactions for the new messages
    if (typeof initializeMessageReactions === 'function') {
      initializeMessageReactions();
    }

    // Handle scroll behavior
    if (chatScrollManager) {
      if (wasAtBottom) {
        // If we were at bottom, scroll to bottom to show new messages
        chatScrollManager.scrollToBottom(true);
      } else {
        // If we weren't at bottom, maintain scroll position but show new message indicator
        const newScrollHeight = messagesList.scrollHeight;
        if (newScrollHeight > scrollHeight) {
          // New content was added, show scroll-to-bottom button
          chatScrollManager.updateScrollButton && chatScrollManager.updateScrollButton();
        }
      }
    }

    console.log(`✅ Updated message list for ${teamCurrentChannel} with ${messages.length} messages`);
  } else {
    console.warn('⚠️ Messages list container not found, falling back to full update');
    // Fallback if content container doesn't exist yet
    updateTeamChatArea();
  }
}

// Load reactions for all messages in current channel
function loadMessageReactionsForCurrentChannel() {
  const messages = teamMessages[teamCurrentChannel] || [];
  messages.forEach(message => {
    if (typeof loadMessageReactions === 'function') {
      const savedReactions = loadMessageReactions(message.id);
      if (Object.keys(savedReactions).length > 0) {
        message.reactions = savedReactions;
      }
    }
  });
}

// Initialize reactions when channel is loaded
function initializeMessageReactions() {
  loadMessageReactionsForCurrentChannel();
  updateTeamChatArea();
}

function selectTeamGroup(groupId) {
  openModal('Group Details', '<p>Group management coming soon!</p>');
}

function setTeamTab(tab) {
  teamCurrentTab = tab;
  // Update tab active states directly
  document.querySelectorAll('.team-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.team-tab').forEach(t => {
    const onclick = t.getAttribute('onclick') || '';
    if (onclick.includes("'" + tab + "'")) {
      t.classList.add('active');
    }
  });
  // Refresh chat content area
  updateTeamChatArea();
}

async function toggleTeamMembersPanel() {
  const panel = document.getElementById('teamMembersPanel');
  if (panel) {
    const isCollapsed = panel.classList.contains('collapsed');
    panel.classList.toggle('collapsed');

    // Refresh panel content when opening
    if (isCollapsed) {
      const newContent = await renderTeamMembersPanel();
      panel.innerHTML = newContent;
    }
  }
}

function toggleTeamCreateDropdown() {
  const dropdown = document.getElementById('teamCreateDropdown');
  if (dropdown) {
    dropdown.classList.toggle('show');
  }
}

function closeTeamCreateDropdown() {
  const dropdown = document.getElementById('teamCreateDropdown');
  if (dropdown) {
    dropdown.classList.remove('show');
  }
}

async function sendTeamMessage() {
  const input = document.getElementById('teamMessageInput');
  if (!input || !input.value.trim()) return;

  const messageText = input.value.trim();
  input.value = '';

  console.log('🔵 Attempting to send message:', messageText);
  console.log('🔵 Current channel:', teamCurrentChannel);

  // Optimistic UI update - add message immediately
  const currentUser = window.LayerDB?.getCurrentUser();
  const tempId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

  const optimisticMessage = {
    id: tempId,
    user: currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0] || 'You',
    avatar: (currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0] || 'U').charAt(0).toUpperCase(),
    avatarUrl: currentUser?.user_metadata?.avatar_url || null,
    content: messageText,
    time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
    isSystem: false,
    userId: currentUser?.id,
    isOptimistic: true, // Flag to identify optimistic messages
    reactions: {} // Initialize empty reactions
  };

  // Add to UI immediately
  if (!teamMessages[teamCurrentChannel]) {
    teamMessages[teamCurrentChannel] = [];
  }
  teamMessages[teamCurrentChannel].push(optimisticMessage);
  updateTeamChatArea();

  // Use enhanced scroll manager for smooth auto-scroll
  if (chatScrollManager) {
    chatScrollManager.addNewMessage();
  }

  try {
    // Check if user is authenticated
    if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
      console.error('❌ User not authenticated');

      // Remove optimistic message
      teamMessages[teamCurrentChannel] = teamMessages[teamCurrentChannel].filter(m => m.id !== tempId);
      updateTeamChatArea();

      showNotification('Please sign in to send messages', 'error');
      input.value = messageText; // Restore message
      return;
    }

    // Determine channel type based on current channel
    const channel = teamChannels.find(c => c.id.toLowerCase() === teamCurrentChannel.toLowerCase()) ||
      teamDirectMessages.find(d => d.id.toLowerCase() === teamCurrentChannel.toLowerCase());

    console.log('🔵 Found channel:', channel);

    const channelType = channel?.type || (teamCurrentChannel?.startsWith('dm-') ? 'dm' : 'channel');
    console.log('🔵 Channel type:', channelType);

    let recipientId = null;

    // For DMs, get the recipient ID
    if (channelType === 'dm') {
      // Parse recipient ID from 'dm-UUID1-UUID2' format
      // UUIDs contain dashes, so we can't just split by '-'
      // UUID format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (36 chars with dashes)

      const dmPrefix = 'dm-';
      const channelWithoutPrefix = teamCurrentChannel.substring(dmPrefix.length);
      const currentUserId = window.LayerDB.getCurrentUser()?.id;

      console.log('🔵 DM channel (without prefix):', channelWithoutPrefix);
      console.log('🔵 Current user ID:', currentUserId);

      // Use regex to extract all UUIDs from the channel ID
      const uuidRegex = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi;
      const uuidMatches = channelWithoutPrefix.match(uuidRegex);

      console.log('🔵 UUID matches found:', uuidMatches);

      if (uuidMatches && uuidMatches.length >= 2 && currentUserId) {
        // Find the UUID that is NOT the current user
        recipientId = uuidMatches.find(id => id.toLowerCase() !== currentUserId.toLowerCase());

        // Fallback: if not found, use the other UUID
        if (!recipientId && uuidMatches.length >= 2) {
          recipientId = uuidMatches[0].toLowerCase() === currentUserId.toLowerCase() ? uuidMatches[1] : uuidMatches[0];
        }
      } else if (uuidMatches && uuidMatches.length === 1) {
        // Self-chat scenario
        recipientId = uuidMatches[0];
      }

      if (!recipientId) {
        console.error('❌ Could not determine recipient ID from channel:', teamCurrentChannel);
        console.error('❌ Channel without prefix:', channelWithoutPrefix);
        console.error('❌ UUID matches:', uuidMatches);

        // Remove optimistic message
        teamMessages[teamCurrentChannel] = teamMessages[teamCurrentChannel].filter(m => m.id !== tempId);
        updateTeamChatArea();

        showNotification('Error sending message: Invalid conversation', 'error');
        input.value = messageText; // Restore message
        return;
      }

      console.log('🔵 Recipient ID:', recipientId);
    }

    console.log('🔵 Calling LayerDB.sendTeamMessage...');

    // Send message to database
    const messageData = await window.LayerDB.sendTeamMessage(
      teamCurrentChannel,
      channelType,
      messageText,
      recipientId
    );

    console.log('✅ Message sent successfully:', messageData);

    // Replace optimistic message with real one
    const messageIndex = teamMessages[teamCurrentChannel].findIndex(m => m.id === tempId);
    if (messageIndex !== -1) {
      teamMessages[teamCurrentChannel][messageIndex] = {
        id: messageData.id,
        user: messageData.user_profile?.name || messageData.message ? (window.LayerDB.getCurrentUser()?.user_metadata?.name || window.LayerDB.getCurrentUser()?.email?.split('@')[0] || 'You') : 'Unknown',
        avatar: (window.LayerDB.getCurrentUser()?.user_metadata?.name || window.LayerDB.getCurrentUser()?.email?.split('@')[0] || 'U').charAt(0).toUpperCase(),
        content: messageData.message,
        time: new Date(messageData.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        isSystem: false,
        userId: messageData.user_id,
        avatarUrl: messageData.user_profile?.avatar_url || null,
        isEdited: messageData.is_edited,
        editedAt: messageData.edited_at
      };
      updateTeamChatArea();
    }

    console.log('✅ Message confirmed in UI');

  } catch (error) {
    console.error('❌ Failed to send team message:', error);
    console.error('❌ Error details:', {
      message: error.message,
      stack: error.stack,
      error: error
    });

    // Remove optimistic message on error
    teamMessages[teamCurrentChannel] = teamMessages[teamCurrentChannel].filter(m => m.id !== tempId);
    updateTeamChatArea();

    // Show user-friendly error message
    let errorMessage = 'Failed to send message. Please try again.';
    if (error.message.includes('Not authenticated')) {
      errorMessage = 'Please sign in to send messages.';
    } else if (error.message.includes('Invalid conversation')) {
      errorMessage = 'Invalid conversation. Please refresh the page.';
    } else if (error.message) {
      errorMessage = `Error: ${error.message}`;
    }

    showNotification(errorMessage, 'error');

    // Restore the message text on error
    const inp = document.getElementById('teamMessageInput');
    if (inp) inp.value = messageText;
  }
}

// Global Background Polling for All DM Conversations
let globalDMPollInterval = null;

async function startGlobalDMPolling() {
  if (globalDMPollInterval) {
    clearInterval(globalDMPollInterval);
  }

  console.log('🌐 Starting global DM polling for all conversations...');

  globalDMPollInterval = setInterval(async () => {
    if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
      return;
    }

    try {
      // Check all DM conversations for new messages
      for (const dm of teamDirectMessages) {
        const channelId = dm.id.toLowerCase();
        const prevLength = teamMessages[channelId]?.length || 0;

        // Silently load messages to check for updates
        await loadTeamMessages(channelId, 'dm');
        const newLength = teamMessages[channelId]?.length || 0;

        // If we have new messages and this isn't the active channel, update sidebar
        if (newLength > prevLength && teamCurrentChannel !== channelId) {
          dm.unread = (dm.unread || 0) + (newLength - prevLength);

          // Update last message info
          const latestMessage = teamMessages[channelId][teamMessages[channelId].length - 1];
          if (latestMessage) {
            dm.lastMessage = {
              message: latestMessage.content,
              created_at: new Date().toISOString(),
              user_id: latestMessage.userId
            };
          }

          console.log(`📨 New messages in DM ${dm.name}: ${newLength - prevLength} new`);

          // Update sidebar to show new unread badges
          updateTeamSidebar();
        }

        // If this IS the active channel, ensure the message list updates
        if (newLength > prevLength && teamCurrentChannel === channelId) {
          console.log(`🔄 Active channel ${channelId} has ${newLength - prevLength} new messages`);
          updateChatContentOnly();
        }
      }
    } catch (error) {
      console.error('❌ Error in global DM polling:', error);
    }
  }, 2000); // Check every 2 seconds
}

function stopGlobalDMPolling() {
  if (globalDMPollInterval) {
    clearInterval(globalDMPollInterval);
    globalDMPollInterval = null;
    console.log('🛑 Stopped global DM polling');
  }
}

// Load team messages from database
async function loadTeamMessages(channelId, channelType = 'channel') {
  try {
    // Ensure lowercase key usage
    channelId = channelId.toLowerCase();

    const messages = await window.LayerDB.getChatMessages(channelId);

    // Convert database messages to local format
    const localMessages = messages.map(msg => ({
      id: msg.id,
      user: msg.user_profile?.name || msg.sender?.email || 'Unknown', // Fallback to sender email if name missing
      avatar: msg.user_profile?.avatar_url, // Use distinct avatar URL
      initial: (msg.user_profile?.name || msg.sender?.email || 'U').charAt(0).toUpperCase(),
      content: msg.message,
      time: new Date(msg.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
      isSystem: msg.message_type === 'system',
      userId: msg.user_id,
      isEdited: msg.is_edited,
      editedAt: msg.edited_at,
      messageType: msg.message_type,
      fileUrl: msg.file_url,
      fileName: msg.file_name,
      replyTo: msg.reply_to,
      isRead: msg.is_read || false, // Include read status
      reactions: msg.reactions || {} // Include reactions from database
    }));

    // Update local state (safe assumption that key is lowercase)
    teamMessages[channelId] = localMessages;

    // Load reactions from localStorage for messages that don't have them from database
    localMessages.forEach(message => {
      if (!message.reactions || Object.keys(message.reactions).length === 0) {
        if (typeof loadMessageReactions === 'function') {
          const savedReactions = loadMessageReactions(message.id);
          if (Object.keys(savedReactions).length > 0) {
            message.reactions = savedReactions;
          }
        }
      }
    });

    return localMessages;
  } catch (error) {
    console.error('Failed to load team messages:', error);
    return [];
  }
}

// Setup realtime subscription for team messages
let currentTeamChatSubscription = null;
let globalDMSubscription = null;

async function setupGlobalDMListener() {
  // If already subscribed, don't subscribe again
  if (globalDMSubscription) return;

  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) return;

  console.log('🎧 Setting up global DM listener...');

  globalDMSubscription = window.LayerDB.subscribeToUserMessages(async (payload) => {
    const { new: newRecord } = payload;

    // We only care about inserts for DMs
    if (!newRecord || newRecord.channel_type !== 'dm') return;

    console.log('📩 Global DM Listener received message:', newRecord);

    // Check if we already have this conversation in our list
    // The sender is the user_id (since we filtered by recipient_id = current user)
    const senderId = newRecord.user_id;

    const existingDM = teamDirectMessages.find(dm => dm.partnerId === senderId);

    if (!existingDM) {
      console.log('✨ New DM conversation detected from:', senderId);

      // Fetch sender profile to add to list
      try {
        // We can use the cache or fetch fresh
        let profile = window.LayerDB.getCachedProfile ? window.LayerDB.getCachedProfile(senderId) : null;

        if (!profile) {
          const profiles = await window.LayerDB.fetchProfiles([senderId]);
          profile = profiles[0];
        } else {
          console.log('👤 Found profile in cache');
        }

        if (profile) {
          // Add to local state
          const newDM = {
            id: newRecord.channel_id.toLowerCase(),
            type: 'dm',
            partnerId: senderId,
            name: profile.name || profile.email,
            avatar: profile.avatar_url,
            email: profile.email,
            status: 'online', // We don't know status yet, assume online or fetch
            email: profile.email,
            status: 'online', // We don't know status yet, assume online or fetch
            unread: 1,
            lastMessage: {
              ...newRecord,
              user_profile: profile // Attach profile for easier rendering
            }
          };

          // Add to beginning of list
          teamDirectMessages.unshift(newDM);

          // Re-render the sidebar list
          // We need to find the specific element or re-render the whole list section
          // For now, let's call updateTeamChatArea() which re-renders everything
          // Or preferably just update the DOM if possible to avoid flickering

          updateTeamChatArea(); // This re-renders sidebar + main area. 
          updateTeamSidebar(); // Update sidebar specificially for better UX

          showNotification(`New message from ${profile.name}`, 'info');

          // Play notification sound if we had one
        }
      } catch (err) {
        console.error('Error handling new DM:', err);
      }
    } else {
      console.log('📨 Message for existing DM:', existingDM.name);
      // Update existing DM
      existingDM.lastMessage = newRecord;

      // Increment unread if we are not currently in this channel
      // Check if we are currently viewing this channel (case-insensitive check)
      const isCurrentChannel = teamCurrentChannel &&
        (teamCurrentChannel.toLowerCase() === existingDM.id.toLowerCase() ||
          teamCurrentChannel.toLowerCase() === newRecord.channel_id.toLowerCase());

      if (!isCurrentChannel) {
        // We are NOT in this channel, so increment unread
        existingDM.unread = (existingDM.unread || 0) + 1;
        updateTeamChatArea(); // Update badges
        updateTeamSidebar(); // Update sidebar badges
      } else {
        // We ARE in this channel.
        // Ensure the message is in our local state for the ACTIVE channel
        // We use teamCurrentChannel as the key to ensure the view updates
        const activeChannelId = teamCurrentChannel;

        if (!teamMessages[activeChannelId]) {
          teamMessages[activeChannelId] = [];
        }

        // Check if message already exists (avoid duplicates)
        const exists = teamMessages[activeChannelId].some(m => m.id === newRecord.id);

        if (!exists) {
          console.log('🔄 Global listener adding message to active view (redundancy)');

          // Convert to local format
          const localMessage = {
            id: newRecord.id,
            user: profile.name || profile.email || 'User',
            avatar: profile.avatar_url, // Use distinct avatar URL
            avatarUrl: profile.avatar_url,
            content: newRecord.message,
            time: new Date(newRecord.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            isSystem: newRecord.message_type === 'system',
            userId: newRecord.user_id,
            isEdited: newRecord.is_edited,
            editedAt: newRecord.edited_at
          };

          // Push to the array backing the CURRENT VIEW
          teamMessages[activeChannelId].push(localMessage);

          // Force UI update
          updateTeamChatArea();
        } else {
          updateTeamChatArea();
        }
      }
    }
  });
}

// 🚀 BACKGROUND PRELOADING: Load all DM messages in background for instant access
async function preloadAllDMMessages() {
  if (!teamDirectMessages || teamDirectMessages.length === 0) {
    console.log('⏭️ No DMs to preload');
    return;
  }

  console.log(`🚀 Preloading messages for ${teamDirectMessages.length} DM conversations...`);

  const startTime = Date.now();
  let loadedCount = 0;
  let errorCount = 0;

  // Load all DM messages in parallel for maximum speed
  const loadPromises = teamDirectMessages.map(async (dm) => {
    try {
      await loadTeamMessages(dm.id, 'dm');
      loadedCount++;
      console.log(`✅ Preloaded DM messages: ${dm.name || dm.id}`);
    } catch (error) {
      errorCount++;
      console.error(`❌ Failed to preload DM messages for ${dm.name || dm.id}:`, error);
    }
  });

  // Wait for all preloading to complete
  await Promise.allSettled(loadPromises);

  const duration = Date.now() - startTime;
  console.log(`🎉 DM message preloading complete! ${loadedCount}/${teamDirectMessages.length} loaded in ${duration}ms (${errorCount} errors)`);

  // Log which DMs are now ready for instant access
  const readyDMs = teamDirectMessages.filter(dm => teamMessages[dm.id] && teamMessages[dm.id].length > 0);
  console.log(`📱 ${readyDMs.length} DMs are now ready for instant access:`, readyDMs.map(dm => dm.name || dm.id));
}

// 🚀 APP-LEVEL BACKGROUND PRELOADING: Load DMs and their messages from app.js
async function preloadTeamDMMessages() {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    console.log('⏭️ Not authenticated, skipping DM preload');
    return;
  }

  try {
    console.log('🔄 Starting app-level DM and message preloading...');

    // Load DMs first
    const dms = await window.LayerDB.getDirectMessages();
    if (dms && dms.length > 0) {
      teamDirectMessages = dms;
      console.log(`📋 Loaded ${dms.length} DM conversations`);

      // Then preload all messages
      await preloadAllDMMessages();
    } else {
      console.log('⏭️ No DMs found to preload');
    }
  } catch (error) {
    console.error('❌ Failed to preload team DM data:', error);
  }
}

// Store multiple channel subscriptions for simultaneous real-time updates
// We now delegate to LayerRealtime in realtime.js, but we might verify here or just let it handle it.
// LayerRealtime manages its own map, so we don't strictly need activeChannelSubscriptions here anymore
// unless we want to track which ones *this specific view* requested.
// For simplicity, let's just use LayerRealtime directly.

async function setupTeamChatRealtime(channelId) {
  if (!window.LayerRealtime) {
    console.error('❌ LayerRealtime not available for channel:', channelId);
    throw new Error('LayerRealtime not available');
  }

  if (!channelId) {
    console.error('❌ No channelId provided for realtime setup');
    return;
  }

  console.log('🎧 Setting up realtime for channel:', channelId);

  try {
    // Setup new subscription for this channel
    window.LayerRealtime.subscribeToTeamChat(channelId, {
      onMessageReceived: (payload) => {
        console.log(`📨 Realtime message received for ${channelId}:`, payload);
        handleTeamChatRealtimeUpdate(payload, channelId);
      }
    });

    console.log(`✅ Realtime subscription setup complete for ${channelId}`);
  } catch (error) {
    console.error(`❌ Failed to setup realtime for ${channelId}:`, error);
    throw error; // Re-throw so caller can handle it
  }
}

// Setup subscriptions for all active DM conversations
async function setupAllDMSubscriptions() {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    console.log('⏭️ Skipping DM subscriptions - not authenticated');
    return;
  }

  console.log('🎧 Setting up subscriptions for all DM conversations...');

  try {
    // Subscribe to each DM conversation with error handling
    for (const dm of teamDirectMessages) {
      try {
        await setupTeamChatRealtime(dm.id);
        console.log(`✅ Subscribed to DM: ${dm.name || dm.id}`);
      } catch (error) {
        console.error(`❌ Failed to subscribe to DM ${dm.name || dm.id}:`, error);
        // Continue with other DMs even if one fails
      }
    }

    console.log('✓ All DM subscriptions attempted via LayerRealtime');
  } catch (error) {
    console.error('❌ Error setting up DM subscriptions:', error);
  }
}

// Cleanup a specific channel subscription
function unsubscribeFromChannel(channelId) {
  if (window.LayerRealtime) {
    window.LayerRealtime.unsubscribeFromTeamChat(channelId);
  }
}

// Cleanup all subscriptions (call on logout or page unload)
function cleanupAllChatSubscriptions() {
  console.log('🔇 Cleaning up all chat subscriptions...');

  // Stop global DM polling
  stopGlobalDMPolling();

  // We can't easily iterate all subscriptions if we don't track them locally or ask LayerRealtime.
  // But strictly, we only need to unsubscribe when the user leaves the context.
  // For now, if we want to clear everything, we might need a method in LayerRealtime to clear all.
  // OR we can just unsubscribe from the current channel if we are switching.

  if (teamCurrentChannel && window.LayerRealtime) {
    window.LayerRealtime.unsubscribeFromTeamChat(teamCurrentChannel);
  }

  if (globalDMSubscription) {
    window.LayerDB.unsubscribeFromTeamMessages(globalDMSubscription);
    globalDMSubscription = null;
  }
}

// Handle realtime updates for team chat
async function handleTeamChatRealtimeUpdate(payload, subscriptionChannelId) {
  const { eventType, new: newRecord, old: oldRecord } = payload;
  const currentUser = window.LayerDB?.getCurrentUser();

  if (eventType === 'INSERT') {
    const channelId = newRecord.channel_id.toLowerCase();

    // Skip if this is our own message (already added optimistically)
    if (newRecord.user_id === currentUser?.id) {
      // Check if we already have this message
      if (teamMessages[channelId]) {
        const exists = teamMessages[channelId].some(m => m.id === newRecord.id);
        if (exists) {
          console.log('⏭️ Skipping own message (already in UI)');
          return;
        }
      }
    }

    // Skip if message already exists locally
    if (teamMessages[channelId]) {
      const exists = teamMessages[channelId].some(m => m.id === newRecord.id);
      if (exists) {
        console.log('⏭️ Skipping duplicate message');
        return;
      }
    }

    // Resolve user profile for the message sender
    let userName = 'User';
    let userAvatar = 'U';
    let avatarUrl = null;

    if (newRecord.user_id === currentUser?.id) {
      userName = currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0] || 'You';
      userAvatar = userName.charAt(0).toUpperCase();
      avatarUrl = currentUser?.user_metadata?.avatar_url || null;
    } else {
      // Fetch profile from cache or DB
      try {
        if (window.LayerDB?.fetchProfiles) {
          await window.LayerDB.fetchProfiles([newRecord.user_id]);
        }
        const profile = window.LayerDB?.getCachedProfile?.(newRecord.user_id);
        if (profile) {
          userName = profile.name || profile.email?.split('@')[0] || 'User';
          userAvatar = userName.charAt(0).toUpperCase();
          avatarUrl = profile.avatar_url || null;
        }
      } catch (e) {
        console.warn('Failed to fetch profile for realtime message:', e);
      }
    }

    const localMessage = {
      id: newRecord.id,
      user: userName,
      avatar: userAvatar,
      avatarUrl: avatarUrl,
      content: newRecord.message,
      time: new Date(newRecord.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
      isSystem: newRecord.message_type === 'system',
      userId: newRecord.user_id,
      isEdited: newRecord.is_edited,
      editedAt: newRecord.edited_at,
      isRead: newRecord.is_read || false, // Include read status
      reactions: newRecord.reactions || {} // Include reactions from database
    };

    if (!teamMessages[channelId]) {
      teamMessages[channelId] = [];
    }
    teamMessages[channelId].push(localMessage);

    console.log('📨 New message received:', {
      channel: channelId,
      from: userName,
      isCurrentChannel: teamCurrentChannel === channelId
    });

    // Check if we're viewing this channel (case-insensitive)
    const isCurrentChannel = teamCurrentChannel &&
      (teamCurrentChannel.toLowerCase() === channelId.toLowerCase() ||
        (subscriptionChannelId && teamCurrentChannel.toLowerCase() === subscriptionChannelId.toLowerCase()));

    console.log('🔄 UI Update Check:', {
      isCurrentChannel,
      teamCurrentChannel,
      channelId,
      subscriptionChannelId
    });

    if (isCurrentChannel) {
      // Update UI immediately for current channel
      console.log("✨ Updating current channel UI for new message. Channel:", channelId);
      console.log("Current teamCurrentChannel:", teamCurrentChannel);
      console.log("Messages before render:", teamMessages[channelId]?.length);

      // Update local message list if it exists
      if (typeof updateTeamChatArea === "function") {
        updateTeamChatArea();
        console.log("✅ updateTeamChatArea called");
      } else if (typeof renderCurrentView === "function") {
        renderCurrentView();
        console.log("✅ renderCurrentView called");
      } else {
        console.error("❌ No render function found!");
      }

      // Use enhanced scroll manager for smooth auto-scroll
      if (chatScrollManager) {
        chatScrollManager.addNewMessage();
        console.log("📜 Enhanced scroll manager triggered");
      }
    } else {
      const dm = teamDirectMessages.find(d => d.id.toLowerCase() === channelId.toLowerCase());
      if (dm) {
        dm.unread = (dm.unread || 0) + 1;
        dm.lastMessage = newRecord;

        // Update sidebar to show unread badge
        updateTeamSidebar();

        // Show notification
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification(`New message from ${userName}`, {
            body: newRecord.message.substring(0, 100),
            icon: avatarUrl || '/default-avatar.png',
            tag: channelId
          });
        } else {
          try {
            // Only show toast if not visible to avoid spam
            const existingToast = document.querySelector(`.notification[data-channel="${channelId}"]`);
            if (!existingToast) {
              showNotification(`New message from ${userName}`, 'info');
            }
          } catch (e) { }
        }

        // Play notification sound (optional)
        playNotificationSound();
      }
    }
  } else if (eventType === 'UPDATE') {
    const channelId = newRecord.channel_id;
    if (teamMessages[channelId]) {
      const messageIndex = teamMessages[channelId].findIndex(msg => msg.id === newRecord.id);
      if (messageIndex !== -1) {
        teamMessages[channelId][messageIndex] = {
          ...teamMessages[channelId][messageIndex],
          content: newRecord.message,
          isEdited: newRecord.is_edited,
          editedAt: newRecord.edited_at
        };

        if (teamCurrentChannel === channelId) {
          updateTeamChatArea();
        }
      }
    }
  } else if (eventType === 'DELETE') {
    const channelId = oldRecord.channel_id;
    if (teamMessages[channelId]) {
      teamMessages[channelId] = teamMessages[channelId].filter(msg => msg.id !== oldRecord.id);

      if (teamCurrentChannel === channelId) {
        updateTeamChatArea();
      }
    }
  }
}

// Play notification sound for new messages
function playNotificationSound() {
  try {
    // Create a subtle notification sound using Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    oscillator.frequency.value = 800;
    oscillator.type = 'sine';

    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.1);
  } catch (e) {
    // Silently fail if audio not supported
  }
}

// ============================================
// Realtime Subscriptions
// ============================================

let realtimeSubscriptions = {
  projects: null,
  calendarEvents: null,
  docs: null
};

// Initialize all realtime subscriptions
async function initializeRealtimeSubscriptions() {
  if (!currentUser) return;

  try {
    // Subscribe to projects changes
    realtimeSubscriptions.projects = api.subscribeToProjects((payload) => {
      handleProjectRealtimeUpdate(payload);
    });

    // Subscribe to calendar events changes
    realtimeSubscriptions.calendarEvents = api.subscribeToCalendarEvents((payload) => {
      handleCalendarEventRealtimeUpdate(payload);
    });

    // Subscribe to docs changes
    realtimeSubscriptions.docs = api.subscribeToDocs((payload) => {
      handleDocRealtimeUpdate(payload);
    });

    console.log('Realtime subscriptions initialized');
  } catch (error) {
    console.error('Failed to initialize realtime subscriptions:', error);
  }
}

// Refresh team members display in project detail view
function refreshTeamMembersDisplay(projectIndex) {
  console.log('Refreshing team members display for project:', projectIndex);

  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) {
    console.error('Project not found:', projectIndex);
    return;
  }

  console.log('Project team members:', project.teamMembers);

  // Update team members section if it exists
  const teamMembersSection = document.querySelector('.pd-team-members .team-members-list');
  if (teamMembersSection) {
    const teamMembersHtml = window.renderTeamMembersList ? window.renderTeamMembersList(project, projectIndex) : generateTeamMembersHtml(project, projectIndex);
    teamMembersSection.innerHTML = teamMembersHtml;
    console.log('Team members section updated');
  } else {
    console.warn('Team members section not found');
  }

  // Update project header members if it exists
  const projectHeaderMembers = document.querySelector('.pd-project-members');
  if (projectHeaderMembers) {
    const membersHtml = generateProjectMembersHtml(project);
    projectHeaderMembers.innerHTML = membersHtml;
    console.log('Project header members updated');
  }
}

// Make function globally available
window.refreshTeamMembersDisplay = refreshTeamMembersDisplay;

// Generate vibrant color based on name
function getNameColor(name) {
  // Vibrant color palette
  const colors = [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
    '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
    '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2'
  ];

  let hash = 0;
  for (let i = 0; i < name.length; i++) {
    hash = name.charCodeAt(i) + ((hash << 5) - hash);
  }
  return colors[Math.abs(hash) % colors.length];
}

// Generate team members HTML for project detail view
function generateTeamMembersHtml(project, projectIndex) {
  const teamMembers = project.teamMembers || [];
  const isOwner = isProjectOwner(projectIndex);

  let html = `
    <div class="pd-team-members">
      <div class="pd-section-header">
        <h3 class="pd-section-title">Team Members</h3>
        <div class="pd-team-stats">
          <span class="pd-team-count">${teamMembers.length} member${teamMembers.length !== 1 ? 's' : ''}</span>
          ${project.leader ? `<span class="pd-team-leader">Lead: ${project.leader}</span>` : ''}
        </div>
      </div>
      <div class="team-members-list">
  `;

  teamMembers.forEach((member, index) => {
    const isCurrentUser = member === (window.getCurrentUserEmail ? window.getCurrentUserEmail() : '') || member === 'You';
    const memberName = member === 'You' ? (window.getCurrentUserName ? window.getCurrentUserName() : 'You') : member;
    const isLeader = project.leader === memberName;

    html += `
      <div class="team-member-item ${isCurrentUser ? 'current-user' : ''} ${isLeader ? 'team-leader' : ''}" 
           ${isOwner && !isCurrentUser ? `oncontextmenu="showMemberContextMenu(event, '${member}', ${projectIndex}, ${index})"` : ''}>
        <div class="member-avatar" style="background: ${getNameColor(memberName)}; color: white;">
          ${memberName.charAt(0).toUpperCase()}
        </div>
        <div class="member-info">
          <div class="member-name">
            ${memberName}
            ${isLeader ? '<i class="fas fa-crown" style="color: gold; margin-left: 4px; font-size: 12px;" title="Project Leader"></i>' : ''}
          </div>
          ${isCurrentUser ? '<div class="member-role">You</div>' : isLeader ? '<div class="member-role">Leader</div>' : ''}
        </div>
        ${isOwner && !isCurrentUser && !isLeader ? `
          <button class="team-member-action" onclick="showMemberContextMenu(event, '${member}', ${projectIndex}, ${index})" title="Manage member">
            <i class="fas fa-ellipsis-v"></i>
          </button>
        ` : ''}
      </div>
    `;
  });

  html += '</div>';

  // Add member button - only for project owners
  if (isOwner) {
    html += `
      <button class="pd-add-member-btn" onclick="openInviteMemberModal(${projectIndex})">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="12" y1="5" x2="12" y2="19"/>
          <line x1="5" y1="12" x2="19" y2="12"/>
        </svg>
        Add Team Member
      </button>
    `;
  }

  html += '</div>';
  return html;
}

// Generate project members HTML for project header
function generateProjectMembersHtml(project) {
  const teamMembers = project.teamMembers || [];
  const maxDisplay = 3;
  const displayMembers = teamMembers.slice(0, maxDisplay);
  const remainingCount = teamMembers.length - maxDisplay;

  let html = '<div class="pd-project-members">';

  displayMembers.forEach(member => {
    const memberName = member === 'You' ? getCurrentUserName() : member;
    const initial = memberName.charAt(0).toUpperCase();

    html += `
      <div class="pd-member-avatar" title="${memberName}">
        ${initial}
      </div>
    `;
  });

  if (remainingCount > 0) {
    html += `
      <div class="pd-member-avatar pd-more-members" title="${remainingCount} more members">
        +${remainingCount}
      </div>
    `;
  }

  html += '</div>';
  return html;
}

// Handle project updates
function handleProjectRealtimeUpdate(payload) {
  console.log('Real-time project update received:', payload);

  const { eventType, new: newRecord, old: oldRecord } = payload;

  if (eventType === 'INSERT') {
    // Add new project to local state
    projects.push(newRecord);
  } else if (eventType === 'UPDATE') {
    // Update existing project
    const index = projects.findIndex(p => p.id === newRecord.id);
    if (index !== -1) {
      const oldProject = projects[index];
      projects[index] = newRecord;

      // Check if team members changed
      const oldMembers = oldProject.team_members || [];
      const newMembers = newRecord.team_members || [];
      const membersChanged = JSON.stringify(oldMembers.sort()) !== JSON.stringify(newMembers.sort());

      console.log('Team members change detected:', {
        oldMembers,
        newMembers,
        membersChanged,
        currentView
      });

      if (membersChanged) {
        console.log('Team members changed, refreshing team display');

        // Refresh only the team members display for better UX
        if (currentView === 'project-detail') {
          refreshTeamMembersDisplay(index);
        }

        // Show notification for member changes
        const addedMembers = newMembers.filter(m => !oldMembers.includes(m));
        const removedMembers = oldMembers.filter(m => !newMembers.includes(m));

        if (addedMembers.length > 0) {
          showNotification(`${addedMembers.join(', ')} joined the project`, 'success');
        }
        if (removedMembers.length > 0) {
          showNotification(`${removedMembers.join(', ')} left the project`, 'info');
        }

        // Also update local storage to keep in sync
        const localProjects = loadProjects();
        if (localProjects[index]) {
          localProjects[index].teamMembers = newMembers;
          saveProjects(localProjects);
        }

        return; // Don't do full refresh if only members changed
      }
    }
  } else if (eventType === 'DELETE') {
    // Remove project from local state
    projects = projects.filter(p => p.id !== oldRecord.id);
  }

  // Refresh current view if needed (for non-member changes)
  if (currentView === 'projects' || currentView === 'project-detail') {
    renderCurrentView();
  }
}

// Handle calendar event updates
function handleCalendarEventRealtimeUpdate(payload) {
  const { eventType, new: newRecord, old: oldRecord } = payload;

  if (eventType === 'INSERT') {
    // Add new event to calendar
    calendarEvents.push(newRecord);
  } else if (eventType === 'UPDATE') {
    // Update existing event
    const index = calendarEvents.findIndex(e => e.id === newRecord.id);
    if (index !== -1) {
      calendarEvents[index] = newRecord;
    }
  } else if (eventType === 'DELETE') {
    // Remove event from calendar
    calendarEvents = calendarEvents.filter(e => e.id !== oldRecord.id);
  }

  // Refresh calendar view if needed
  if (currentView === 'calendar') {
    renderCurrentView();
  }
}

// Handle doc updates
function handleDocRealtimeUpdate(payload) {
  const { eventType, new: newRecord, old: oldRecord } = payload;

  if (eventType === 'INSERT') {
    // Add new doc
    docs.push(newRecord);
  } else if (eventType === 'UPDATE') {
    // Update existing doc
    const index = docs.findIndex(d => d.id === newRecord.id);
    if (index !== -1) {
      docs[index] = newRecord;
    }
  } else if (eventType === 'DELETE') {
    // Remove doc
    docs = docs.filter(d => d.id !== oldRecord.id);
  }

  // Refresh docs view if needed
  if (currentView === 'docs') {
    renderCurrentView();
  }
}

// Cleanup all realtime subscriptions
function cleanupRealtimeSubscriptions() {
  Object.values(realtimeSubscriptions).forEach(subscription => {
    if (subscription) {
      api.supabase.removeChannel(subscription);
    }
  });

  // Cleanup team chat subscription
  if (currentTeamChatSubscription) {
    api.unsubscribeFromTeamMessages(currentTeamChatSubscription);
    currentTeamChatSubscription = null;
  }

  realtimeSubscriptions = {
    projects: null,
    calendarEvents: null,
    docs: null
  };
}

function handleTeamMessageKeydown(event) {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendTeamMessage();
  }
}


// Modal Functions for Team Features
function openCreateChannelModal() {
  openModal('Create Channel', `
    <div class="modal-form">
      <div class="form-group">
        <label>Channel Name</label>
        <input type="text" id="newChannelName" placeholder="e.g., design-team" class="form-input">
      </div>
      <div class="form-group">
        <label>Description (optional)</label>
        <textarea id="newChannelDesc" placeholder="What is this channel about?" class="form-textarea"></textarea>
      </div>
      <div class="form-actions">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-primary" onclick="createNewChannel()">Create Channel</button>
      </div>
    </div>
  `);
}

function openCreateMessageModal() {
  openModal('New Message', `
    <div class="modal-form">
      <div class="form-group">
        <label>To</label>
        <input type="text" id="dmRecipient" placeholder="Search for a team member..." class="form-input">
      </div>
      <div class="form-actions">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-primary" onclick="startDirectMessage()">Start Conversation</button>
      </div>
    </div>
  `);
}

function openCreateGroupModal() {
  const projects = JSON.parse(localStorage.getItem('layerProjectsData') || '[]');

  openModal('Create Group', `
    <div class="modal-form">
      <div class="form-group">
        <label>Group Name</label>
        <input type="text" id="newGroupName" placeholder="e.g., Marketing Team" class="form-input">
      </div>
      <div class="form-group">
        <label>Link to Project (optional)</label>
        <select id="groupLinkedProject" class="form-select">
          <option value="">No project linked</option>
          ${projects.map(p => `<option value="${p.name}">${p.name}</option>`).join('')}
        </select>
      </div>
      <div class="form-group">
        <label>Add Members</label>
        <input type="text" id="groupMembers" placeholder="Search for team members..." class="form-input">
      </div>
      <div class="form-actions">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-primary" onclick="createNewGroup()">Create Group</button>
      </div>
    </div>
  `);
}

// Toggle Add People Dropdown
function toggleAddPeopleDropdown() {
  const dropdown = document.getElementById('addPeopleDropdown');
  if (dropdown) {
    const isVisible = dropdown.style.display !== 'none';
    dropdown.style.display = isVisible ? 'none' : 'block';

    // Adjust position to stay within viewport
    if (!isVisible) {
      // Wait for the dropdown to be displayed to get accurate measurements
      setTimeout(() => {
        const rect = dropdown.getBoundingClientRect();
        const viewportWidth = window.innerWidth;

        // If dropdown extends beyond right edge, adjust position
        if (rect.right > viewportWidth) {
          const overflow = rect.right - viewportWidth;
          dropdown.style.left = `-${overflow + 10}px`;
        } else {
          // Reset to default position
          dropdown.style.left = '0';
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function closeDropdown(e) {
          if (!dropdown.contains(e.target) && !e.target.closest('.team-add-people-btn')) {
            dropdown.style.display = 'none';
            dropdown.style.left = '0'; // Reset position
            document.removeEventListener('click', closeDropdown);
          }
        });
      }, 10);
    } else {
      // Reset position when hiding
      dropdown.style.left = '0';
    }
  }
}

// Add people from dropdown
async function addPeopleFromDropdown() {
  const emailInput = document.getElementById('dropdownInviteEmail');
  const messageInput = document.getElementById('dropdownInviteMessage');
  const email = emailInput?.value?.trim();
  const message = messageInput?.value?.trim();

  if (!email) {
    showNotification('Please enter an email address', 'error');
    return;
  }

  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    showNotification('Please enter a valid email address', 'error');
    return;
  }

  // Check if trying to add self
  const currentUser = window.LayerDB.getCurrentUser();
  if (currentUser?.email === email) {
    showNotification('You cannot add yourself', 'error');
    return;
  }

  try {
    // Follow user by email (creates follow request)
    await window.LayerDB.followUserByEmail(email);

    // Send email notification
    const currentUserName = currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0] || 'Someone';
    await window.LayerDB.sendFollowerNotificationEmail(email, currentUserName, 'follow');

    // Close dropdown
    const dropdown = document.getElementById('addPeopleDropdown');
    if (dropdown) {
      dropdown.style.display = 'none';
    }

    // Clear form
    emailInput.value = '';
    messageInput.value = '';

    showNotification(`Follow request sent to ${email}! They will receive an email notification and can accept in their followers sidebar.`, 'success');

    // Refresh team view to show pending invitations
    setTimeout(() => {
      renderCurrentView();
    }, 1000);

  } catch (error) {
    console.error('Error sending follow request:', error);

    // Provide more specific error messages
    let errorMessage = error.message;
    if (errorMessage?.includes('already following')) {
      errorMessage = 'You are already following this user';
    } else if (errorMessage?.includes('Not authenticated')) {
      errorMessage = 'Please sign in again';
    } else if (errorMessage?.includes('Invalid email')) {
      errorMessage = 'Please enter a valid email address';
    } else if (!errorMessage) {
      errorMessage = 'Failed to send follow request. Please try again.';
    }

    showNotification(errorMessage, 'error');
  }
}

async function openAddPeopleModal() {
  // Check if user is authenticated
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showNotification('Please sign in to add people', 'error');
    openAuthModal();
    return;
  }

  const currentUser = window.LayerDB.getCurrentUser();

  // Load existing team members and followers
  let existingMembers = [];
  let pendingInvitations = [];

  try {
    // Get accepted followers
    const followers = await window.LayerDB.getFollowers();
    existingMembers = followers.filter(f => f.status === 'accepted').map(f => ({
      id: f.following_id || f.follower_id,
      email: f.following_email || f.follower_email,
      name: f.following_name || f.follower_name || 'Unknown',
      avatar: f.following_avatar || f.follower_avatar,
      status: 'accepted'
    }));

    // Get pending invitations
    pendingInvitations = await window.LayerDB.getPendingFollowRequests();
  } catch (error) {
    console.error('Error loading team members:', error);
  }

  openModal('Add People to Team', `
    <div class="team-add-people-modal">
      <div class="team-auth-section">
        <div class="current-user-info">
          <div class="user-avatar-large">
            ${currentUser?.user_metadata?.avatar_url ?
      `<img src="${currentUser.user_metadata.avatar_url}" alt="Avatar">` :
      `<span>${(currentUser?.email?.[0] || 'U').toUpperCase()}</span>`
    }
          </div>
          <div class="user-details">
            <div class="user-name">${currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0] || 'User'}</div>
            <div class="user-email">
              <span>${currentUser?.email || 'Not signed in'}</span>
              ${currentUser?.email ? '<span class="email-status verified">✓ Signed In</span>' : ''}
            </div>
          </div>
        </div>
      </div>
      
      <div class="team-invite-section">
        <div class="section-header">
          <h3>Add by Email</h3>
          <p class="section-description">Add a registered user to your team by entering their account email address.</p>
        </div>
        <div class="form-group">
          <label>Email Address</label>
          <input type="email" id="inviteEmail" placeholder="colleague@example.com" class="form-input" autocomplete="email">
          <small class="form-help">Enter the email address of a user who has an account on this app</small>
        </div>
        <div class="form-group">
          <label>Custom Message (Optional)</label>
          <textarea id="inviteMessage" placeholder="Hey! I'd like to collaborate with you on Layer..." class="form-textarea" rows="3"></textarea>
        </div>
        <div class="form-actions">
          <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
          <button class="btn btn-primary" onclick="inviteTeamMember()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:6px;">
              <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
              <circle cx="8.5" cy="7" r="4"/>
              <line x1="20" y1="8" x2="20" y2="14"/>
              <line x1="23" y1="11" x2="17" y2="11"/>
            </svg>
            Add Member
          </button>
        </div>
      </div>
      
      ${existingMembers.length > 0 ? `
        <div class="team-members-section">
          <div class="section-header">
            <h3>Team Members (${existingMembers.length})</h3>
          </div>
          <div class="team-members-list">
            ${existingMembers.map(member => `
              <div class="team-member-item">
                <div class="member-avatar">
                  ${member.avatar ?
        `<img src="${member.avatar}" alt="${member.name}">` :
        `<span>${member.name[0].toUpperCase()}</span>`
      }
                </div>
                <div class="member-info">
                  <div class="member-name">${member.name}</div>
                  <div class="member-email">${member.email}</div>
                </div>
                <div class="member-status">
                  <span class="status-badge active">Active</span>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      ` : ''}
      
      ${pendingInvitations.length > 0 ? `
        <div class="team-pending-section">
          <div class="section-header">
            <h3>Pending Invitations (${pendingInvitations.length})</h3>
          </div>
          <div class="pending-invitations-list">
            ${pendingInvitations.map(inv => `
              <div class="pending-invitation-item">
                <div class="invitation-info">
                  <div class="invitation-email">${inv.invitee_email || inv.following_email || 'Unknown'}</div>
                  <div class="invitation-time">Sent ${formatTimeAgo(inv.created_at)}</div>
                </div>
                <div class="invitation-status">
                  <span class="status-badge pending">Pending</span>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      ` : ''}
    </div>
  `);
}

async function inviteTeamMember(event) {
  const emailInput = document.getElementById('inviteEmail');
  const messageInput = document.getElementById('inviteMessage');
  const email = emailInput?.value?.trim();
  const message = messageInput?.value?.trim() || '';

  if (!email) {
    showNotification('Please enter an email address', 'error');
    return;
  }

  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    showNotification('Please enter a valid email address', 'error');
    return;
  }

  // Check if trying to add self
  const currentUser = window.LayerDB.getCurrentUser();
  if (!currentUser) {
    showNotification('Please sign in first', 'error');
    openAuthModal();
    return;
  }

  if (currentUser?.email === email) {
    showNotification('You cannot add yourself', 'error');
    return;
  }

  // Show loading state
  const submitBtn = event?.target || document.querySelector('.btn-primary');
  const originalText = submitBtn ? submitBtn.innerHTML : '';
  if (submitBtn) {
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="spinner"></span> Adding...';
  }

  try {
    // First check if the user exists in the DB
    const { data: userProfile, error: profileError } = await window.LayerDB.supabase
      .from('profiles')
      .select('id, email, name')
      .ilike('email', email)
      .maybeSingle();

    if (profileError || !userProfile) {
      showNotification(`No user found with email ${email}. They must have an account first.`, 'error');
      if (submitBtn) {
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalText;
      }
      return;
    }

    // Create a follow request for the found user
    try {
      await window.LayerDB.followUserByEmail(email);
    } catch (followError) {
      if (followError.message?.includes('already following')) {
        showNotification('This user is already in your team or has a pending request.', 'info');
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.innerHTML = originalText;
        }
        return;
      }
      throw followError;
    }

    closeModal();
    showNotification(`Team request sent to ${userProfile.name || email}! They can accept it in their Team panel.`, 'success');

    // Refresh team members panel
    const panel = document.getElementById('teamMembersPanel');
    if (panel) {
      const newContent = await renderTeamMembersPanel();
      panel.innerHTML = newContent;
    }
  } catch (error) {
    console.error('Error adding team member:', error);
    showNotification(error.message || 'Failed to add member. Please try again.', 'error');
    if (submitBtn) {
      submitBtn.disabled = false;
      submitBtn.innerHTML = originalText;
    }
  }
}

function createNewChannel() {
  const name = document.getElementById('newChannelName')?.value?.trim();
  if (!name) {
    showNotification('Please enter a channel name', 'error');
    return;
  }

  const newChannel = {
    id: 'ch-' + Date.now(),
    name: name,
    type: 'channel',
    unread: 0,
    icon: 'hash'
  };

  teamChannels.push(newChannel);
  teamMessages[newChannel.id] = [];
  teamCurrentChannel = newChannel.id;

  closeModal();
  showNotification(`Channel #${name} created!`, 'success');
  renderCurrentView();
}

function createNewGroup() {
  const name = document.getElementById('newGroupName')?.value?.trim();
  const linkedProject = document.getElementById('groupLinkedProject')?.value;

  if (!name) {
    showNotification('Please enter a group name', 'error');
    return;
  }

  const newGroup = {
    id: 'grp-' + Date.now(),
    name: name,
    members: 1,
    linkedProject: linkedProject || null
  };

  teamGroups.push(newGroup);

  closeModal();
  showNotification(`Group "${name}" created!`, 'success');
  renderCurrentView();
}

function openTeamSearchModal() {
  openModal('Search', `
    <div class="modal-form">
      <input type="text" placeholder="Search messages, channels, people..." class="form-input" autofocus>
    </div>
  `);
}

function openTeamCallModal() {
  // Voice/video calls not available
}

function openTeamShareModal() {
  openModal('Share Channel', `
    <div class="modal-form">
      <p>Share this channel with others</p>
      <div class="form-group">
        <input type="text" value="${window.location.href}" readonly class="form-input" onclick="this.select()">
      </div>
      <div class="form-actions">
        <button class="btn btn-primary" onclick="navigator.clipboard.writeText(window.location.href); showNotification('Link copied!', 'success'); closeModal();">Copy Link</button>
      </div>
    </div>
  `);
}

function openTeamAI() {
  showNotification('AI assistant for chat coming soon!', 'info');
}

function toggleAutomation() {
  showNotification('Automation features coming soon!', 'info');
}

function addTeamView() {
  showNotification('Custom views coming soon!', 'info');
}

function importFromSlack() {
  showNotification('Slack import coming soon!', 'info');
}

function openTrackTasksModal() {
  showNotification('Task tracking integration coming soon!', 'info');
}

function openAddDocModal() {
  if (typeof openDocEditor === 'function') {
    openDocEditor();
  } else {
    showNotification('Doc editor coming soon!', 'info');
  }
}

function startSyncUp() {
  // Not available
}

function startDirectMessage() {
  closeModal();
  showNotification('Direct message started!', 'success');
}

async function addPeopleToChannel() {
  const emailInput = document.getElementById('inviteEmail');
  const email = emailInput?.value?.trim();

  if (!email) {
    showNotification('Please enter an email address', 'error');
    return;
  }

  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    showNotification('Please enter a valid email address', 'error');
    return;
  }

  // Check if trying to add self
  const currentUser = window.LayerDB.getCurrentUser();
  if (currentUser?.email === email) {
    showNotification('You cannot add yourself', 'error');
    return;
  }

  try {
    // Follow user by email (creates follow request)
    await window.LayerDB.followUserByEmail(email);

    // Send email notification
    const currentUserName = currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0] || 'Someone';
    await window.LayerDB.sendFollowerNotificationEmail(email, currentUserName, 'follow');

    closeModal();
    showNotification(`Follow request sent to ${email}! They will receive an email notification and can accept in their followers sidebar.`, 'success');

    // Refresh team view to show pending invitations
    setTimeout(() => {
      renderCurrentView();
    }, 1000);

  } catch (error) {
    console.error('Error sending follow request:', error);

    // Provide more specific error messages
    let errorMessage = error.message;
    if (errorMessage.includes('does not have an account')) {
      errorMessage += ' Make sure the user has signed up with Google and try again.';
    } else if (errorMessage.includes('already following')) {
      errorMessage = 'You are already following this user.';
    }

    showNotification('Failed to send follow request: ' + errorMessage, 'error');
  }
}

function toggleMessageTypeDropdown() {
  showNotification('Message types coming soon!', 'info');
}

async function acceptFollowRequest(requestId, followerId) {
  try {
    // Accept the follow request
    await window.LayerDB.acceptFollowRequest(followerId);

    // Send acceptance email
    const currentUser = window.LayerDB.getCurrentUser();
    const currentUserName = currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0] || 'Someone';

    // Get follower's email (this would need to be fetched from the request data)
    const request = pendingFollowRequests.find(r => r.id === requestId);
    if (request?.follower_profile?.email) {
      await window.LayerDB.sendFollowerNotificationEmail(
        request.follower_profile.email,
        currentUserName,
        'accept'
      );
    }

    // Remove from pending requests
    pendingFollowRequests = pendingFollowRequests.filter(r => r.id !== requestId);

    // Add to followers list
    const follower = request?.follower_profile;
    if (follower) {
      teamFollowers.push({
        id: `f-${followerId}`,
        name: follower.name || follower.email,
        avatar: follower.name?.charAt(0) || follower.email?.charAt(0) || '?',
        email: follower.email
      });
    }

    showNotification('Follow request accepted!', 'success');
    renderCurrentView();

  } catch (error) {
    console.error('Error accepting follow request:', error);
    showNotification('Failed to accept follow request: ' + error.message, 'error');
  }
}

async function rejectFollowRequest(requestId, followerId) {
  try {
    // Reject the follow request
    await window.LayerDB.rejectFollowRequest(followerId);

    // Remove from pending requests
    pendingFollowRequests = pendingFollowRequests.filter(r => r.id !== requestId);

    showNotification('Follow request rejected', 'info');
    renderCurrentView();

  } catch (error) {
    console.error('Error rejecting follow request:', error);
    showNotification('Failed to reject follow request: ' + error.message, 'error');
  }
}



/* ============================================
   Layer - Settings View (Professional Layout)
   ============================================ */

async function renderSettingsView() {
  const currentTheme = localStorage.getItem('layerTheme') || 'dark';
  const appVersion = '0.3.0';
  const lastSync = new Date().toLocaleString();

  // Get current user info - ONLY use saved profile name, never Google metadata
  const currentUser = window.LayerDB?.getCurrentUser();
  let name = 'User';
  let email = 'Not signed in';
  
  if (currentUser) {
    email = currentUser.email || 'Not signed in';
    
    // ONLY try to get saved profile name from database (async for fresh data)
    try {
      const profile = await window.LayerDB?.getProfile();
      if (profile && profile.name) {
        name = profile.name;
        console.log('renderSettingsView: Using saved profile name (IGNORING Google):', name);
      } else {
        // If no saved profile, use email split (NEVER use Google metadata)
        name = currentUser.email?.split('@')[0] || 'User';
        console.log('renderSettingsView: No saved profile, using email split (NOT Google name):', name);
      }
    } catch (error) {
      // If error getting profile, use email split (NEVER use Google metadata)
      name = currentUser.email?.split('@')[0] || 'User';
      console.log('renderSettingsView: Error getting profile, using email split (NOT Google name):', name);
    }
  } else {
    // Fallback to localStorage only if no database user
    const savedName = localStorage.getItem('userDisplayName');
    if (savedName && savedName !== 'User') {
      name = savedName;
      console.log('renderSettingsView: Using localStorage fallback:', name);
    }
  }

  // Load notification settings
  const notifyDeadlines = localStorage.getItem('layerNotifyDeadlines') !== 'false';
  const notifyReminders = localStorage.getItem('layerNotifyReminders') !== 'false';
  const notifySounds = localStorage.getItem('layerNotifySounds') !== 'false';
  const notifyEmail = localStorage.getItem('layerNotifyEmail') === 'true';

  // Full list of all available themes
  const themes = [
    { value: 'dark', label: 'Dark (Default)' },
    { value: 'light', label: 'Light' },
    { value: 'pink', label: 'Pink' },
    { value: 'purple', label: 'Purple' },
    { value: 'ocean', label: 'Ocean' },
    { value: 'forest', label: 'Forest' },
    { value: 'darklime', label: 'Dark Lime' },
    { value: 'midnight', label: 'Midnight Blue' },
    { value: 'dracula', label: 'Dracula' },
    { value: 'gruvbox', label: 'Gruvbox Dark' },
    { value: 'rosepine', label: 'Rosé Pine' },
    { value: 'claude', label: 'Claude' },
  ];

  // Helper for avatar
  const getAvatarHtml = (user) => {
    if (!user) return '<div class="settings-avatar-placeholder">?</div>';

    // Use metadata or direct properties
    const meta = user.user_metadata || {};
    const photoUrl = meta.avatar_url || meta.picture || user.avatar_url;
    const name = meta.full_name || meta.name || user.email?.split('@')[0] || 'User';

    if (photoUrl) {
      return `<img src="${photoUrl}" alt="${name}" class="settings-avatar-img">`;
    }

    return `<div class="settings-avatar-placeholder">?</div>`;
  };

  return `
    <div class="settings-container">
      <!-- Header -->
      <div class="view-header">
        <h1 class="view-title">Settings</h1>
        <p class="view-subtitle">Manage your account and preferences</p>
      </div>

      <!-- Account Section -->
      <div class="settings-section card">
        <h3 class="section-title">Account</h3>
        
        <div class="settings-profile-card" id="profileCard">
          <div class="settings-avatar-wrapper">
            ${getAvatarHtml(currentUser)}
          </div>
          <div style="flex: 1;">
            <!-- View Mode -->
            <div id="profileViewMode">
              <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                <h4 id="displayName" style="margin: 0; font-size: 20px; font-weight: 700; color: var(--foreground);">${name}</h4>
                <button class="btn-edit-profile" onclick="toggleEditMode()" title="Edit profile">
                  <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                  </svg>
                </button>
              </div>
              <p style="margin: 4px 0 0; font-size: 14px; color: var(--muted-foreground);">${email}</p>
              <div style="margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
                <span class="badge badge-sm" style="background: var(--primary); color: white;">Free Plan</span>
                ${currentUser ? `<span class="badge badge-sm" style="background: var(--muted); color: var(--muted-foreground);">ID: ${currentUser.id.substring(0, 8)}...</span>` : ''}
              </div>
            </div>
            
            <!-- Edit Mode -->
            <div id="profileEditMode" style="display: none;">
              <div class="profile-edit-header">
                <span class="edit-indicator">Editing Profile</span>
              </div>
              
              <div class="form-group-advanced">
                <label class="form-label" for="usernameInput">Username</label>
                <div class="input-wrapper-advanced">
                  <input 
                    type="text" 
                    id="usernameInput" 
                    class="form-input-advanced" 
                    value="${name}"
                    maxlength="30"
                    placeholder="Enter your username"
                    oninput="handleUsernameInput(this.value)"
                    onfocus="this.parentElement.classList.add('focused')"
                    onblur="this.parentElement.classList.remove('focused')"
                  >
                  <div class="input-validation" id="usernameValidation">
                    <div class="validation-icon" id="validationIcon"></div>
                  </div>
                </div>
                <div class="validation-message" id="validationMessage"></div>
                <div class="input-meta">
                  <span class="char-counter" id="charCounter">${name.length}/30</span>
                </div>
              </div>
              
              <div class="edit-actions">
                <button class="btn btn-secondary" onclick="cancelUsernameEdit()">
                  Cancel
                </button>
                <button class="btn btn-primary" id="saveUsernameBtn" onclick="saveUsernameChanges()" disabled>
                  <span class="btn-text">Save Changes</span>
                  <svg class="btn-spinner" style="display: none;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10" opacity="0.25"></circle>
                    <path d="M12 2a10 10 0 0 1 10 10" opacity="0.75"></path>
                  </svg>
                </button>
              </div>
            </div>
          </div>
          <button class="btn btn-destructive-outline" onclick="window.LayerDB.signOut()">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
              <polyline points="16 17 21 12 16 7"></polyline>
              <line x1="21" y1="12" x2="9" y2="12"></line>
            </svg>
            Sign Out
          </button>
        </div>
      </div>

      <!-- Appearance Section -->
      <div class="settings-section card">
        <h3 class="section-title">Appearance</h3>
        <div class="settings-item">
          <div class="settings-label">
            <span>Theme</span>
          </div>
          <select id="themeSelect" class="form-select">
            ${themes.map(theme => `
              <option value="${theme.value}" ${currentTheme === theme.value ? 'selected' : ''}>
                ${theme.label}
              </option>
            `).join('')}
          </select>
        </div>
        <div class="settings-item" id="themeModeToggleContainer" style="${currentTheme === 'dark' || currentTheme === 'light' || currentTheme === 'darklime' ? 'display: none;' : ''}">
          <div class="settings-label">
            <span>Theme Mode</span>
            <p class="settings-description">Toggle between light and dark variants of your theme</p>
          </div>
          <div style="display: flex; align-items: center; gap: 12px;">
            <span style="font-size: 13px; color: var(--muted-foreground);">Dark</span>
            <label class="toggle-switch">
              <input type="checkbox" id="themeModeToggle" ${localStorage.getItem('layerThemeMode') === 'light' ? 'checked' : ''} onchange="toggleThemeModeFromSettings(this.checked)">
              <span class="toggle-slider"></span>
            </label>
            <span style="font-size: 13px; color: var(--muted-foreground);">Light</span>
          </div>
        </div>
      </div>

      <!-- Notifications Section -->
      <div class="settings-section card">
        <h3 class="section-title">Notifications</h3>
        
        <div class="settings-item">
          <div class="settings-label">
            <span>Deadline Reminders</span>
            <p class="settings-description">Get notified when project deadlines are approaching</p>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="notifyDeadlines" ${notifyDeadlines ? 'checked' : ''} onchange="updateNotificationSetting('layerNotifyDeadlines', this.checked)">
            <span class="toggle-slider"></span>
          </label>
        </div>

        <div class="settings-item">
          <div class="settings-label">
            <span>Task Reminders</span>
            <p class="settings-description">Receive reminders for upcoming tasks</p>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="notifyReminders" ${notifyReminders ? 'checked' : ''} onchange="updateNotificationSetting('layerNotifyReminders', this.checked)">
            <span class="toggle-slider"></span>
          </label>
        </div>

        <div class="settings-item">
          <div class="settings-label">
            <span>Sound Effects</span>
            <p class="settings-description">Play sounds for notifications and actions</p>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="notifySounds" ${notifySounds ? 'checked' : ''} onchange="updateNotificationSetting('layerNotifySounds', this.checked)">
            <span class="toggle-slider"></span>
          </label>
        </div>

        <div class="settings-item">
          <div class="settings-label">
            <span>Email Notifications</span>
            <p class="settings-description">Receive important updates via email</p>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="notifyEmail" ${notifyEmail ? 'checked' : ''} onchange="updateNotificationSetting('layerNotifyEmail', this.checked)">
            <span class="toggle-slider"></span>
          </label>
        </div>
      </div>

      <!-- Data Management Section -->
      <div class="settings-section card">
        <h3 class="section-title">Data Management</h3>
        
        <div class="settings-item">
          <div class="settings-label">
            <span>Export Data</span>
            <p class="settings-description">Download a full backup of your projects, tasks, issues, and settings</p>
          </div>
          <button class="btn btn-secondary" onclick="exportData()">
            Export All Data (JSON)
          </button>
        </div>

        <div class="settings-item">
          <div class="settings-label">
            <span>Import Data</span>
            <p class="settings-description">Restore from a previously exported Layer backup file</p>
          </div>
          <button class="btn btn-secondary" onclick="document.getElementById('importFileInput').click()">
            Choose File to Import
          </button>
          <input type="file" id="importFileInput" accept=".json,application/json" style="display:none" onchange="handleImportFile(event)">
        </div>

        <div class="settings-item danger-zone">
          <div class="settings-label">
            <span>Reset All Data</span>
            <p class="settings-description">Permanently delete everything — use with caution</p>
          </div>
          <button class="btn btn-destructive" onclick="resetAllData()">
            Reset Everything
          </button>
        </div>
      </div>

      <!-- About & Info Section -->
      <div class="settings-section card">
        <h3 class="section-title">About & Info</h3>
        <div class="settings-item">
          <div class="settings-label">
            <span>Created by</span>
            <p class="settings-description">Lead developer and designer</p>
          </div>
          <div class="settings-value creator-badge">
            <span class="creator-avatar">ZM</span>
            <span class="creator-name">Zeyad Maher Mohamed</span>
          </div>
        </div>
        <div class="settings-item">
          <div class="settings-label">
            <span>Version</span>
            <p class="settings-description">Current app version</p>
          </div>
          <span class="settings-value">${appVersion}</span>
        </div>
        <div class="settings-item">
          <div class="settings-label">
            <span>Last Sync</span>
            <p class="settings-description">When your data was last updated</p>
          </div>
          <span class="settings-value">${lastSync}</span>
        </div>
        <div class="settings-item">
          <div class="settings-label">
            <span>Feedback</span>
            <p class="settings-description">Help us improve Layer</p>
          </div>
          <a href="mailto:feedback@layer.app" class="btn btn-ghost">Send Feedback</a>
        </div>
      </div>

      <div class="settings-section card">
        <h3 class="section-title">Danger Zone</h3>
        <div class="settings-item danger-zone">
          <div class="settings-label">
            <span>Delete Account</span>
            <p class="settings-description">Permanently delete your account and all associated data. This cannot be undone.</p>
          </div>
          <button class="btn btn-destructive" onclick="requestAccountDeletion()">
            Delete Account
          </button>
        </div>
      </div>
    </div>
  `;
}

// Notification Settings Handler
function updateNotificationSetting(key, value) {
  localStorage.setItem(key, value);
}

// ========================
// Export Data - Exports EVERYTHING
// ========================
function exportData() {
  const data = {
    // Core data
    projects: localStorage.getItem('layerProjectsData'),
    backlog: localStorage.getItem('layerBacklogTasks'),
    issues: localStorage.getItem('layerMyIssues'),
    calendar: localStorage.getItem('layerCalendarEvents'),
    expanded: localStorage.getItem('layerCalendarExpandedTask'),
    theme: localStorage.getItem('layerTheme'),
    themeMode: localStorage.getItem('layerThemeMode'),

    // Documents and Spreadsheets
    docs: localStorage.getItem('layerDocs'),
    excels: localStorage.getItem('layerExcels'),

    // Spaces
    spaces: localStorage.getItem('layerSpaces'),

    // Assignments
    assignments: localStorage.getItem('layerAssignments'),

    // Favorites
    favoriteDocs: localStorage.getItem('layerFavoriteDocs'),
    favoriteExcels: localStorage.getItem('layerFavoriteExcels'),

    // User data
    users: localStorage.getItem('layerUsers'),
    currentUser: localStorage.getItem('layerCurrentUser'),

    // UI state
    sidebarCollapsed: localStorage.getItem('layerSidebarCollapsed'),
    hideBetaNotification: localStorage.getItem('hideBetaNotification'),
    focusTimerPosition: localStorage.getItem('layerFocusTimerPosition'),
    focusModeState: localStorage.getItem('layerFocusModeState'),

    // Export timestamp
    exportedAt: new Date().toISOString()
  };

  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `layer-backup-${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

// ========================
// Import Data
// ========================
function handleImportFile(event) {
  const file = event.target.files[0];
  if (!file) return;

  if (!file.name.endsWith('.json')) {
    alert('Please select a valid JSON file.');
    return;
  }

  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      const imported = JSON.parse(e.target.result);

      const confirmHTML = `
        <div style="padding: 24px; text-align: center;">
          <h3 style="margin: 0 0 16px; font-size: 18px; font-weight: 600; color: var(--foreground);">Import Data?</h3>
          <p style="margin: 0 0 24px; color: var(--muted-foreground); font-size: 14px; line-height: 1.5;">
            This will <strong>replace all current data</strong> with the contents of the backup file.<br><br>
            File: <strong>${file.name}</strong><br>
            Are you sure you want to continue?
          </p>
          <div style="display: flex; gap: 12px; justify-content: center;">
            <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            <button class="btn btn-primary" onclick="performImport()">Yes, Import Data</button>
          </div>
        </div>
      `;

      window.pendingImportData = imported;
      openModal('Confirm Import', confirmHTML);
    } catch (err) {
      alert('Invalid backup file: Could not parse JSON.');
      console.error(err);
    }
  };

  reader.readAsText(file);
}

function performImport() {
  const data = window.pendingImportData;
  if (!data) return;

  // Core data
  if (data.projects) localStorage.setItem('layerProjectsData', data.projects);
  if (data.backlog) localStorage.setItem('layerBacklogTasks', data.backlog);
  if (data.issues) localStorage.setItem('layerMyIssues', data.issues);
  if (data.calendar) localStorage.setItem('layerCalendarEvents', data.calendar);
  if (data.expanded) localStorage.setItem('layerCalendarExpandedTask', data.expanded);
  if (data.theme) {
    localStorage.setItem('layerTheme', data.theme);
    applyTheme(data.theme);
  }
  if (data.themeMode) localStorage.setItem('layerThemeMode', data.themeMode);

  // Documents and Spreadsheets
  if (data.docs) localStorage.setItem('layerDocs', data.docs);
  if (data.excels) localStorage.setItem('layerExcels', data.excels);

  // Spaces
  if (data.spaces) localStorage.setItem('layerSpaces', data.spaces);

  // Assignments
  if (data.assignments) localStorage.setItem('layerAssignments', data.assignments);

  // Favorites
  if (data.favoriteDocs) localStorage.setItem('layerFavoriteDocs', data.favoriteDocs);
  if (data.favoriteExcels) localStorage.setItem('layerFavoriteExcels', data.favoriteExcels);

  // User data
  if (data.users) localStorage.setItem('layerUsers', data.users);
  if (data.currentUser) localStorage.setItem('layerCurrentUser', data.currentUser);

  // UI state
  if (data.sidebarCollapsed) localStorage.setItem('layerSidebarCollapsed', data.sidebarCollapsed);
  if (data.hideBetaNotification) localStorage.setItem('hideBetaNotification', data.hideBetaNotification);
  if (data.focusTimerPosition) localStorage.setItem('layerFocusTimerPosition', data.focusTimerPosition);
  if (data.focusModeState) localStorage.setItem('layerFocusModeState', data.focusModeState);

  delete window.pendingImportData;
  closeModal();
  alert('Data imported successfully! The app will now reload.');
  location.reload();
}

// ========================
// Reset All Data
// ========================
function resetAllData() {
  const confirmHTML = `
    <div style="padding: 24px; text-align: center;">
      <h3 style="margin: 0 0 16px; font-size: 18px; font-weight: 600; color: var(--foreground);">Are you sure?</h3>
      <p style="margin: 0 0 32px; color: var(--muted-foreground); font-size: 14px; line-height: 1.5;">
        This will <strong>permanently delete ALL</strong> your data:<br>
        projects, tasks, issues, calendar events, and settings.<br><br>
        <strong>This action cannot be undone.</strong>
      </p>
      <div style="display: flex; gap: 12px; justify-content: center;">
        <button class="btn btn-secondary" onclick="closeModal()">No, Cancel</button>
        <button class="btn btn-destructive" onclick="confirmResetAllData()">Yes, Delete Everything</button>
      </div>
    </div>
  `;

  openModal('Reset All Data', confirmHTML);
}

function confirmResetAllData() {
  localStorage.clear();
  closeModal();
  location.reload();
}

async function requestAccountDeletion() {
  const user = window.LayerDB?.getCurrentUser?.();
  if (!user) {
    showNotification('You must be signed in to delete your account.', 'error');
    return;
  }

  const confirmHTML = `
    <div style="padding: 24px;">
      <h3 style="margin: 0 0 12px; font-size: 18px; font-weight: 700; color: var(--foreground); text-align: center;">Delete your account?</h3>
      <p style="margin: 0 0 18px; color: var(--muted-foreground); font-size: 14px; line-height: 1.5; text-align: center;">
        This will permanently delete your account and all data associated with it (projects, issues, docs, spaces, drafts, preferences, etc.).
        <br><br>
        Type <strong>DELETE</strong> to confirm.
      </p>

      <div style="display: flex; justify-content: center; margin-bottom: 18px;">
        <input
          id="deleteAccountConfirmInput"
          class="form-input"
          style="width: 100%; max-width: 320px;"
          placeholder="Type DELETE"
          oninput="handleDeleteAccountConfirmInput(this.value)"
          autocomplete="off"
          spellcheck="false"
        />
      </div>

      <div style="display: flex; gap: 12px; justify-content: center;">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-destructive" id="confirmDeleteAccountBtn" onclick="confirmDeleteAccount()" disabled>
          Yes, Delete Account
        </button>
      </div>
    </div>
  `;

  openModal('Delete Account', confirmHTML);
}

function handleDeleteAccountConfirmInput(value) {
  const btn = document.getElementById('confirmDeleteAccountBtn');
  if (!btn) return;
  btn.disabled = String(value || '').trim().toUpperCase() !== 'DELETE';
}

async function confirmDeleteAccount() {
  const btn = document.getElementById('confirmDeleteAccountBtn');
  if (btn) btn.disabled = true;

  try {
    if (!window.LayerDB?.supabase) {
      throw new Error('Supabase client not available');
    }

    const { data: { session }, error: sessionError } = await window.LayerDB.supabase.auth.getSession();
    if (sessionError || !session) {
      throw new Error('No active session found');
    }

    const token = session.access_token;

    const { data, error } = await window.LayerDB.supabase.functions.invoke('delete-account', {
      body: { confirm: 'DELETE' },
      headers: { 'Authorization': 'Bearer ' + token }
    });

    if (error) {
      throw error;
    }

    closeModal();
    showNotification('Account deleted successfully.', 'success');

    try {
      await window.LayerDB.signOut();
    } catch (e) {
      // ignore
    }

    localStorage.clear();
    location.reload();
  } catch (error) {
    console.error('Account deletion failed:', error);
    showNotification('Failed to delete account. Please try again.', 'error');
    if (btn) btn.disabled = false;
  }
}

// ========================
// Theme Application with Mode Support
// ========================
function applyTheme(theme) {
  document.body.classList.remove('light');
  document.documentElement.removeAttribute('data-theme');
  document.documentElement.removeAttribute('data-mode');

  if (theme === 'light') {
    document.body.classList.add('light');
  } else if (theme === 'dark') {
    // Default dark, no special attributes needed
  } else {
    // Custom theme - apply with current mode
    const currentMode = localStorage.getItem('layerThemeMode') || 'dark';
    document.documentElement.setAttribute('data-theme', theme);
    document.documentElement.setAttribute('data-mode', currentMode);
  }

  localStorage.setItem('layerTheme', theme);
}

function toggleThemeModeFromSettings(isLight) {
  const newMode = isLight ? 'light' : 'dark';
  localStorage.setItem('layerThemeMode', newMode);
  document.documentElement.setAttribute('data-mode', newMode);
}

function initThemeSelector() {
  const themeSelect = document.getElementById('themeSelect');
  const modeContainer = document.getElementById('themeModeToggleContainer');

  if (!themeSelect) return;

  const current = localStorage.getItem('layerTheme') || 'dark';
  themeSelect.value = current;

  themeSelect.addEventListener('change', (e) => {
    const newTheme = e.target.value;
    applyTheme(newTheme);

    // Show/hide mode toggle based on theme
    if (modeContainer) {
      if (newTheme === 'dark' || newTheme === 'light' || newTheme === 'darklime') {
        modeContainer.style.display = 'none';
      } else {
        modeContainer.style.display = '';
        // Reset mode to dark when switching themes
        localStorage.setItem('layerThemeMode', 'dark');
        document.documentElement.setAttribute('data-mode', 'dark');
        const modeToggle = document.getElementById('themeModeToggle');
        if (modeToggle) modeToggle.checked = false;
      }
    }
  });
}

// Apply saved theme on load
document.addEventListener('DOMContentLoaded', async () => {
  const saved = localStorage.getItem('layerTheme') || 'dark';
  applyTheme(saved);
  initThemeSelector();

  // Check if focus mode was active
  const focusState = loadFocusModeState();
  if (focusState && focusState.active) {
    restoreFocusMode(focusState);
  }
  
  // Render folders
  await renderFoldersInPlaceholder();
});


/* ============================================
   Layer - Focus Mode Feature
   ============================================ */

const FOCUS_MODE_KEY = 'layerFocusModeState';
let focusTimerInterval = null;
let focusStartTime = null;
let focusPausedTime = 0;
let focusPaused = false;
let focusProjectIndex = null;
let focusTasks = [];

function loadFocusModeState() {
  try {
    return JSON.parse(localStorage.getItem(FOCUS_MODE_KEY));
  } catch {
    return null;
  }
}

function saveFocusModeState(state) {
  localStorage.setItem(FOCUS_MODE_KEY, JSON.stringify(state));
}

function clearFocusModeState() {
  localStorage.removeItem(FOCUS_MODE_KEY);
}

function toggleFocusModeExpand() {
  const expandable = document.getElementById('focusModeExpandable');
  const projectSelect = document.getElementById('focusProjectSelect');
  
  if (!expandable.classList.contains('expanded')) {
    // Populate projects when expanding
    const projects = loadProjects();
    if (projects.length === 0) {
      projectSelect.innerHTML = '<option value="">No projects available</option>';
    } else {
      projectSelect.innerHTML = projects.map((p, i) => `<option value="${i}">${p.name}</option>`).join('');
    }
    
    expandable.classList.add('expanded');
  } else {
    expandable.classList.remove('expanded');
  }
}

function openFocusModeModal() {
  // Legacy function - redirect to expandable version
  toggleFocusModeExpand();
}

function selectFocusDuration(btn) {
  document.querySelectorAll('.focus-duration-btn').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
}

function startFocusMode() {
  const select = document.getElementById('focusProjectSelect');
  const durationSelect = document.getElementById('focusDurationSelect');
  const projectIndex = parseInt(select.value);
  const projects = loadProjects();
  const project = projects[projectIndex];

  if (!project) return;

  const duration = durationSelect ? parseInt(durationSelect.value) : 0;

  // Get tasks from the project's To Do and In Progress columns
  focusTasks = [];
  project.columns.forEach((col, colIndex) => {
    if (colIndex < 2) { // To Do and In Progress
      col.tasks.forEach((task, taskIndex) => {
        if (!task.done) {
          focusTasks.push({
            title: task.title,
            done: false,
            colIndex,
            taskIndex,
            id: task.id
          });
        }
      });
    }
  });

  focusProjectIndex = projectIndex;
  focusStartTime = Date.now();
  focusPausedTime = 0;
  focusPaused = false;

  // Save state
  saveFocusModeState({
    active: true,
    projectIndex,
    projectName: project.name,
    startTime: focusStartTime,
    pausedTime: 0,
    paused: false,
    duration: duration,
    tasks: focusTasks
  });

  // Close expandable panel instead of modal
  const expandable = document.getElementById('focusModeExpandable');
  if (expandable) {
    expandable.classList.remove('expanded');
  }
  
  showFocusTimer(project.name);
}

function restoreFocusMode(state) {
  focusProjectIndex = state.projectIndex;
  focusStartTime = state.startTime;
  focusPausedTime = state.pausedTime || 0;
  focusPaused = state.paused || false;
  focusTasks = state.tasks || [];

  showFocusTimer(state.projectName);

  if (focusPaused) {
    updatePauseButton(true);
  }
}

function showFocusTimer(projectName) {
  const floatEl = document.getElementById('focusTimerFloat');
  const projectNameEl = document.getElementById('timerProjectName');

  if (floatEl) {
    floatEl.style.display = 'flex';
    projectNameEl.textContent = projectName;
    renderFocusTasks();

    // Initialize drag functionality
    initFocusTimerDrag();

    // Restore saved position or use default
    restoreTimerPosition();

    if (!focusPaused) {
      startTimerInterval();
    } else {
      updateTimerDisplay();
    }
  }
}

// ============================================
// Focus Timer Drag & Snap to Corner
// ============================================
let timerDragState = {
  isDragging: false,
  startX: 0,
  startY: 0,
  initialLeft: 0,
  initialTop: 0
};

const TIMER_POSITION_KEY = 'layerFocusTimerPosition';
const SNAP_MARGIN = 24; // Distance from edges

function initFocusTimerDrag() {
  const floatEl = document.getElementById('focusTimerFloat');
  const widget = document.getElementById('focusTimerWidget');

  if (!floatEl || !widget) return;

  // Mouse events
  widget.addEventListener('mousedown', handleTimerDragStart);
  document.addEventListener('mousemove', handleTimerDrag);
  document.addEventListener('mouseup', handleTimerDragEnd);

  // Touch events for mobile
  widget.addEventListener('touchstart', handleTimerDragStart, { passive: false });
  document.addEventListener('touchmove', handleTimerDrag, { passive: false });
  document.addEventListener('touchend', handleTimerDragEnd);
}

function handleTimerDragStart(e) {
  const floatEl = document.getElementById('focusTimerFloat');
  if (!floatEl) return;

  // Prevent default to stop text selection
  e.preventDefault();

  const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
  const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

  // Get current position
  const rect = floatEl.getBoundingClientRect();

  timerDragState.isDragging = true;
  timerDragState.startX = clientX;
  timerDragState.startY = clientY;
  timerDragState.initialLeft = rect.left;
  timerDragState.initialTop = rect.top;

  // Remove snapping class and add dragging class
  floatEl.classList.remove('snapping');
  floatEl.classList.add('dragging');

  // Clear positional styles and use left/top for dragging
  floatEl.style.right = 'auto';
  floatEl.style.bottom = 'auto';
  floatEl.style.left = rect.left + 'px';
  floatEl.style.top = rect.top + 'px';
}

function handleTimerDrag(e) {
  if (!timerDragState.isDragging) return;

  e.preventDefault();

  const floatEl = document.getElementById('focusTimerFloat');
  if (!floatEl) return;

  const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
  const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;

  const deltaX = clientX - timerDragState.startX;
  const deltaY = clientY - timerDragState.startY;

  let newLeft = timerDragState.initialLeft + deltaX;
  let newTop = timerDragState.initialTop + deltaY;

  // Keep widget within bounds
  const rect = floatEl.getBoundingClientRect();
  const maxX = window.innerWidth - rect.width;
  const maxY = window.innerHeight - rect.height;

  newLeft = Math.max(0, Math.min(newLeft, maxX));
  newTop = Math.max(0, Math.min(newTop, maxY));

  floatEl.style.left = newLeft + 'px';
  floatEl.style.top = newTop + 'px';
}

function handleTimerDragEnd(e) {
  if (!timerDragState.isDragging) return;

  timerDragState.isDragging = false;

  const floatEl = document.getElementById('focusTimerFloat');
  if (!floatEl) return;

  floatEl.classList.remove('dragging');

  // Calculate which corner to snap to
  const rect = floatEl.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  const windowCenterX = window.innerWidth / 2;
  const windowCenterY = window.innerHeight / 2;

  // Determine the closest corner
  const isLeft = centerX < windowCenterX;
  const isTop = centerY < windowCenterY;

  // Add snapping class for smooth animation
  floatEl.classList.add('snapping');

  // Clear current positioning
  floatEl.style.left = 'auto';
  floatEl.style.right = 'auto';
  floatEl.style.top = 'auto';
  floatEl.style.bottom = 'auto';

  // Set the corner position
  let corner = '';
  if (isTop && isLeft) {
    floatEl.style.left = SNAP_MARGIN + 'px';
    floatEl.style.top = SNAP_MARGIN + 'px';
    corner = 'top-left';
  } else if (isTop && !isLeft) {
    floatEl.style.right = SNAP_MARGIN + 'px';
    floatEl.style.top = SNAP_MARGIN + 'px';
    corner = 'top-right';
  } else if (!isTop && isLeft) {
    floatEl.style.left = SNAP_MARGIN + 'px';
    floatEl.style.bottom = SNAP_MARGIN + 'px';
    corner = 'bottom-left';
  } else {
    floatEl.style.right = SNAP_MARGIN + 'px';
    floatEl.style.bottom = SNAP_MARGIN + 'px';
    corner = 'bottom-right';
  }

  // Save the position
  saveTimerPosition(corner);

  // Remove snapping class after animation completes
  setTimeout(() => {
    floatEl.classList.remove('snapping');
  }, 450);
}

function saveTimerPosition(corner) {
  localStorage.setItem(TIMER_POSITION_KEY, corner);
}

function restoreTimerPosition() {
  const floatEl = document.getElementById('focusTimerFloat');
  if (!floatEl) return;

  const savedCorner = localStorage.getItem(TIMER_POSITION_KEY) || 'bottom-left';

  // Clear all positioning first
  floatEl.style.left = 'auto';
  floatEl.style.right = 'auto';
  floatEl.style.top = 'auto';
  floatEl.style.bottom = 'auto';

  // Apply saved corner position
  switch (savedCorner) {
    case 'top-left':
      floatEl.style.left = SNAP_MARGIN + 'px';
      floatEl.style.top = SNAP_MARGIN + 'px';
      break;
    case 'top-right':
      floatEl.style.right = SNAP_MARGIN + 'px';
      floatEl.style.top = SNAP_MARGIN + 'px';
      break;
    case 'bottom-right':
      floatEl.style.right = SNAP_MARGIN + 'px';
      floatEl.style.bottom = SNAP_MARGIN + 'px';
      break;
    case 'bottom-left':
    default:
      floatEl.style.left = SNAP_MARGIN + 'px';
      floatEl.style.bottom = SNAP_MARGIN + 'px';
      break;
  }
}

function startTimerInterval() {
  if (focusTimerInterval) {
    clearInterval(focusTimerInterval);
  }

  focusTimerInterval = setInterval(() => {
    if (!focusPaused) {
      updateTimerDisplay();
    }
  }, 1000);

  updateTimerDisplay();
}

function updateTimerDisplay() {
  const displayEl = document.getElementById('timerDisplay');
  if (!displayEl) return;

  let elapsed;
  if (focusPaused) {
    elapsed = focusPausedTime;
  } else {
    elapsed = Math.floor((Date.now() - focusStartTime) / 1000) + focusPausedTime;
  }

  const hours = Math.floor(elapsed / 3600);
  const minutes = Math.floor((elapsed % 3600) / 60);
  const seconds = elapsed % 60;

  if (hours > 0) {
    displayEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  } else {
    displayEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }
}

function toggleTimerExpand() {
  // Prevent expand toggle during drag
  if (timerDragState.isDragging) return;

  const widget = document.getElementById('focusTimerWidget');
  const isExpanded = widget.classList.contains('expanded');

  if (isExpanded) {
    widget.classList.remove('expanded', 'tasks-visible');
  } else {
    widget.classList.add('expanded');
    // Show tasks after a short delay
    setTimeout(() => {
      widget.classList.add('tasks-visible');
    }, 150);
  }
}

function toggleTimerPause() {
  focusPaused = !focusPaused;

  if (focusPaused) {
    // Save elapsed time when pausing
    focusPausedTime = Math.floor((Date.now() - focusStartTime) / 1000) + focusPausedTime;
    clearInterval(focusTimerInterval);
    focusTimerInterval = null;
  } else {
    // Resume from paused time
    focusStartTime = Date.now();
    startTimerInterval();
  }

  updatePauseButton(focusPaused);

  // Update saved state
  const state = loadFocusModeState();
  if (state) {
    state.paused = focusPaused;
    state.pausedTime = focusPausedTime;
    if (!focusPaused) {
      state.startTime = focusStartTime;
    }
    saveFocusModeState(state);
  }
}

function updatePauseButton(isPaused) {
  const btn = document.getElementById('timerPauseBtn');
  const text = document.getElementById('pauseBtnText');
  const icon1 = document.getElementById('pauseIcon1');
  const icon2 = document.getElementById('pauseIcon2');

  if (isPaused) {
    text.textContent = 'Resume';
    // Change to play icon
    if (icon1 && icon2) {
      icon1.setAttribute('d', 'M5 3l14 9-14 9V3z');
      icon1.removeAttribute('x');
      icon1.removeAttribute('y');
      icon1.removeAttribute('width');
      icon1.removeAttribute('height');
      icon2.style.display = 'none';
    }
  } else {
    text.textContent = 'Pause';
    if (icon2) icon2.style.display = '';
  }
}

function stopFocusMode() {
  if (focusTimerInterval) {
    clearInterval(focusTimerInterval);
    focusTimerInterval = null;
  }

  const floatEl = document.getElementById('focusTimerFloat');
  if (floatEl) {
    floatEl.style.display = 'none';
  }

  // Reset state
  focusStartTime = null;
  focusPausedTime = 0;
  focusPaused = false;
  focusProjectIndex = null;
  focusTasks = [];

  clearFocusModeState();

  // Reset widget state
  const widget = document.getElementById('focusTimerWidget');
  if (widget) {
    widget.classList.remove('expanded', 'tasks-visible');
  }
}

function renderFocusTasks() {
  const listEl = document.getElementById('timerTasksList');
  const progressEl = document.getElementById('tasksProgress');

  if (!listEl) return;

  const completedCount = focusTasks.filter(t => t.done).length;
  progressEl.textContent = `${completedCount}/${focusTasks.length}`;

  if (focusTasks.length === 0) {
    listEl.innerHTML = `
      <div style="text-align: center; padding: 16px; color: var(--muted-foreground); font-size: 13px;">
        No tasks in this project
      </div>
    `;
    return;
  }

  listEl.innerHTML = focusTasks.map((task, i) => `
    <div class="timer-task-item ${task.done ? 'done' : ''}" onclick="toggleFocusTask(${i})">
      <div class="timer-task-checkbox"></div>
      <span>${task.title}</span>
    </div>
  `).join('');
}

function toggleFocusTask(index) {
  if (!focusTasks[index]) return;

  focusTasks[index].done = !focusTasks[index].done;

  // Update the actual project task
  const task = focusTasks[index];
  if (focusProjectIndex !== null) {
    toggleTaskDone(focusProjectIndex, task.colIndex, task.taskIndex);
  }

  // Update saved state
  const state = loadFocusModeState();
  if (state) {
    state.tasks = focusTasks;
    saveFocusModeState(state);
  }

  renderFocusTasks();
}

// ============================================
// Project Export/Import Functions
// ============================================

function exportAllProjects() {
  const projects = loadProjects();
  if (projects.length === 0) {
    alert('No projects to export!');
    return;
  }

  const exportData = {
    version: '1.0',
    exportDate: new Date().toISOString(),
    projects: projects
  };

  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `layer-projects-${new Date().toISOString().split('T')[0]}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  // Show success toast
  showToast('Projects exported successfully!');
}

function importProjects() {
  const input = document.getElementById('projectImportInput');
  if (input) {
    input.click();
  }
}

function handleProjectImport(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function (e) {
    try {
      const importData = JSON.parse(e.target.result);

      // Validate import data
      if (!importData.projects || !Array.isArray(importData.projects)) {
        alert('Invalid file format. Please select a valid Layer projects export file.');
        return;
      }

      // Ask user how to handle import
      const existingProjects = loadProjects();
      const importCount = importData.projects.length;

      if (existingProjects.length > 0) {
        const choice = confirm(
          `Found ${importCount} project(s) to import.\n\n` +
          `You currently have ${existingProjects.length} project(s).\n\n` +
          `Click OK to MERGE (add to existing)\n` +
          `Click Cancel to REPLACE all existing projects`
        );

        if (choice) {
          // Merge - add imported projects with new IDs to avoid conflicts
          const mergedProjects = [...existingProjects];
          importData.projects.forEach(project => {
            // Generate new ID to avoid conflicts
            project.id = generateId('PROJ');
            mergedProjects.push(project);
          });
          saveProjects(mergedProjects);
        } else {
          // Replace all
          saveProjects(importData.projects);
        }
      } else {
        // No existing projects, just import
        saveProjects(importData.projects);
      }

      // Reset the input
      event.target.value = '';

      // Refresh view
      renderCurrentView();

      showToast(`${importCount} project(s) imported successfully!`);

    } catch (error) {
      console.error('Import error:', error);
      alert('Failed to import projects. Please check the file format.');
    }
  };
  reader.readAsText(file);
}

function showToast(message) {
  const toast = document.createElement('div');
  toast.textContent = message;
  toast.style.cssText = `
    position: fixed;
    bottom: 24px;
    right: 24px;
    padding: 14px 24px;
    background: var(--card);
    color: var(--foreground);
    border: 1px solid var(--border);
    border-radius: 10px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    z-index: 9999;
    font-size: 14px;
    font-weight: 500;
    animation: toastSlideIn 0.3s ease;
  `;
  document.body.appendChild(toast);
  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(10px)';
    toast.style.transition = 'all 0.3s ease';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}
/* ============================================
   Layer - Create Features (Doc, Excel, Space)
   ============================================ */

// Storage keys
const DOCS_KEY = 'layerDocs';
const EXCELS_KEY = 'layerExcels';
const SPACES_KEY = 'layerSpaces';
const DRAFTS_KEY = 'layerDrafts';

// State
let currentDocId = null;
let currentExcelId = null;
let currentSpaceId = null; // Track which space we're in for saving docs/excels
let isSavingDoc = false; // Prevent concurrent saves

// ============================================
// Create Dropdown (legacy - moved to sidebar)
// ============================================

// Function to create a whiteboard draft
async function createWhiteboardDraft() {
  // Require authentication
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create whiteboards', 'error');
    return null;
  }

  try {
    // Create a draft project for the whiteboard
    const draftProject = {
      name: 'Untitled Whiteboard',
      description: 'Whiteboard draft',
      status: 'todo',
      startDate: new Date().toISOString().split('T')[0],
      targetDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 30 days from now
      grip_diagram: { nodes: [], edges: [], offsetX: 0, offsetY: 0, scale: 1 }, // Empty whiteboard
      isDraft: true, // Mark as draft
      isWhiteboard: true // Specific marker for whiteboard
    };

    // Create the project
    const newProject = await addProject(draftProject);
    
    if (newProject) {
      // Create a draft entry for the whiteboard
      if (window.LayerDB && window.LayerDB.isAuthenticated()) {
        try {
          const draftEntry = {
            title: newProject.name,
            content: '', // Whiteboards don't have content in the traditional sense
            type: 'whiteboard',
            metadata: { projectId: newProject.id },
            createdAt: newProject.createdAt || new Date().toISOString(),
            updatedAt: newProject.updatedAt || newProject.createdAt || new Date().toISOString()
          };
          
          const savedDraft = await window.LayerDB.saveDraft(draftEntry);
          console.log('✅ Whiteboard draft saved to DB:', savedDraft.id);
          
          // Update cache
          if (window.cachedDrafts) {
            window.cachedDrafts.unshift(savedDraft);
          }
        } catch (error) {
          console.error('❌ Failed to save whiteboard draft to DB:', error);
        }
      } else {
        // Fallback to localStorage for unauthenticated users
        const drafts = loadDrafts();
        const draftEntry = {
          id: newProject.id,
          title: newProject.name,
          type: 'whiteboard',
          createdAt: newProject.createdAt || new Date().toISOString(),
          updatedAt: newProject.updatedAt || newProject.createdAt || new Date().toISOString()
        };
        drafts.push(draftEntry);
        saveDrafts(drafts);
      }
      
      // Mark drafts view for refresh
      window.draftsNeedRefresh = true;
      
      showToast('Whiteboard created and saved as draft', 'success');
      
      // Return the project index for the newly created project
      const projects = loadProjects();
      const projectIndex = projects.findIndex(p => p.id === newProject.id);
      return projectIndex;
    }
    
    return null;
  } catch (error) {
    console.error('Failed to create whiteboard draft:', error);
    showToast('Failed to create whiteboard draft', 'error');
    return null;
  }
}

// Function to open a whiteboard draft
function openGripDiagramForDraft(draftId) {
  const projects = loadProjects();
  const projectIndex = projects.findIndex(p => p.id === draftId);
  
  if (projectIndex !== -1) {
    openGripDiagram(projectIndex);
  } else {
    console.error('Draft project not found:', draftId);
    showToast('Draft project not found', 'error');
  }
}

// Function to delete a draft
async function deleteDraft(draftId, draftType) {
  try {
    // Delete from database based on type
    if (draftType === 'whiteboard') {
      // For whiteboards, delete the associated project
      const projects = loadProjects();
      const projectIndex = projects.findIndex(p => p.id === draftId);
      if (projectIndex !== -1) {
        await deleteProject(projectIndex);
      }
    } else if (draftType === 'doc') {
      // For documents, delete from docs table
      if (window.LayerDB && window.LayerDB.isAuthenticated()) {
        await window.LayerDB.deleteDoc(draftId);
      }
    } else if (draftType === 'sheet') {
      // For spreadsheets, delete from excels table
      if (window.LayerDB && window.LayerDB.isAuthenticated()) {
        await window.LayerDB.deleteExcel(draftId);
      }
    }

    // Remove from drafts database
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      await window.LayerDB.deleteDraft(draftId);
      // Update cache
      if (window.cachedDrafts) {
        window.cachedDrafts = window.cachedDrafts.filter(d => d.id !== draftId);
      }
    } else {
      // Fallback to localStorage for unauthenticated users
      const drafts = loadDrafts();
      const updatedDrafts = drafts.filter(d => d.id !== draftId);
      saveDrafts(updatedDrafts);
    }

    // Mark drafts view for refresh
    window.draftsNeedRefresh = true;

    showToast('Draft deleted successfully', 'success');
  } catch (error) {
    console.error('Failed to delete draft:', error);
    showToast('Failed to delete draft', 'error');
  }
}

// Function to clear all drafts
async function clearAllDrafts() {
  if (!confirm('Are you sure you want to delete ALL drafts? This action cannot be undone.')) {
    return;
  }
  
  try {
    const drafts = loadDrafts();
    
    // Delete all whiteboard projects
    const whiteboardDrafts = drafts.filter(d => d.type === 'whiteboard');
    for (const draft of whiteboardDrafts) {
      const projects = loadProjects();
      const projectIndex = projects.findIndex(p => p.id === draft.id);
      if (projectIndex !== -1) {
        await deleteProject(projectIndex);
      }
    }
    
    // Clear all drafts from storage
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      const drafts = await window.LayerDB.loadDrafts();
      for (const draft of drafts) {
        await window.LayerDB.deleteDraft(draft.id);
      }
      window.cachedDrafts = [];
    } else {
      // Fallback to localStorage for unauthenticated users
      localStorage.removeItem(DRAFTS_KEY);
    }
    
    // Refresh the view
    if (window.currentView === 'drafts' && typeof renderCurrentView === 'function') {
      renderCurrentView();
    }
    
    showToast('All drafts cleared successfully', 'success');
  } catch (error) {
    console.error('Failed to clear all drafts:', error);
    showToast('Failed to clear drafts', 'error');
  }
}

function toggleCreateDropdown() {
  const container = document.getElementById('createDropdownContainer');
  if (container) {
    container.classList.toggle('open');
  }
}

// Sidebar Create Dropdown
function toggleSidebarCreateDropdown() {
  const dropdown = document.getElementById('sidebarCreateDropdown');
  const btn = document.getElementById('sidebarCreateBtn');
  if (dropdown && btn) {
    dropdown.classList.toggle('show');
    btn.classList.toggle('active');
  }
}

function closeSidebarCreateDropdown() {
  const dropdown = document.getElementById('sidebarCreateDropdown');
  const btn = document.getElementById('sidebarCreateBtn');
  if (dropdown) dropdown.classList.remove('show');
  if (btn) btn.classList.remove('active');
}

// Close dropdowns when clicking outside
document.addEventListener('click', (e) => {
  const container = document.getElementById('createDropdownContainer');
  if (container && !container.contains(e.target)) {
    container.classList.remove('open');
  }

  // Sidebar create dropdown
  const sidebarDropdown = document.getElementById('sidebarCreateDropdown');
  const sidebarBtn = document.getElementById('sidebarCreateBtn');
  if (sidebarDropdown && sidebarBtn && !sidebarDropdown.contains(e.target) && !sidebarBtn.contains(e.target)) {
    sidebarDropdown.classList.remove('show');
    sidebarBtn.classList.remove('active');
  }
});

// ============================================
// Card Item Delete Functions
// ============================================

function deleteCardItem(itemId, itemType, spaceId = null) {
  // Show confirmation dialog
  const confirmHTML = `
    <div style="padding: 24px; text-align: center;">
      <h3 style="margin: 0 0 16px; font-size: 18px; font-weight: 600; color: var(--foreground);">Delete Item?</h3>
      <p style="margin: 0 0 32px; color: var(--muted-foreground); font-size: 14px; line-height: 1.5;">
        Are you sure you want to delete this ${itemType}?<br>
        <strong>This action cannot be undone.</strong>
      </p>
      <div style="display: flex; gap: 12px; justify-content: center;">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-destructive" onclick="confirmDeleteCardItem('${itemId}', '${itemType}', '${spaceId || ''}')">Delete</button>
      </div>
    </div>
  `;

  openModal('Confirm Delete', confirmHTML);
}

function confirmDeleteCardItem(itemId, itemType, spaceId) {
  closeModal();

  // Handle different item types and ensure data is properly updated
  let deletePromise;
  switch (itemType.toLowerCase()) {
    case 'doc':
      deletePromise = deleteDoc(itemId);
      break;
    case 'excel':
      deletePromise = deleteExcel(itemId);
      break;
    case 'bookmark':
      removeBookmark(itemId);
      deletePromise = Promise.resolve(); // Bookmarks don't need async handling
      break;
    default:
      console.warn('Unknown item type for deletion:', itemType);
      return;
  }

  // Handle the deletion promise
  if (deletePromise) {
    deletePromise.then(() => {
      // Remove the card item from UI immediately for better UX
      const cardItem = document.querySelector(`.card-item[data-item-id="${itemId}"]`);
      if (cardItem) {
        cardItem.style.opacity = '0';
        cardItem.style.transform = 'translateX(-20px)';
        setTimeout(() => {
          cardItem.remove();
          // Force re-render of the entire space view to ensure consistency
          setTimeout(() => {
            // Refresh the current space view
            if (typeof openSpaceView === 'function' && spaceId) {
              openSpaceView(spaceId);
            }
            // Also re-render favorites in sidebar if needed
            if (typeof renderFavoritesInSidebar === 'function') {
              renderFavoritesInSidebar();
            }
            // Re-render spaces in sidebar to update counts
            if (typeof renderSpacesInSidebar === 'function') {
              renderSpacesInSidebar();
            }
          }, 100);
        }, 300);
      }
      showToast(`${itemType} deleted successfully`, 'success');
    }).catch((error) => {
      console.error('Deletion failed:', error);
      showToast(`Failed to delete ${itemType}`, 'error');
    });
  }
}

// ============================================
// Doc Storage
// ============================================
function loadDocs() {
  // Only return docs if user is authenticated
  // Docs should only exist in database, not localStorage for unauthenticated users
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return [];
  }

  try {
    return JSON.parse(localStorage.getItem(DOCS_KEY)) || [];
  } catch {
    return [];
  }
}

function saveDocs(docs) {
  localStorage.setItem(DOCS_KEY, JSON.stringify(docs));
}

// Draft Storage
function loadDrafts() {
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return [];
  }

  try {
    // Return cached drafts if available, otherwise load from DB
    if (window.cachedDrafts) {
      return window.cachedDrafts;
    }
    
    // Load asynchronously and cache
    window.LayerDB.loadDrafts().then(drafts => {
      window.cachedDrafts = drafts;
      return drafts;
    }).catch(error => {
      console.error('Error loading drafts from DB:', error);
      return [];
    });
    
    return window.cachedDrafts || [];
  } catch (error) {
    console.error('Error loading drafts:', error);
    return [];
  }
}

function saveDrafts(drafts) {
  // This function is deprecated - use individual save/update operations
  console.warn('saveDrafts() is deprecated. Use individual draft save/update operations.');
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    window.cachedDrafts = drafts;
  }
}

// Initialize drafts from DB on page load
async function initDraftsFromDB() {
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      const drafts = await window.LayerDB.loadDrafts();
      window.cachedDrafts = drafts;
      console.log('✅ Drafts loaded from DB:', drafts.length, 'items');
      return drafts;
    } catch (error) {
      console.error('❌ Error loading drafts from DB:', error);
      return [];
    }
  }
  return [];
}

// Initialize docs from DB on page load
async function initDocsFromDB() {
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      const docs = await window.LayerDB.loadDocs();
      saveDocs(docs);
      return docs;
    } catch (error) {
      console.error('Failed to load docs from database:', error);
    }
  } else {
    // Clear localStorage when not authenticated to prevent showing old docs
    localStorage.removeItem(DOCS_KEY);
  }
  return [];
}

async function addDoc(doc) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create documents', 'error');
    return null;
  }

  try {
    const savedDoc = await window.LayerDB.saveDoc(doc);
    // Refresh local cache
    const docs = await window.LayerDB.loadDocs();
    saveDocs(docs);
    return savedDoc;
  } catch (error) {
    console.error('Failed to save doc to database:', error);
    showToast('Failed to save document', 'error');
    return null;
  }
}

async function updateDoc(id, updates) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to update documents', 'error');
    return;
  }

  try {
    await window.LayerDB.updateDoc(id, updates);
    const docs = await window.LayerDB.loadDocs();
    saveDocs(docs);
  } catch (error) {
    console.error('Failed to update doc in database:', error);
    showToast('Failed to update document', 'error');
  }
}

async function deleteDoc(id) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to delete documents', 'error');
    return Promise.reject(new Error('Not authenticated'));
  }

  try {
    await window.LayerDB.deleteDoc(id);
    const docs = await window.LayerDB.loadDocs();
    saveDocs(docs);
    return Promise.resolve();
  } catch (error) {
    console.error('Failed to delete doc from database:', error);
    showToast('Failed to delete document', 'error');
    return Promise.reject(error);
  }
}

// ============================================
// Document Editor State Management
// ============================================

// 🛡️ GLOBAL STATE: Prevent multiple document editors
let documentEditorState = {
  isOpen: false,
  currentDocId: null,
  overlayElement: null,
  isClosing: false,
  openTimestamp: null,
  eventListeners: [] // Track event listeners for proper cleanup
};

// 🛡️ DEBOUNCE: Prevent rapid successive calls
let docEditorOpenTimeout = null;

// ============================================
// Doc Editor - Professional Word-like UI
// ============================================
function openDocEditor(docId = null) {
  // 🛡️ CRITICAL: Prevent all duplicate calls using a global lock
  if (window._docEditorOpeningLock) {
    console.log('📝 Document editor opening in progress, ignoring duplicate call');
    return;
  }

  // 🛡️ DEBOUNCE: Clear any pending timeout
  if (docEditorOpenTimeout) {
    clearTimeout(docEditorOpenTimeout);
    docEditorOpenTimeout = null;
  }

  // 🛡️ PREVENT DUPLICATION: Check global state first
  if (documentEditorState.isOpen && !documentEditorState.isClosing) {
    console.log('📝 Document editor already open, focusing existing one');
    // If trying to open a different doc, show a toast
    if (docId && documentEditorState.currentDocId !== docId) {
      showToast('Please close the current document first', 'info');
    }
    // Focus the existing editor instead of creating duplicate
    const contentDiv = document.getElementById('docEditorContent');
    if (contentDiv) {
      contentDiv.focus();
      // Bring the overlay to front
      const overlay = document.getElementById('docEditorOverlay');
      if (overlay) {
        overlay.style.zIndex = '10000';
      }
    }
    return;
  }

  // 🛡️ PREVENT DUPLICATION: Check if editor is already open (fallback)
  const existingOverlay = document.getElementById('docEditorOverlay');
  if (existingOverlay && existingOverlay.parentNode) {
    console.log('📝 Document editor already open (fallback check), focusing existing one');
    // If trying to open a different doc, show a toast
    if (docId && documentEditorState.currentDocId !== docId) {
      showToast('Please close the current document first', 'info');
    }
    // Focus the existing editor instead of creating duplicate
    const contentDiv = document.getElementById('docEditorContent');
    if (contentDiv) {
      contentDiv.focus();
      existingOverlay.style.zIndex = '10000';
    }
    return;
  }

  // 🛡️ PREVENT DUPLICATION: If closing, wait for close to complete
  if (documentEditorState.isClosing) {
    console.log('📝 Document editor is closing, waiting for completion...');
    docEditorOpenTimeout = setTimeout(() => {
      openDocEditor(docId);
    }, 100);
    return;
  }

  // Set the lock to prevent duplicate calls
  window._docEditorOpeningLock = true;

  try {
    // Require authentication for creating new docs
    if (!docId && (!window.LayerDB || !window.LayerDB.isAuthenticated())) {
      showToast('Please sign in to create documents', 'error');
      window._docEditorOpeningLock = false;
      return;
    }

    let doc = null;
    if (docId) {
      const docs = loadDocs();
      doc = docs.find(d => d.id === docId);
    }

    // 🔄 UPDATE STATE: Mark editor as opening
    documentEditorState.isOpen = true;
    documentEditorState.currentDocId = doc ? doc.id : Date.now();
    documentEditorState.isClosing = false;
    documentEditorState.openTimestamp = Date.now();
    documentEditorState.eventListeners = []; // Reset event listeners array

    currentDocId = doc ? doc.id : Date.now();
    const isFavorited = doc ? isDocFavorited(doc.id) : false;

  // Get current user for author display
  const currentUser = window.LayerDB?.getCurrentUser() || {};
  const authorName = currentUser.user_metadata?.full_name || currentUser.user_metadata?.name || currentUser.email?.split('@')[0] || 'User';
  const userAvatar = currentUser.user_metadata?.avatar_url || currentUser.user_metadata?.picture;
  const lastUpdated = doc ? formatTimeAgo(doc.updatedAt) : 'Just now';

  // Create avatar HTML
  const getAuthorAvatarHtml = () => {
    if (userAvatar) {
      return `<img src="${userAvatar}" alt="${authorName}" class="notion-author-avatar-img">`;
    } else {
      return `<span class="notion-author-avatar">${authorName.charAt(0).toUpperCase()}</span>`;
    }
  };

  // 🧹 CLEANUP: Remove any existing overlays before creating new one
  const existingOverlays = document.querySelectorAll('.doc-editor-overlay');
  existingOverlays.forEach(overlay => overlay.remove());

  const overlay = document.createElement('div');
  overlay.className = 'doc-editor-overlay';
  overlay.id = 'docEditorOverlay';

  // 🔄 UPDATE STATE: Store reference to overlay
  documentEditorState.overlayElement = overlay;

  overlay.innerHTML = `
    <div class="doc-editor-container notion-style">
      <!-- Minimalistic Header Bar -->
      <div class="doc-editor-header notion-header">
        <div class="doc-header-left">
          <div class="doc-breadcrumb">
            <span class="breadcrumb-item" onclick="closeDocEditor()">Docs</span>
            <span class="breadcrumb-separator">/</span>
            <span class="breadcrumb-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
              </svg>
            </span>
            <span class="breadcrumb-current">Doc</span>
            <button class="doc-favorite-btn-mini ${isFavorited ? 'is-favorite' : ''}" data-favorite-doc="${currentDocId}" onclick="toggleDocFavorite('${currentDocId}')" title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">
              <svg viewBox="0 0 24 24" fill="${isFavorited ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="doc-header-right notion-actions">
          <!-- Shared Users Avatars -->
          <div class="doc-shared-avatars" id="docSharedAvatars" style="display: flex; align-items: center; margin-right: 16px;">
            <!-- Avatars will be populated here -->
          </div>
          
          <button class="notion-action-btn" onclick="insertLink()" title="Add link">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            </svg>
          </button>
          <button class="notion-action-btn" onclick="openInEditorSharePanel('doc')" title="Share">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
              <circle cx="9" cy="7" r="4"/>
              <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
              <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
            </svg>
            Share
          </button>
          <button class="notion-action-btn doc-ask-ai-header-btn" onclick="toggleDocAiSidebar()" title="Ask AI">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2v10z"/>
              <path d="M8 10h.01M12 10h.01M16 10h.01"/>
            </svg>
            Ask AI
          </button>
          <button class="notion-action-btn" title="More options">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <circle cx="12" cy="12" r="1"/>
              <circle cx="19" cy="12" r="1"/>
              <circle cx="5" cy="12" r="1"/>
            </svg>
          </button>
          <button class="doc-close-btn" onclick="closeDocEditor()" title="Close">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>
      </div>
      
      <!-- AI Sidebar - LEFT Side - Minimalistic ClickUp Brain Style -->
      <div class="doc-ai-sidebar" id="docAiSidebar">
        <div class="ai-sidebar-header">
          <div class="ai-sidebar-brand">
            <div class="ai-sidebar-brain-icon">
              <div class="ai-brain-pulse"></div>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 4.44-1.54"/>
                <path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-4.44-1.54"/>
              </svg>
            </div>
            <span class="ai-sidebar-title-text">Brain</span>
          </div>
          <button class="ai-sidebar-close-minimal" onclick="toggleDocAiSidebar()" title="Close">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>
        <div class="ai-sidebar-messages" id="docAiMessages">
          <div class="ai-welcome-message">
            <div class="ai-welcome-header">
              <div class="ai-welcome-avatar">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 4.44-1.54"/>
                  <path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-4.44-1.54"/>
                </svg>
              </div>
              <div class="ai-welcome-content">
                <div class="ai-welcome-name">Brain</div>
                <div class="ai-welcome-text">Welcome back! Feel free to ask me anything about this Doc. How can I help?</div>
              </div>
            </div>
          </div>
        </div>
        <div class="ai-sidebar-input-minimal">
          <div class="ai-input-container">
            <textarea id="docAiInput" placeholder="Tell AI what to do next" rows="1" onkeydown="if(event.key==='Enter' && !event.shiftKey){event.preventDefault();handleDocAiSend()}"></textarea>
            <div class="ai-input-actions">
              <button class="ai-input-action-btn" title="Attach">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M12 5v14M5 12h14"/>
                </svg>
              </button>
              <button class="ai-input-action-btn" title="Settings">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="1"/>
                </svg>
              </button>
              <button class="ai-send-btn" onclick="handleDocAiSend()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="ai-page-context">
            <div class="ai-page-context-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
              </svg>
            </div>
            <span class="ai-page-context-text"><span class="ai-page-context-name">Untitled</span> Page</span>
          </div>
        </div>
      </div>
      
      <!-- Right Action Bar -->
      <div class="notion-right-actions">
        <button class="notion-right-btn" onclick="openPageStylesSidebar()" title="Page Styles">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:18px;height:18px;">
            <rect x="3" y="3" width="18" height="18" rx="2"/>
            <path d="M7 7h10M7 12h6M7 17h8"/>
          </svg>
          <span class="notion-right-label">Aa</span>
        </button>
        <button class="notion-right-btn" onclick="insertLink()" title="Add link">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:18px;height:18px;">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
          </svg>
        </button>
        <button class="notion-right-btn" onclick="saveCurrentDoc()" title="Save">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:18px;height:18px;">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
            <polyline points="17 21 17 13 7 13 7 21"/>
            <polyline points="7 3 7 8 15 8"/>
          </svg>
        </button>
        <button class="notion-right-btn" onclick="exportDocAsPDF()" title="Download">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:18px;height:18px;">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
        </button>
      </div>
      
      <!-- Document Content Area - Notion Style -->
      <div class="doc-content-area notion-content-area">
        <div class="notion-page-container">
          <!-- Link Task or Doc -->
          <div class="notion-link-task" onclick="showComingSoonToast()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
            </svg>
            Link Task or Doc
          </div>
          
          <!-- Title Input - Large like Notion -->
          <input type="text" class="notion-title-input" id="docTitleInput" 
                 placeholder="Untitled" value="${doc ? doc.title : ''}" />
          
          <!-- Author and Last Updated -->
          <div class="notion-meta">
            <div class="notion-author">
              ${getAuthorAvatarHtml()}
              <span class="notion-author-name">${authorName}</span>
            </div>
            <span class="notion-meta-separator">·</span>
            <span class="notion-last-updated">Last updated ${lastUpdated}</span>
          </div>
          
          <!-- Content Editor -->
          <div class="notion-editor-content" id="docEditorContent" contenteditable="true" spellcheck="true">${doc ? doc.content : ''}</div>
        </div>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);
  document.body.style.overflow = 'hidden';

  // Set up placeholder and autosave
  setupNotionEditor();

  // Set up AI command (** trigger)
  setupDocAiCommand();

  // Load and display shared users avatars instantly when opening existing doc
  if (doc) {
    loadExistingSharedUsers('doc').then(() => {
      // Update avatars immediately after loading shared users
      updateDocHeaderAvatars(inEditorShareEmails);
    });
  }
  // Auto-create the document immediately if new (auth already checked at function start)
  if (!doc) {
    const newDoc = {
      id: currentDocId,
      title: 'Untitled',
      content: '',
      spaceId: currentSpaceId || null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      isDraft: true // Mark as draft initially
    };

    // Save to Supabase immediately and synchronously
    (async () => {
      try {
        console.log('📝 Creating new document in DB:', newDoc);
        const savedDoc = await window.LayerDB.saveDoc(newDoc);
        // Update currentDocId to use database ID
        currentDocId = savedDoc.id;
        console.log('📝 Document created successfully with DB ID:', currentDocId);

        // Create a draft entry for the document
        if (window.LayerDB && window.LayerDB.isAuthenticated()) {
          try {
            const draftEntry = {
              title: savedDoc.title,
              content: savedDoc.content || '',
              type: 'doc',
              metadata: { docId: savedDoc.id },
              createdAt: savedDoc.createdAt,
              updatedAt: savedDoc.updatedAt
            };
            
            const savedDraft = await window.LayerDB.saveDraft(draftEntry);
            console.log('✅ Document draft saved to DB:', savedDraft.id);
            
            // Update cache
            if (window.cachedDrafts) {
              window.cachedDrafts.unshift(savedDraft);
            }
          } catch (error) {
            console.error('❌ Failed to save document draft to DB:', error);
          }
        } else {
          // Fallback to localStorage for unauthenticated users
          const drafts = loadDrafts();
          const draftEntry = {
            id: savedDoc.id,
            title: savedDoc.title,
            type: 'doc',
            createdAt: savedDoc.createdAt,
            updatedAt: savedDoc.updatedAt
          };
          drafts.push(draftEntry);
          saveDrafts(drafts);
        }

        // Mark drafts view for refresh
        window.draftsNeedRefresh = true;

        const docs = await window.LayerDB.loadDocs();
        saveDocs(docs);
        
        // Show success message
        if (typeof showToast === 'function') {
          showToast('Document created and saved as draft', 'success');
        }
      } catch (error) {
        console.error('Failed to create doc in database:', error);
        showToast('Failed to save document', 'error');
      }
    })();
  } else {
    // For existing documents, check if title is "Untitled" and generate from content
    if (doc.title === 'Untitled' && doc.content && doc.content.trim() !== '') {
      const generatedTitle = generateTitleFromContent(doc.content);
      if (generatedTitle !== 'Untitled') {
        // Update the title input immediately
        setTimeout(() => {
          const titleInput = document.getElementById('docTitleInput');
          if (titleInput) {
            titleInput.value = generatedTitle;
            console.log('📝 Updated existing document title from content:', generatedTitle);
            
            // Save the updated title
            (async () => {
              try {
                await window.LayerDB.updateDoc(doc.id, { title: generatedTitle });
                const docs = await window.LayerDB.loadDocs();
                saveDocs(docs);
                
                // Update drafts
                if (window.LayerDB && window.LayerDB.isAuthenticated()) {
                  try {
                    const drafts = await window.LayerDB.loadDrafts();
                    const draftIndex = drafts.findIndex(d => d.id === doc.id);
                    if (draftIndex !== -1) {
                      const updatedDraft = {
                        ...drafts[draftIndex],
                        title: generatedTitle,
                        updatedAt: new Date().toISOString()
                      };
                      await window.LayerDB.updateDraft(doc.id, updatedDraft);
                      
                      // Update cache
                      if (window.cachedDrafts) {
                        const cacheIndex = window.cachedDrafts.findIndex(d => d.id === doc.id);
                        if (cacheIndex !== -1) {
                          window.cachedDrafts[cacheIndex] = updatedDraft;
                        }
                      }
                    }
                  } catch (error) {
                    console.error('❌ Failed to update draft title in DB:', error);
                  }
                } else {
                  // Fallback to localStorage
                  const drafts = loadDrafts();
                  const draftIndex = drafts.findIndex(d => d.id === doc.id);
                  if (draftIndex !== -1) {
                    drafts[draftIndex].title = generatedTitle;
                    drafts[draftIndex].updatedAt = new Date().toISOString();
                    saveDrafts(drafts);
                  }
                }
                
                console.log('✅ Updated existing document title in database');
              } catch (error) {
                console.error('Failed to update existing document title:', error);
              }
            })();
          }
        }, 100);
      }
    }
  }

  setTimeout(() => {
    document.getElementById('docTitleInput')?.focus();
  }, 100);

  } finally {
    // 🛡️ RELEASE LOCK: Always release the lock when done
    window._docEditorOpeningLock = false;
  }
}

function setupNotionEditor() {
  const contentDiv = document.getElementById('docEditorContent');
  const titleInput = document.getElementById('docTitleInput');
  if (!contentDiv) return;

  // Placeholder behavior
  contentDiv.addEventListener('focus', function () {
    if (this.textContent.trim() === '' && !this.querySelector('*')) {
      this.innerHTML = '';
    }
  });

  contentDiv.addEventListener('blur', function () {
    if (this.textContent.trim() === '') {
      this.innerHTML = '';
    }
  });

  // Debounced auto-save function
  let saveTimeout;
  function triggerAutoSave() {
    clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => {
      autoSaveDoc();
      showAutoSaveIndicator();
    }, 500); // Reduced to 500ms for faster saves
  }

  // Auto-save on multiple events for comprehensive coverage
  contentDiv.addEventListener('input', triggerAutoSave);
  contentDiv.addEventListener('keyup', triggerAutoSave);
  contentDiv.addEventListener('paste', function () {
    setTimeout(triggerAutoSave, 100); // Delay slightly after paste
  });
  contentDiv.addEventListener('cut', function () {
    setTimeout(triggerAutoSave, 100);
  });
  contentDiv.addEventListener('blur', function () {
    // Save immediately on blur
    autoSaveDoc();
  });

  // Generate title from content when title is still "Untitled"
  contentDiv.addEventListener('input', function() {
    const titleInput = document.getElementById('docTitleInput');
    if (titleInput && titleInput.value.trim() === 'Untitled') {
      const generatedTitle = generateTitleFromContent(this.innerHTML);
      if (generatedTitle !== 'Untitled') {
        titleInput.value = generatedTitle;
        syncDraftCardTitle(currentDocId, generatedTitle);
        console.log('📝 Auto-generated title from content:', generatedTitle);
      }
    }
  });

  // Use MutationObserver for reliable change detection (catches formatting changes too)
  const observer = new MutationObserver(function (mutations) {
    triggerAutoSave();
    
    // Also check for title generation from content
    const titleInput = document.getElementById('docTitleInput');
    if (titleInput && titleInput.value.trim() === 'Untitled') {
      const generatedTitle = generateTitleFromContent(contentDiv.innerHTML);
      if (generatedTitle !== 'Untitled') {
        titleInput.value = generatedTitle;
        syncDraftCardTitle(currentDocId, generatedTitle);
        console.log('📝 Auto-generated title from content (MutationObserver):', generatedTitle);
      }
    }
  });
  observer.observe(contentDiv, {
    childList: true,
    subtree: true,
    characterData: true,
    attributes: true
  });

  // Auto-save on title change
  if (titleInput) {
    titleInput.addEventListener('input', triggerAutoSave);
    titleInput.addEventListener('blur', function () {
      autoSaveDoc();
    });
    
    // Real-time title sync with draft cards
    titleInput.addEventListener('input', function() {
      const newTitle = this.value.trim() || 'Untitled';
      syncDraftCardTitle(currentDocId, newTitle);
    });
  }

  // Handle keyboard shortcuts
  contentDiv.addEventListener('keydown', function (e) {
    if (e.key === '/' && contentDiv.textContent.trim() === '') {
      // Show slash command menu (coming soon)
    }
    // Ctrl+S / Cmd+S to force save
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      e.preventDefault();
      autoSaveDoc();
      showAutoSaveIndicator();
    }
  });
}

function showAutoSaveIndicator() {
  // Show a subtle auto-save indicator
  let indicator = document.getElementById('autoSaveIndicator');
  if (!indicator) {
    indicator = document.createElement('div');
    indicator.id = 'autoSaveIndicator';
    indicator.style.cssText = `
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      padding: 8px 16px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 12px;
      color: var(--muted-foreground);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 9999;
      display: flex;
      align-items: center;
      gap: 6px;
    `;
    indicator.innerHTML = `
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;color:var(--status-done);">
        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
        <polyline points="22 4 12 14.01 9 11.01"/>
      </svg>
      Auto-saved
    `;
    document.body.appendChild(indicator);
  }

  indicator.style.opacity = '1';
  indicator.style.transform = 'translateX(-50%) translateY(0)';

  setTimeout(() => {
    indicator.style.opacity = '0';
    indicator.style.transform = 'translateX(-50%) translateY(20px)';
  }, 2000);
}

// Generate a meaningful title from document content
function generateTitleFromContent(content) {
  if (!content || content.trim() === '') {
    return 'Untitled';
  }
  
  // Remove HTML tags and get plain text
  const plainText = content.replace(/<[^>]*>/g, '').replace(/&nbsp;/g, ' ').trim();
  
  if (!plainText) {
    return 'Untitled';
  }
  
  // Get first few words or characters
  const words = plainText.split(/\s+/).filter(word => word.length > 0);
  
  if (words.length === 0) {
    return 'Untitled';
  }
  
  // Try to get first 3-5 words, but limit to 50 characters
  let title = '';
  let charCount = 0;
  let wordCount = 0;
  
  for (const word of words) {
    if (charCount + word.length + (title ? 1 : 0) > 50) {
      break;
    }
    if (wordCount >= 5) {
      break;
    }
    
    if (title) {
      title += ' ';
      charCount += 1;
    }
    
    title += word;
    charCount += word.length;
    wordCount++;
  }
  
  // Capitalize first letter
  if (title.length > 0) {
    title = title.charAt(0).toUpperCase() + title.slice(1);
  }
  
  // Add ellipsis if truncated
  if ((words.length > wordCount) || (plainText.length > 50)) {
    title += '...';
  }
  
  return title || 'Untitled';
}

// Real-time sync of draft card title with notion title input
function syncDraftCardTitle(draftId, newTitle) {
  if (!draftId) return;
  
  console.log(`🔄 Syncing title for draft ${draftId}: "${newTitle}"`);
  
  // Update draft card title in the DOM if drafts view is currently visible
  const draftCards = document.querySelectorAll('.draft-card');
  let updatedInDOM = false;
  
  draftCards.forEach(card => {
    const titleElement = card.querySelector('.draft-card-title');
    if (titleElement && titleElement.getAttribute('onclick') && titleElement.getAttribute('onclick').includes(draftId)) {
      titleElement.textContent = newTitle;
      updatedInDOM = true;
      console.log(`✅ Updated draft card title in DOM: "${newTitle}"`);
    }
  });
  
  if (!updatedInDOM && draftCards.length > 0) {
    console.log(`ℹ️ Draft card not found in DOM for ID: ${draftId} (drafts view may not be visible)`);
  }
  
  // Also update in localStorage drafts data for consistency
  try {
    const drafts = loadDrafts();
    const draftIndex = drafts.findIndex(d => d.id === draftId);
    if (draftIndex !== -1) {
      const oldTitle = drafts[draftIndex].title;
      drafts[draftIndex].title = newTitle;
      drafts[draftIndex].updatedAt = new Date().toISOString();
      saveDrafts(drafts);
      console.log(`✅ Updated draft title in localStorage: "${oldTitle}" → "${newTitle}"`);
    } else {
      console.log(`⚠️ Draft not found in localStorage for ID: ${draftId}`);
    }
  } catch (error) {
    console.error('❌ Failed to sync draft title in localStorage:', error);
  }
}

async function autoSaveDoc() {
  // Prevent concurrent saves
  if (isSavingDoc) {
    console.log('📝 Save already in progress, skipping...');
    return;
  }

  const titleInput = document.getElementById('docTitleInput');
  const contentDiv = document.getElementById('docEditorContent');

  if (!titleInput || !contentDiv) return;

  let title = titleInput.value.trim() || 'Untitled';
  const content = contentDiv.innerHTML;
  
  // If title is still "Untitled", try to generate one from content
  if (title === 'Untitled') {
    const generatedTitle = generateTitleFromContent(content);
    if (generatedTitle !== 'Untitled') {
      title = generatedTitle;
      // Update the title input field with the generated title
      titleInput.value = title;
      console.log('📝 Generated title from content:', title);
    }
  }

  isSavingDoc = true;

  try {
    // Use Supabase if authenticated
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      try {
        // Check if this is a new document (temporary ID) or existing document
        const docs = await window.LayerDB.loadDocs();
        const existingDoc = docs.find(d => d.id === currentDocId);

        if (existingDoc) {
          // Document exists, update it
          console.log('📝 Updating existing doc:', currentDocId);
          await window.LayerDB.updateDoc(currentDocId, { title, content });
        } else {
          // Document doesn't exist in DB yet (likely new doc), create it first
          console.log('📝 Creating new doc in DB:', currentDocId);
          const newDoc = {
            id: currentDocId,
            title,
            content,
            spaceId: currentSpaceId || null,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          };
          const savedDoc = await window.LayerDB.saveDoc(newDoc);
          // Update currentDocId to use the database ID
          currentDocId = savedDoc.id;
          console.log('📝 Doc created with DB ID:', currentDocId);
        }

        // Sync draft title
        const drafts = loadDrafts();
        const draftIndex = drafts.findIndex(d => d.id === currentDocId);
        if (draftIndex !== -1) {
          drafts[draftIndex].title = title;
          drafts[draftIndex].updatedAt = new Date().toISOString();
          saveDrafts(drafts);
          console.log('📝 Draft title synced:', title);
          // Mark drafts view for refresh so title shows updated
          window.draftsNeedRefresh = true;
        }

        // Refresh local cache
        const updatedDocs = await window.LayerDB.loadDocs();
        saveDocs(updatedDocs);
        return;
      } catch (error) {
        console.error('❌ Failed to auto-save doc to database:', error);
        // Show error to user
        if (typeof showToast === 'function') {
          showToast('Failed to save document to cloud', 'error');
        }
      }
    }

    // Fallback to localStorage
    console.log('📝 Saving to localStorage fallback');
    const docs = loadDocs();
    const existingIndex = docs.findIndex(d => d.id === currentDocId);

    if (existingIndex !== -1) {
      docs[existingIndex] = {
        ...docs[existingIndex],
        title,
        content,
        updatedAt: new Date().toISOString()
      };
      saveDocs(docs);
    } else {
      // Save new document
      docs.unshift({
        id: currentDocId,
        title,
        content,
        spaceId: currentSpaceId || null,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      });
      saveDocs(docs);
    }

    // Sync draft title in localStorage
    const drafts = loadDrafts();
    const draftIndex = drafts.findIndex(d => d.id === currentDocId);
    if (draftIndex !== -1) {
      drafts[draftIndex].title = title;
      drafts[draftIndex].updatedAt = new Date().toISOString();
      saveDrafts(drafts);
      // Mark drafts view for refresh so title shows updated
      window.draftsNeedRefresh = true;
    }
  } finally {
    isSavingDoc = false;
  }
}

function closeDocEditor() {
  console.log('🔒 Closing document editor...');

  // 🛡️ PREVENT RE-ENTRY: Mark as closing to prevent race conditions
  documentEditorState.isClosing = true;

  // 🧹 COMPREHENSIVE CLEANUP: Remove tracked event listeners
  if (documentEditorState.eventListeners && documentEditorState.eventListeners.length > 0) {
    documentEditorState.eventListeners.forEach(({ element, event, handler }) => {
      if (element && handler) {
        element.removeEventListener(event, handler);
      }
    });
    documentEditorState.eventListeners = [];
  }

  // 🧹 COMPREHENSIVE CLEANUP: Remove all overlays and reset state
  const overlays = document.querySelectorAll('.doc-editor-overlay');
  overlays.forEach(overlay => {
    // Remove any remaining event listeners
    overlay.removeEventListener('click', closeDocEditor);
    overlay.remove();
  });

  // Reset body styles
  document.body.style.overflow = '';

  // Reset document state
  currentDocId = null;
  isSavingDoc = false; // Reset save lock

  // 🛡️ RESET GLOBAL STATE: Mark editor as closed so it can be reopened
  documentEditorState.isOpen = false;
  documentEditorState.currentDocId = null;
  documentEditorState.isClosing = false;
  documentEditorState.overlayElement = null;

  // 🔄 REFRESH DASHBOARD: Update the inbox view to reflect any changes
  // Use a small delay to ensure DOM is fully cleaned up
  setTimeout(() => {
    if (currentView === 'inbox') {
      console.log('🔄 Refreshing dashboard after document close...');
      renderCurrentView();
    }
  }, 100);
}

function execDocCommand(command, value = null) {
  document.execCommand(command, false, value);
  document.getElementById('docEditorContent')?.focus();
}

function setFontSize(size) {
  document.execCommand('fontSize', false, size);
  document.getElementById('docEditorContent')?.focus();
}

function setupWordCount() {
  const contentDiv = document.getElementById('docEditorContent');
  if (!contentDiv) return;

  const updateCount = () => {
    const text = contentDiv.innerText || '';
    const words = text.trim() ? text.trim().split(/\s+/).length : 0;
    const chars = text.length;

    const wordCountEl = document.getElementById('wordCount');
    const charCountEl = document.getElementById('charCount');

    if (wordCountEl) wordCountEl.textContent = `Words: ${words}`;
    if (charCountEl) charCountEl.textContent = `Characters: ${chars}`;
  };

  contentDiv.addEventListener('input', updateCount);
  updateCount();
}

function insertLink() {
  const url = prompt('Enter URL:', 'https://');
  if (url) {
    document.execCommand('createLink', false, url);
    document.getElementById('docEditorContent')?.focus();
  }
}

function insertImage() {
  const url = prompt('Enter image URL:', 'https://');
  if (url) {
    document.execCommand('insertImage', false, url);
    document.getElementById('docEditorContent')?.focus();
  }
}

function insertTable() {
  const rows = prompt('Number of rows:', '3') || '3';
  const cols = prompt('Number of columns:', '3') || '3';

  let tableHtml = '<table style="border-collapse: collapse; width: 100%; margin: 16px 0;">';
  for (let r = 0; r < parseInt(rows); r++) {
    tableHtml += '<tr>';
    for (let c = 0; c < parseInt(cols); c++) {
      tableHtml += '<td style="border: 1px solid var(--border); padding: 8px; min-width: 80px;">&nbsp;</td>';
    }
    tableHtml += '</tr>';
  }
  tableHtml += '</table>';

  document.execCommand('insertHTML', false, tableHtml);
  document.getElementById('docEditorContent')?.focus();
}

function insertHorizontalRule() {
  document.execCommand('insertHorizontalRule', false, null);
  document.getElementById('docEditorContent')?.focus();
}

function exportDocAsPDF() {
  showToast('PDF export feature coming soon!');
}

function printDoc() {
  const content = document.getElementById('docEditorContent');
  const title = document.getElementById('docTitleInput')?.value || 'Document';

  if (!content) return;

  const printWindow = window.open('', '_blank');
  printWindow.document.write(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>${title}</title>
      <style>
        body { font-family: Georgia, serif; padding: 40px; max-width: 800px; margin: 0 auto; line-height: 1.7; }
        h1 { font-size: 24px; font-weight: bold; margin-bottom: 24px; }
        h2 { font-size: 20px; font-weight: bold; margin: 20px 0 16px; }
        h3 { font-size: 18px; font-weight: bold; margin: 16px 0 12px; }
        p { margin: 12px 0; }
        ul, ol { margin: 12px 0; padding-left: 24px; }
        table { border-collapse: collapse; width: 100%; margin: 16px 0; }
        td, th { border: 1px solid #ddd; padding: 8px; }
        blockquote { margin: 16px 0; padding-left: 16px; border-left: 4px solid #3b82f6; color: #666; }
        @media print { body { padding: 0; } }
      </style>
    </head>
    <body>
      <h1>${title}</h1>
      ${content.innerHTML}
    </body>
    </html>
  `);
  printWindow.document.close();
  printWindow.print();
}

function saveCurrentDoc() {
  // Show inline save panel in the doc editor instead of modal
  showInDocSavePanel();
}

function showInDocSavePanel() {
  const spaces = loadSpaces();

  // Remove existing panel if any
  const existingPanel = document.getElementById('inDocSavePanel');
  if (existingPanel) existingPanel.remove();

  if (spaces.length === 0) {
    showToast('Create a space first to organize your documents');
    return;
  }

  const panel = document.createElement('div');
  panel.id = 'inDocSavePanel';
  panel.className = 'in-doc-save-panel';
  panel.innerHTML = `
    <div class="in-doc-save-header">
      <span>Save to Space</span>
      <button class="in-doc-save-close" onclick="closeInDocSavePanel()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    <div class="in-doc-save-list">
      ${spaces.map(space => `
        <button class="in-doc-save-space-btn" onclick="confirmSaveDocToSpace(${space.id}); closeInDocSavePanel();">
          <div class="in-doc-save-space-icon">${getSpaceIconSVGById(space.icon)}</div>
          <span>${space.name}</span>
        </button>
      `).join('')}
    </div>
  `;

  const container = document.querySelector('.doc-editor-container');
  if (container) {
    container.appendChild(panel);
    setTimeout(() => panel.classList.add('show'), 10);
  }
}

function closeInDocSavePanel() {
  const panel = document.getElementById('inDocSavePanel');
  if (panel) {
    panel.classList.remove('show');
    setTimeout(() => panel.remove(), 200);
  }
}

function confirmSaveDocToSpace(spaceId) {
  const titleInput = document.getElementById('docTitleInput');
  const contentDiv = document.getElementById('docEditorContent');

  if (!titleInput || !contentDiv) {
    closeModal();
    return;
  }

  const title = titleInput.value.trim() || 'Untitled Document';
  const content = contentDiv.innerHTML;

  const docs = loadDocs();
  const existingIndex = docs.findIndex(d => d.id === currentDocId);

  if (existingIndex !== -1) {
    docs[existingIndex] = {
      ...docs[existingIndex],
      title,
      content,
      spaceId: spaceId,
      updatedAt: new Date().toISOString()
    };
  } else {
    docs.unshift({
      id: currentDocId,
      title,
      content,
      spaceId: spaceId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });
  }

  saveDocs(docs);
  closeModal();

  // Refresh favorites sidebar
  renderFavoritesInSidebar();

  const spaces = loadSpaces();
  const space = spaces.find(s => String(s.id) === String(spaceId));
  showToast('Document saved to "' + (space ? space.name : 'Space') + '"!');
}

// ============================================
// Excel Storage
// ============================================
function loadExcels() {
  // Only return excels if user is authenticated
  // Excels should only exist in database, not localStorage for unauthenticated users
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return [];
  }

  try {
    return JSON.parse(localStorage.getItem(EXCELS_KEY)) || [];
  } catch {
    return [];
  }
}

function saveExcels(excels) {
  localStorage.setItem(EXCELS_KEY, JSON.stringify(excels));
}

// Initialize excels from DB on page load
async function initExcelsFromDB() {
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      const excels = await window.LayerDB.loadExcels();
      saveExcels(excels);
      return excels;
    } catch (error) {
      console.error('Failed to load excels from database:', error);
    }
  } else {
    // Clear localStorage when not authenticated to prevent showing old excels
    localStorage.removeItem(EXCELS_KEY);
  }
  return [];
}

async function addExcel(excel) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create spreadsheets', 'error');
    return null;
  }

  try {
    const savedExcel = await window.LayerDB.saveExcel(excel);
    const excels = await window.LayerDB.loadExcels();
    saveExcels(excels);
    return savedExcel;
  } catch (error) {
    console.error('Failed to save excel to database:', error);
    showToast('Failed to save spreadsheet', 'error');
    return null;
  }
}

async function updateExcel(id, updates) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to update spreadsheets', 'error');
    return;
  }

  try {
    await window.LayerDB.updateExcel(id, updates);
    const excels = await window.LayerDB.loadExcels();
    saveExcels(excels);
  } catch (error) {
    console.error('Failed to update excel in database:', error);
    showToast('Failed to update spreadsheet', 'error');
  }
}

async function deleteExcel(id) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to delete spreadsheets', 'error');
    return Promise.reject(new Error('Not authenticated'));
  }

  try {
    await window.LayerDB.deleteExcel(id);
    const excels = await window.LayerDB.loadExcels();
    saveExcels(excels);
    return Promise.resolve();
  } catch (error) {
    console.error('Failed to delete excel from database:', error);
    showToast('Failed to delete spreadsheet', 'error');
    return Promise.reject(error);
  }
}

// ============================================
// Excel Editor
// ============================================
const DEFAULT_ROWS = 20;
const DEFAULT_COLS = 10;
const COLUMN_LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

function openExcelEditor(excelId = null) {
  toggleCreateDropdown();

  // Require authentication for creating new spreadsheets
  if (!excelId && (!window.LayerDB || !window.LayerDB.isAuthenticated())) {
    showToast('Please sign in to create spreadsheets', 'error');
    return;
  }

  let excel = null;
  if (excelId) {
    const excels = loadExcels();
    excel = excels.find(e => e.id === excelId);
  }

  currentExcelId = excel ? excel.id : Date.now();
  const data = excel ? excel.data : createEmptyGrid(DEFAULT_ROWS, DEFAULT_COLS);
  const isFavorited = excel ? isExcelFavorited(excel.id) : false;

  // Get current user for author display
  const currentUser = window.LayerDB?.getCurrentUser() || {};
  const authorName = currentUser.user_metadata?.full_name || currentUser.user_metadata?.name || currentUser.email?.split('@')[0] || 'User';
  const userAvatar = currentUser.user_metadata?.avatar_url || currentUser.user_metadata?.picture;
  const lastUpdated = excel ? formatTimeAgo(excel.updatedAt) : 'Just now';

  // Create avatar HTML
  const getAuthorAvatarHtml = () => {
    if (userAvatar) {
      return `<img src="${userAvatar}" alt="${authorName}" class="notion-author-avatar-img">`;
    } else {
      return `<span class="notion-author-avatar">${authorName.charAt(0).toUpperCase()}</span>`;
    }
  };

  const overlay = document.createElement('div');
  overlay.className = 'excel-editor-overlay';
  overlay.id = 'excelEditorOverlay';

  overlay.innerHTML = `
    <div class="excel-editor-container notion-style">
      <!-- Minimalistic Header Bar -->
      <div class="doc-editor-header notion-header">
        <div class="doc-header-left">
          <div class="doc-breadcrumb">
            <span class="breadcrumb-item" onclick="closeExcelEditor()">Spreadsheets</span>
            <span class="breadcrumb-separator">/</span>
            <span class="breadcrumb-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <line x1="3" y1="9" x2="21" y2="9"/>
                <line x1="9" y1="3" x2="9" y2="21"/>
              </svg>
            </span>
            <span class="breadcrumb-current">Sheet</span>
            <button class="doc-favorite-btn-mini ${isFavorited ? 'is-favorite' : ''}" data-favorite-excel="${currentExcelId}" onclick="toggleExcelFavorite(${currentExcelId})" title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">
              <svg viewBox="0 0 24 24" fill="${isFavorited ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="doc-header-right notion-actions">
          <!-- Shared Users Avatars -->
          <div class="doc-shared-avatars" id="excelSharedAvatars" style="display: flex; align-items: center; margin-right: 16px;">
            <!-- Avatars will be populated here -->
          </div>
          <button class="notion-action-btn" onclick="insertExcelLink()" title="Add link">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
              <path d="M3 15h18"/>
              <path d="M12 12v6"/>
            </svg>
          </button>
          <button class="notion-action-btn" onclick="addExcelRow()" title="Add Row">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
              <path d="M3 15h18"/>
              <path d="M12 12v6"/>
            </svg>
          </button>
          <button class="notion-action-btn" onclick="addExcelColumn()" title="Add Column">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
              <path d="M15 3v18"/>
              <path d="M12 12h6"/>
            </svg>
          </button>
          <button class="notion-action-btn" onclick="openInEditorSharePanel('excel')" title="Share">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
              <circle cx="9" cy="7" r="4"/>
              <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
              <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
            </svg>
            Share
          </button>
          <button class="notion-action-btn" title="More options">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <circle cx="12" cy="12" r="1"/>
              <circle cx="19" cy="12" r="1"/>
              <circle cx="5" cy="12" r="1"/>
            </svg>
          </button>
          <button class="doc-close-btn" onclick="closeExcelEditor()" title="Close">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>
      </div>
      
      <!-- Right Action Bar -->
      <div class="notion-right-actions">
        <button class="notion-right-btn" onclick="addExcelRow()" title="Add Row">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:18px;height:18px;">
            <rect x="3" y="3" width="18" height="18" rx="2"/>
            <path d="M3 15h18"/>
            <path d="M12 12v6"/>
          </svg>
        </button>
        <button class="notion-right-btn" onclick="addExcelColumn()" title="Add Column">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:18px;height:18px;">
            <rect x="3" y="3" width="18" height="18" rx="2"/>
            <path d="M15 3v18"/>
            <path d="M12 12h6"/>
          </svg>
        </button>
        <button class="notion-right-btn" onclick="saveCurrentExcel()" title="Save">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:18px;height:18px;">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
            <polyline points="17 21 17 13 7 13 7 21"/>
            <polyline points="7 3 7 8 15 8"/>
          </svg>
        </button>
        <button class="notion-right-btn" onclick="exportExcelAsCSV()" title="Export CSV">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:18px;height:18px;">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
        </button>
      </div>
      
      <!-- Spreadsheet Content Area - Notion Style -->
      <div class="doc-content-area notion-content-area excel-notion-content">
        <div class="notion-page-container excel-page-container">
          <!-- Title Input - Large like Notion -->
          <input type="text" class="notion-title-input" id="excelTitleInput" 
                 placeholder="Untitled Spreadsheet" value="${excel ? excel.title : ''}" />
          
          <!-- Author and Last Updated -->
          <div class="notion-meta">
            <div class="notion-author">
              ${getAuthorAvatarHtml()}
              <span class="notion-author-name">${authorName}</span>
            </div>
            <span class="notion-meta-separator">·</span>
            <span class="notion-last-updated">Last updated ${lastUpdated}</span>
          </div>
          
          <!-- Excel Grid -->
          <div class="excel-grid-wrapper">
            <div class="excel-grid" id="excelGrid" style="grid-template-columns: 50px repeat(${data[0]?.length || DEFAULT_COLS}, 120px);">
              ${renderExcelGrid(data)}
            </div>
          </div>
        </div>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);
  document.body.style.overflow = 'hidden';

  // Load and display shared users avatars instantly when opening existing excel
  if (excel) {
    loadExistingSharedUsers('excel').then(() => {
      // Update avatars immediately after loading shared users
      updateExcelHeaderAvatars(inEditorShareEmails);
    });
  }

  // Auto-create the spreadsheet immediately if new (auth already checked at function start)
  if (!excel) {
    const newExcel = {
      id: currentExcelId,
      title: 'Untitled Spreadsheet',
      data: createEmptyGrid(DEFAULT_ROWS, DEFAULT_COLS),
      spaceId: currentSpaceId || null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      isDraft: true // Mark as draft initially
    };

    // Save to Supabase (auth is guaranteed by check at function start)
    (async () => {
      try {
        const savedExcel = await window.LayerDB.saveExcel(newExcel);
        // Update currentExcelId to use database ID
        currentExcelId = savedExcel.id;

        // Create a draft entry for the spreadsheet
        if (window.LayerDB && window.LayerDB.isAuthenticated()) {
          try {
            const draftEntry = {
              title: savedExcel.title,
              content: JSON.stringify(savedExcel.data || []),
              type: 'sheet',
              metadata: { excelId: savedExcel.id },
              createdAt: savedExcel.createdAt,
              updatedAt: savedExcel.updatedAt
            };
            
            const savedDraft = await window.LayerDB.saveDraft(draftEntry);
            console.log('✅ Spreadsheet draft saved to DB:', savedDraft.id);
            
            // Update cache
            if (window.cachedDrafts) {
              window.cachedDrafts.unshift(savedDraft);
            }
          } catch (error) {
            console.error('❌ Failed to save spreadsheet draft to DB:', error);
          }
        } else {
          // Fallback to localStorage for unauthenticated users
          const drafts = loadDrafts();
          const draftEntry = {
            id: savedExcel.id,
            title: savedExcel.title,
            type: 'sheet',
            createdAt: savedExcel.createdAt,
            updatedAt: savedExcel.updatedAt
          };
          drafts.push(draftEntry);
          saveDrafts(drafts);
        }

        // Mark drafts view for refresh
        window.draftsNeedRefresh = true;

        const excels = await window.LayerDB.loadExcels();
        saveExcels(excels);
        
        // Show success message
        if (typeof showToast === 'function') {
          showToast('Spreadsheet created and saved as draft', 'success');
        }
      } catch (error) {
        console.error('Failed to create excel in database:', error);
        showToast('Failed to save spreadsheet', 'error');
      }
    })();

    setTimeout(() => {
      const excelTitleInput = document.getElementById('excelTitleInput');
      excelTitleInput?.focus();
      
      // Generate title immediately if current title is "Untitled Spreadsheet" and there's data
      if (excelTitleInput && excelTitleInput.value.trim() === 'Untitled Spreadsheet' && data && data.length > 0) {
        const generatedTitle = generateTitleFromExcelData(data);
        if (generatedTitle !== 'Untitled Spreadsheet') {
          excelTitleInput.value = generatedTitle;
          console.log('📊 Generated spreadsheet title on open:', generatedTitle);
        }
      }
      
      // Add real-time title sync for Excel spreadsheets
      if (excelTitleInput) {
        excelTitleInput.addEventListener('input', function() {
          const newTitle = this.value.trim() || 'Untitled Spreadsheet';
          syncDraftCardTitle(currentExcelId, newTitle);
        });
      }
    }, 100);
  } else {
    // For existing spreadsheets, check if title is "Untitled Spreadsheet" and generate from data
    if (excel.title === 'Untitled Spreadsheet' && excel.data && excel.data.length > 0) {
      const generatedTitle = generateTitleFromExcelData(excel.data);
      if (generatedTitle !== 'Untitled Spreadsheet') {
        // Update the title input immediately
        setTimeout(() => {
          const titleInput = document.getElementById('excelTitleInput');
          if (titleInput) {
            titleInput.value = generatedTitle;
            console.log('📊 Updated existing spreadsheet title from data:', generatedTitle);
            
            // Save the updated title
            (async () => {
              try {
                await window.LayerDB.updateExcel(excel.id, { title: generatedTitle });
                const excels = await window.LayerDB.loadExcels();
                saveExcels(excels);
                
                // Update drafts
                const drafts = loadDrafts();
                const draftIndex = drafts.findIndex(d => d.id === excel.id);
                if (draftIndex !== -1) {
                  drafts[draftIndex].title = generatedTitle;
                  drafts[draftIndex].updatedAt = new Date().toISOString();
                  saveDrafts(drafts);
                }
                
                console.log('✅ Updated existing spreadsheet title in database');
              } catch (error) {
                console.error('Failed to update existing spreadsheet title:', error);
              }
            })();
          }
        }, 100);
      }
    }
  }
}

function createEmptyGrid(rows, cols) {
  const grid = [];
  for (let r = 0; r < rows; r++) {
    const row = [];
    for (let c = 0; c < cols; c++) {
      row.push('');
    }
    grid.push(row);
  }
  return grid;
}

function renderExcelGrid(data) {
  const cols = data[0]?.length || DEFAULT_COLS;
  let html = '';

  // Header row
  html += '<div class="excel-header-row">';
  html += '<div class="excel-header-cell"></div>';
  for (let c = 0; c < cols; c++) {
    html += `<div class="excel-header-cell">${COLUMN_LETTERS[c] || c + 1}</div>`;
  }
  html += '</div>';

  // Data rows
  data.forEach((row, rowIndex) => {
    html += `<div class="excel-row-header">${rowIndex + 1}</div>`;
    row.forEach((cell, colIndex) => {
      html += `<div class="excel-cell">
        <input type="text" value="${cell}" data-row="${rowIndex}" data-col="${colIndex}" 
               onchange="updateExcelCell(${rowIndex}, ${colIndex}, this.value)" />
      </div>`;
    });
  });

  return html;
}

let excelSaveTimeout = null;
function updateExcelCell(row, col, value) {
  // Generate title immediately if current title is "Untitled Spreadsheet"
  const titleInput = document.getElementById('excelTitleInput');
  if (titleInput && titleInput.value.trim() === 'Untitled Spreadsheet') {
    const data = getExcelData();
    const generatedTitle = generateTitleFromExcelData(data);
    if (generatedTitle !== 'Untitled Spreadsheet') {
      titleInput.value = generatedTitle;
      console.log('📊 Generated spreadsheet title from cell change:', generatedTitle);
    }
  }
  
  // Auto-save on cell change
  clearTimeout(excelSaveTimeout);
  excelSaveTimeout = setTimeout(() => {
    autoSaveExcel();
    showAutoSaveIndicator();
  }, 1000);
}

async function autoSaveExcel() {
  const titleInput = document.getElementById('excelTitleInput');
  if (!titleInput) return;

  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return; // Silently fail - user was warned on open
  }

  let title = titleInput.value.trim() || 'Untitled Spreadsheet';
  const data = getExcelData();

  // Generate title from data if current title is "Untitled Spreadsheet"
  if (title === 'Untitled Spreadsheet') {
    const generatedTitle = generateTitleFromExcelData(data);
    if (generatedTitle !== 'Untitled Spreadsheet') {
      title = generatedTitle;
      // Update the title input field
      titleInput.value = title;
      console.log('📊 Auto-generated spreadsheet title from data:', title);
    }
  }

  try {
    await window.LayerDB.updateExcel(currentExcelId, { title, data });
    const excels = await window.LayerDB.loadExcels();
    saveExcels(excels);

    // Sync draft title
    const drafts = loadDrafts();
    const draftIndex = drafts.findIndex(d => d.id === currentExcelId);
    if (draftIndex !== -1) {
      drafts[draftIndex].title = title;
      drafts[draftIndex].updatedAt = new Date().toISOString();
      saveDrafts(drafts);
      console.log('📊 Excel draft title synced:', title);
      // Mark drafts view for refresh so title shows updated
      window.draftsNeedRefresh = true;
      
      // Also sync the draft card title in real-time
      syncDraftCardTitle(currentExcelId, title);
    }
  } catch (error) {
    console.error('Failed to auto-save excel to database:', error);
  }
}

// Generate title from spreadsheet data
function generateTitleFromExcelData(data) {
  if (!data || !Array.isArray(data) || data.length === 0) {
    return 'Untitled Spreadsheet';
  }

  // Try to find a meaningful title from the first row or first column
  let title = '';

  // Look for non-empty cells in the first row (headers)
  const firstRow = data[0];
  if (firstRow && firstRow.length > 0) {
    // Find the first non-empty cell in first row
    for (let i = 0; i < firstRow.length; i++) {
      const cellValue = firstRow[i] ? firstRow[i].toString().trim() : '';
      if (cellValue && cellValue.length > 0 && cellValue.length <= 50) {
        title = cellValue;
        break;
      }
    }
  }

  // If no title found in first row, look at first column
  if (!title) {
    for (let i = 0; i < data.length; i++) {
      const cellValue = data[i][0] ? data[i][0].toString().trim() : '';
      if (cellValue && cellValue.length > 0 && cellValue.length <= 50) {
        title = cellValue;
        break;
      }
    }
  }

  // If still no title, look for any non-empty cell
  if (!title) {
    for (let r = 0; r < data.length; r++) {
      for (let c = 0; c < data[r].length; c++) {
        const cellValue = data[r][c] ? data[r][c].toString().trim() : '';
        if (cellValue && cellValue.length > 0 && cellValue.length <= 50) {
          title = cellValue;
          break;
        }
      }
      if (title) break;
    }
  }

  // Clean up the title
  if (title) {
    title = title.replace(/[""'']/g, '').trim();
    
    // Capitalize first letter if it's not already
    if (title.length > 0 && title[0] !== title[0].toUpperCase()) {
      title = title.charAt(0).toUpperCase() + title.slice(1);
    }
    
    // Add "Spreadsheet" suffix if it doesn't sound like a title
    if (!title.includes('Sheet') && !title.includes('Table') && !title.includes('Data')) {
      title += ' Spreadsheet';
    }
    
    // Limit length
    if (title.length > 60) {
      title = title.substring(0, 57) + '...';
    }
    
    return title;
  }

  return 'Untitled Spreadsheet';
}

function getExcelData() {
  const inputs = document.querySelectorAll('#excelGrid .excel-cell input');
  const data = [];
  let maxRow = 0;
  let maxCol = 0;

  inputs.forEach(input => {
    const row = parseInt(input.dataset.row);
    const col = parseInt(input.dataset.col);
    if (row > maxRow) maxRow = row;
    if (col > maxCol) maxCol = col;
  });

  for (let r = 0; r <= maxRow; r++) {
    data.push([]);
    for (let c = 0; c <= maxCol; c++) {
      data[r].push('');
    }
  }

  inputs.forEach(input => {
    const row = parseInt(input.dataset.row);
    const col = parseInt(input.dataset.col);
    data[row][col] = input.value;
  });

  return data;
}

function addExcelRow() {
  const data = getExcelData();
  const cols = data[0]?.length || DEFAULT_COLS;
  data.push(new Array(cols).fill(''));
  refreshExcelGrid(data);
}

function addExcelColumn() {
  const data = getExcelData();
  data.forEach(row => row.push(''));
  refreshExcelGrid(data);
}

function refreshExcelGrid(data) {
  const grid = document.getElementById('excelGrid');
  if (grid) {
    grid.style.gridTemplateColumns = `50px repeat(${data[0]?.length}, 120px)`;
    grid.innerHTML = renderExcelGrid(data);
  }
}

function closeExcelEditor() {
  const overlay = document.getElementById('excelEditorOverlay');
  if (overlay) {
    overlay.remove();
    document.body.style.overflow = '';
  }
  currentExcelId = null;
}

function saveCurrentExcel() {
  // Show inline save panel in the excel editor instead of modal
  showInExcelSavePanel();
}

function showInExcelSavePanel() {
  const spaces = loadSpaces();

  // Remove existing panel if any
  const existingPanel = document.getElementById('inExcelSavePanel');
  if (existingPanel) existingPanel.remove();

  if (spaces.length === 0) {
    showToast('Create a space first to organize your spreadsheets');
    return;
  }

  const panel = document.createElement('div');
  panel.id = 'inExcelSavePanel';
  panel.className = 'in-doc-save-panel';
  panel.innerHTML = `
    <div class="in-doc-save-header">
      <span>Save to Space</span>
      <button class="in-doc-save-close" onclick="closeInExcelSavePanel()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    <div class="in-doc-save-list">
      ${spaces.map(space => `
        <button class="in-doc-save-space-btn" onclick="confirmSaveExcelToSpace(${space.id}); closeInExcelSavePanel();">
          <div class="in-doc-save-space-icon">${getSpaceIconSVGById(space.icon)}</div>
          <span>${space.name}</span>
        </button>
      `).join('')}
    </div>
  `;

  const container = document.querySelector('.excel-editor-container');
  if (container) {
    container.appendChild(panel);
    setTimeout(() => panel.classList.add('show'), 10);
  }
}

function closeInExcelSavePanel() {
  const panel = document.getElementById('inExcelSavePanel');
  if (panel) {
    panel.classList.remove('show');
    setTimeout(() => panel.remove(), 200);
  }
}

async function confirmSaveExcelToSpace(spaceId) {
  const titleInput = document.getElementById('excelTitleInput');
  if (!titleInput) {
    closeModal();
    return;
  }

  const title = titleInput.value.trim() || 'Untitled Spreadsheet';
  const data = getExcelData();

  // Require authentication
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to save spreadsheets', 'error');
    return;
  }

  try {
    // Save to Supabase database
    await window.LayerDB.updateExcel(currentExcelId, { title, data, spaceId });
    
    // Load updated data and sync to localStorage
    const excels = await window.LayerDB.loadExcels();
    saveExcels(excels);
    
    // Update drafts
    const drafts = loadDrafts();
    const draftIndex = drafts.findIndex(d => d.id === currentExcelId);
    if (draftIndex !== -1) {
      drafts[draftIndex].title = title;
      drafts[draftIndex].updatedAt = new Date().toISOString();
      saveDrafts(drafts);
      window.draftsNeedRefresh = true;
    }
    
    closeModal();
    
    // Refresh favorites sidebar
    renderFavoritesInSidebar();

    const spaces = loadSpaces();
    const space = spaces.find(s => String(s.id) === String(spaceId));
    showToast('Spreadsheet saved to "' + (space ? space.name : 'Space') + '"!');
    
    console.log('✅ Spreadsheet saved to database:', { id: currentExcelId, title, spaceId });
  } catch (error) {
    console.error('Failed to save spreadsheet to database:', error);
    showToast('Failed to save spreadsheet', 'error');
  }
}

function exportExcelAsCSV() {
  const data = getExcelData();
  const titleInput = document.getElementById('excelTitleInput');
  const title = titleInput?.value?.trim() || 'spreadsheet';

  // Convert to CSV
  const csvContent = data.map(row =>
    row.map(cell => {
      // Escape quotes and wrap in quotes if needed
      const escaped = String(cell).replace(/"/g, '""');
      return escaped.includes(',') || escaped.includes('"') || escaped.includes('\n')
        ? `"${escaped}"`
        : escaped;
    }).join(',')
  ).join('\n');

  // Create and download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `${title}.csv`;
  link.click();
  URL.revokeObjectURL(link.href);

  showToast('Spreadsheet exported as CSV!');
}

// ============================================
// Assignments
// ============================================
function loadAssignments() {
  try {
    return JSON.parse(localStorage.getItem('layerAssignments')) || [];
  } catch {
    return [];
  }
}

function saveAssignments(assignments) {
  localStorage.setItem('layerAssignments', JSON.stringify(assignments));
}

// ============================================
// Spaces
// ============================================
function loadSpaces() {
  // Only return spaces if user is authenticated
  // Spaces should only exist in database, not localStorage for unauthenticated users
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return [];
  }

  try {
    return JSON.parse(localStorage.getItem(SPACES_KEY)) || [];
  } catch {
    return [];
  }
}

function saveSpaces(spaces) {
  localStorage.setItem(SPACES_KEY, JSON.stringify(spaces));
}

// Initialize spaces from DB on page load
async function initSpacesFromDB() {
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      const spaces = await window.LayerDB.loadSpaces();
      saveSpaces(spaces);
      // Render spaces in sidebar after loading
      if (typeof renderSpacesInSidebar === 'function') {
        renderSpacesInSidebar();
      }
      return spaces;
    } catch (error) {
      console.error('Failed to load spaces from database:', error);
    }
  } else {
    // Clear localStorage when not authenticated to prevent showing old spaces
    localStorage.removeItem(SPACES_KEY);
  }
  return [];
}

async function addSpace(space) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create spaces', 'error');
    return null;
  }

  try {
    const savedSpace = await window.LayerDB.saveSpace(space);
    const spaces = await window.LayerDB.loadSpaces();
    saveSpaces(spaces);
    return savedSpace;
  } catch (error) {
    console.error('Failed to save space to database:', error);
    showToast('Failed to save space', 'error');
    return null;
  }
}

async function updateSpace(id, updates) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to update spaces', 'error');
    return;
  }

  try {
    await window.LayerDB.updateSpace(id, updates);
    const spaces = await window.LayerDB.loadSpaces();
    saveSpaces(spaces);
  } catch (error) {
    console.error('Failed to update space in database:', error);
    showToast('Failed to update space', 'error');
  }
}

async function deleteSpace(id) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to delete spaces', 'error');
    return;
  }

  try {
    await window.LayerDB.deleteSpace(id);
    const spaces = await window.LayerDB.loadSpaces();
    saveSpaces(spaces);
  } catch (error) {
    console.error('Failed to delete space from database:', error);
    showToast('Failed to delete space', 'error');
  }
}

// Minimalistic SVG icons for spaces (instead of emojis)
const SPACE_ICON_SVGS = [
  { id: 'folder', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>' },
  { id: 'home', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>' },
  { id: 'briefcase', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="14" rx="2" ry="2"/><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"/></svg>' },
  { id: 'target', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>' },
  { id: 'rocket', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z"/><path d="m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z"/><path d="M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0"/><path d="M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5"/></svg>' },
  { id: 'lightbulb', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></svg>' },
  { id: 'bar-chart', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="20" x2="12" y2="10"/><line x1="18" y1="20" x2="18" y2="4"/><line x1="6" y1="20" x2="6" y2="16"/></svg>' },
  { id: 'palette', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="13.5" cy="6.5" r="0.5" fill="currentColor"/><circle cx="17.5" cy="10.5" r="0.5" fill="currentColor"/><circle cx="8.5" cy="7.5" r="0.5" fill="currentColor"/><circle cx="6.5" cy="12.5" r="0.5" fill="currentColor"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.555C21.965 6.012 17.461 2 12 2z"/></svg>' },
  { id: 'edit', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>' },
  { id: 'star', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>' },
  { id: 'zap', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>' },
  { id: 'layers', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>' },
  { id: 'users', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>' },
  { id: 'code', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>' },
  { id: 'globe', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>' },
  { id: 'book', svg: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>' }
];

function openNewSpaceModal() {
  // Require authentication to create spaces
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create spaces', 'error');
    return;
  }

  // Close any open dropdowns
  closeSidebarCreateDropdown();

  const projects = loadProjects();

  const content = `
    <form id="newSpaceForm" onsubmit="handleCreateSpace(event)" class="new-space-form">
      <div class="form-group">
        <label class="form-label">Space Name <span class="required">*</span></label>
        <input type="text" name="name" class="form-input" required placeholder="e.g. Marketing, Development..." />
      </div>
      
      <div class="form-group">
        <label class="form-label">Choose an Icon</label>
        <div class="space-icon-grid-svg" id="spaceIconGrid">
          ${SPACE_ICON_SVGS.map((icon, index) => `
            <button type="button" class="space-icon-svg-option ${index === 0 ? 'selected' : ''}" 
                    data-icon="${icon.id}" onclick="selectSpaceIcon(this)">
              ${icon.svg}
            </button>
          `).join('')}
        </div>
        <input type="hidden" name="icon" id="selectedSpaceIcon" value="${SPACE_ICON_SVGS[0].id}" />
      </div>
      
      <div class="form-group">
        <label class="form-label">Description <span style="color: var(--muted-foreground); font-weight: normal;">(optional)</span></label>
        <textarea name="description" class="form-textarea" placeholder="What is this space for?" rows="2"></textarea>
      </div>
      
      <div class="optional-fields-toggle" onclick="toggleOptionalFields()">
        <svg class="icon optional-toggle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 5v14M5 12h14"/>
        </svg>
        <span>Add more details</span>
      </div>
      
      <div class="optional-fields" id="optionalFields" style="display: none;">
        <div class="form-group">
          <label class="form-label">Due Date <span style="color: var(--muted-foreground); font-weight: normal;">(optional)</span></label>
          <input type="date" name="dueDate" class="form-input" />
        </div>
        
        <div class="form-group">
          <label class="form-label">Link with Project <span style="color: var(--muted-foreground); font-weight: normal;">(optional)</span></label>
          <select name="linkedProject" class="form-select">
            <option value="">No linked project</option>
            ${projects.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
          </select>
        </div>
        
        <div class="form-group">
          <label class="form-label">Invite Team Members <span style="color: var(--muted-foreground); font-weight: normal;">(optional)</span></label>
          <div class="team-invite-input-container">
            <input type="email" id="teamMemberEmail" class="form-input" placeholder="Enter email address" />
            <button type="button" class="btn btn-secondary btn-sm" onclick="addTeamMemberToSpace()">Add</button>
          </div>
          <div id="invitedMembersList" class="invited-members-list"></div>
        </div>
        
        <div class="form-group">
          <label class="form-label">Color Tag <span style="color: var(--muted-foreground); font-weight: normal;">(optional)</span></label>
          <div class="color-tag-options">
            <button type="button" class="color-tag-option selected" data-color="none" onclick="selectColorTag(this)" style="background: var(--surface); border: 2px dashed var(--border);">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;opacity:0.5;"><path d="M18 6L6 18M6 6l12 12"/></svg>
            </button>
            <button type="button" class="color-tag-option" data-color="blue" onclick="selectColorTag(this)" style="background: hsl(217, 91%, 60%);"></button>
            <button type="button" class="color-tag-option" data-color="green" onclick="selectColorTag(this)" style="background: hsl(142, 71%, 45%);"></button>
            <button type="button" class="color-tag-option" data-color="purple" onclick="selectColorTag(this)" style="background: hsl(271, 91%, 65%);"></button>
            <button type="button" class="color-tag-option" data-color="orange" onclick="selectColorTag(this)" style="background: hsl(24, 90%, 60%);"></button>
            <button type="button" class="color-tag-option" data-color="red" onclick="selectColorTag(this)" style="background: hsl(0, 84%, 60%);"></button>
          </div>
          <input type="hidden" name="colorTag" id="selectedColorTag" value="none" />
        </div>
      </div>
      
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-themed-primary">Create Space</button>
      </div>
    </form>
  `;

  openModal('Create New Space', content);
}

// Store invited team members temporarily
let pendingInvitedMembers = [];

function addTeamMemberToSpace() {
  const emailInput = document.getElementById('teamMemberEmail');
  const email = emailInput.value.trim();

  if (!email || !email.includes('@')) {
    emailInput.style.borderColor = 'hsl(0, 84%, 60%)';
    setTimeout(() => emailInput.style.borderColor = '', 2000);
    return;
  }

  if (pendingInvitedMembers.includes(email)) return;

  pendingInvitedMembers.push(email);
  emailInput.value = '';
  renderInvitedMembers();
}

function removeInvitedMember(email) {
  pendingInvitedMembers = pendingInvitedMembers.filter(e => e !== email);
  renderInvitedMembers();
}

function renderInvitedMembers() {
  const container = document.getElementById('invitedMembersList');
  if (!container) return;

  container.innerHTML = pendingInvitedMembers.map(email => `
    <div class="invited-member-chip">
      <span>${email}</span>
      <button type="button" onclick="removeInvitedMember('${email}')" class="remove-member-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;"><path d="M18 6L6 18M6 6l12 12"/></svg>
      </button>
    </div>
  `).join('');
}

function toggleOptionalFields() {
  const container = document.getElementById('optionalFields');
  const toggle = document.querySelector('.optional-fields-toggle');

  if (container.style.display === 'none') {
    container.style.display = 'block';
    toggle.classList.add('expanded');
  } else {
    container.style.display = 'none';
    toggle.classList.remove('expanded');
  }
}

function selectColorTag(button) {
  document.querySelectorAll('.color-tag-option').forEach(btn => btn.classList.remove('selected'));
  button.classList.add('selected');
  document.getElementById('selectedColorTag').value = button.dataset.color;
}

function selectSpaceIcon(button) {
  document.querySelectorAll('.space-icon-svg-option').forEach(btn => btn.classList.remove('selected'));
  button.classList.add('selected');
  document.getElementById('selectedSpaceIcon').value = button.dataset.icon;
}

async function handleCreateSpace(event) {
  event.preventDefault();

  // Require authentication (already checked in openNewSpaceModal, but double-check)
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to create spaces', 'error');
    closeModal();
    return;
  }

  const form = event.target;
  const name = form.name.value.trim();
  const icon = document.getElementById('selectedSpaceIcon').value;
  const description = form.description?.value?.trim() || '';
  const dueDate = form.dueDate?.value || null;
  const linkedProject = form.linkedProject?.value || null;
  const colorTag = document.getElementById('selectedColorTag')?.value || 'none';

  if (!name) return;

  const newSpace = {
    id: Date.now(),
    name,
    icon,
    description,
    dueDate,
    linkedProject,
    colorTag,
    members: [...pendingInvitedMembers],
    createdAt: new Date().toISOString()
  };

  // Reset pending members
  pendingInvitedMembers = [];

  try {
    await window.LayerDB.saveSpace(newSpace);
    const spaces = await window.LayerDB.loadSpaces();
    saveSpaces(spaces);
    closeModal();
    renderSpacesInSidebar();
    showToast(`Space "${name}" created!`);
  } catch (error) {
    console.error('Failed to save space to database:', error);
    showToast('Failed to create space', 'error');
    closeModal();
  }
}

function renderSpacesInSidebar() {
  const spaces = loadSpaces();
  const workspaceSection = document.querySelector('.workspace-section');

  if (!workspaceSection) return;

  // Remove existing spaces from workspace section
  const existingSpaces = workspaceSection.querySelectorAll('.workspace-space-item');
  existingSpaces.forEach(space => space.remove());

  if (spaces.length === 0) return;

  // Helper function to get SVG icon by id
  function getSpaceIconSVG(iconId) {
    const iconData = SPACE_ICON_SVGS.find(i => i.id === iconId);
    if (iconData) return iconData.svg;
    // Fallback for old emoji-based icons
    return `<span style="font-size:16px;">${iconId}</span>`;
  }

  // Create space items and append to workspace section (after Projects button)
  const projectsButton = workspaceSection.querySelector('[data-view="activity"]');

  spaces.forEach(space => {
    const spaceItem = document.createElement('div');
    spaceItem.className = 'workspace-space-item';
    spaceItem.innerHTML = `
      <div class="custom-space-item-wrapper workspace-nested" ${space.colorTag && space.colorTag !== 'none' ? `style="--space-accent: var(--event-${space.colorTag});"` : ''}>
        <button class="custom-space-item workspace-space ${space.colorTag && space.colorTag !== 'none' ? 'has-color' : ''}" data-space-id="${space.id}" onclick="openSpaceView('${space.id}')">
          <span class="space-icon-svg">${getSpaceIconSVG(space.icon)}</span>
          <span class="space-name-text">${space.name}</span>
        </button>
        <button class="delete-item-btn" onclick="confirmDeleteSpace('${space.id}', '${space.name.replace(/'/g, "\\'")}')" title="Delete space">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6"/>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          </svg>
        </button>
      </div>
    `;

    // Insert after the Projects button
    if (projectsButton) {
      projectsButton.parentNode.insertBefore(spaceItem, projectsButton.nextSibling);
    } else {
      workspaceSection.appendChild(spaceItem);
    }
  });

  // Also render favorites section
  renderFavoritesInSidebar();
}

// ============================================
// Favorites System for Documents
// ============================================
const FAVORITES_KEY = 'layerFavorites';
const EXCEL_FAVORITES_KEY = 'layerExcelFavorites';

function loadFavorites() {
  try {
    return JSON.parse(localStorage.getItem(FAVORITES_KEY)) || [];
  } catch {
    return [];
  }
}

function saveFavorites(favorites) {
  localStorage.setItem(FAVORITES_KEY, JSON.stringify(favorites));
}

function loadExcelFavorites() {
  try {
    return JSON.parse(localStorage.getItem(EXCEL_FAVORITES_KEY)) || [];
  } catch {
    return [];
  }
}

function saveExcelFavorites(favorites) {
  localStorage.setItem(EXCEL_FAVORITES_KEY, JSON.stringify(favorites));
}

async function toggleDocFavorite(docId) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to save favorites', 'error');
    return;
  }

  const docs = loadDocs();
  const doc = docs.find(d => String(d.id) === String(docId));
  if (!doc) return;

  const newFavoriteState = !doc.isFavorite;

  // Optimistic UI update - update immediately for instant feedback
  const starBtn = document.querySelector(`[data-favorite-doc="${docId}"]`);
  if (starBtn) {
    starBtn.classList.toggle('is-favorite', newFavoriteState);
  }

  // Update local state immediately
  doc.isFavorite = newFavoriteState;
  saveDocs(docs);
  renderFavoritesInSidebar();

  try {
    // Sync to database in background
    const updatedDocs = await window.LayerDB.toggleDocFavorite(docId, newFavoriteState);
    saveDocs(updatedDocs);
    // Re-render favorites in case order changed
    renderFavoritesInSidebar();

    // Update star icon again in case it was re-rendered
    const updatedStarBtn = document.querySelector(`[data-favorite-doc="${docId}"]`);
    if (updatedStarBtn) {
      updatedStarBtn.classList.toggle('is-favorite', newFavoriteState);
    }
  } catch (error) {
    console.error('Failed to toggle doc favorite in database:', error);
    // Revert optimistic update on error
    doc.isFavorite = !newFavoriteState;
    saveDocs(docs);
    renderFavoritesInSidebar();
    if (starBtn) {
      starBtn.classList.toggle('is-favorite', !newFavoriteState);
    }
    showToast('Failed to save favorite', 'error');
  }
}

async function toggleExcelFavorite(excelId) {
  // Require authentication - no localStorage fallback
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to save favorites', 'error');
    return;
  }

  const excels = loadExcels();
  const excel = excels.find(e => String(e.id) === String(excelId));
  if (!excel) return;

  const newFavoriteState = !excel.isFavorite;

  // Optimistic UI update - update immediately for instant feedback
  const starBtn = document.querySelector(`[data-favorite-excel="${excelId}"]`);
  if (starBtn) {
    starBtn.classList.toggle('is-favorite', newFavoriteState);
  }

  // Update local state immediately
  excel.isFavorite = newFavoriteState;
  saveExcels(excels);
  renderFavoritesInSidebar();

  try {
    // Sync to database in background
    const updatedExcels = await window.LayerDB.toggleExcelFavorite(excelId, newFavoriteState);
    saveExcels(updatedExcels);
    // Re-render favorites in case order changed
    renderFavoritesInSidebar();

    // Update star icon again in case it was re-rendered
    const updatedStarBtn = document.querySelector(`[data-favorite-excel="${excelId}"]`);
    if (updatedStarBtn) {
      updatedStarBtn.classList.toggle('is-favorite', newFavoriteState);
    }
  } catch (error) {
    console.error('Failed to toggle excel favorite in database:', error);
    // Revert optimistic update on error
    excel.isFavorite = !newFavoriteState;
    saveExcels(excels);
    renderFavoritesInSidebar();
    if (starBtn) {
      starBtn.classList.toggle('is-favorite', !newFavoriteState);
    }
    showToast('Failed to save favorite', 'error');
  }
}

function isDocFavorited(docId) {
  const docs = loadDocs();
  const doc = docs.find(d => String(d.id) === String(docId));
  return doc ? doc.isFavorite === true : false;
}

function isExcelFavorited(excelId) {
  const excels = loadExcels();
  const excel = excels.find(e => String(e.id) === String(excelId));
  return excel ? excel.isFavorite === true : false;
}

function renderFavoritesInSidebar() {
  // Only show favorites if user is authenticated
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    // Remove existing favorites section if user is not authenticated
    const existingSection = document.getElementById('favoritesSection');
    if (existingSection) {
      existingSection.remove();
    }
    return;
  }

  const docs = loadDocs();
  const excels = loadExcels();
  const sidebar = document.querySelector('.sidebar-nav');

  // Remove existing favorites section
  const existingSection = document.getElementById('favoritesSection');
  if (existingSection) {
    existingSection.remove();
  }

  // Get favorited docs and excels using isFavorite field
  const favoriteDocs = docs.filter(doc => doc.isFavorite === true);
  const favoriteExcels = excels.filter(excel => excel.isFavorite === true);

  if (favoriteDocs.length === 0 && favoriteExcels.length === 0) return;

  // Helper to truncate title
  function truncateTitle(title, maxLen = 12) {
    if (title.length <= maxLen) return title;
    return title.substring(0, maxLen) + '...';
  }

  // Create favorites section
  const favoritesSection = document.createElement('div');
  favoritesSection.id = 'favoritesSection';

  const totalFavorites = favoriteDocs.length + favoriteExcels.length;
  const needsScroll = totalFavorites > 3;

  favoritesSection.innerHTML = `
    <div class="spaces-divider"></div>
    <div class="spaces-section-label">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;margin-right:4px;vertical-align:-1px;">
        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
      </svg>
      Favorites ${totalFavorites > 3 ? `(${totalFavorites})` : ''}
    </div>
    <div class="${needsScroll ? 'favorites-scroll-container' : ''}">
      ${favoriteDocs.map(doc => `
        <div class="custom-space-item-wrapper favorite-doc-item">
          <button class="custom-space-item" onclick="openDocEditor('${doc.id}')">
            <div class="favorite-item-layout">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="favorite-type-icon doc-icon">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
              </svg>
              <span class="favorite-text-truncate" title="${doc.title}">${truncateTitle(doc.title)}</span>
              <svg viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1" class="favorite-star-right">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
              </svg>
            </div>
          </button>
        </div>
      `).join('')}
      ${favoriteExcels.map(excel => `
        <div class="custom-space-item-wrapper favorite-excel-item">
          <button class="custom-space-item" onclick="openExcelEditor('${excel.id}')">
            <div class="favorite-item-layout">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="favorite-type-icon excel-icon">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <line x1="3" y1="9" x2="21" y2="9"/>
                <line x1="9" y1="3" x2="9" y2="21"/>
              </svg>
              <span class="favorite-text-truncate" title="${excel.title}">${truncateTitle(excel.title)}</span>
              <svg viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1" class="favorite-star-right">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
              </svg>
            </div>
          </button>
        </div>
      `).join('')}
    </div>
  `;

  sidebar.appendChild(favoritesSection);
}

function confirmDeleteSpace(spaceId, spaceName) {
  const content = `
    <div style="text-align: center;">
      <div style="width: 64px; height: 64px; margin: 0 auto 16px; background: var(--surface); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 32px; height: 32px; color: var(--destructive);">
          <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          <line x1="10" y1="11" x2="10" y2="17"/>
          <line x1="14" y1="11" x2="14" y2="17"/>
        </svg>
      </div>
      <p style="color: var(--muted-foreground); margin-bottom: 24px;">
        Are you sure you want to delete the space "<strong>${spaceName}</strong>"? This action cannot be undone.
      </p>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="button" class="btn btn-danger" onclick="deleteSpaceConfirmed('${spaceId}')">Delete Space</button>
      </div>
    </div>
  `;
  openModal('Delete Space', content);
}

async function deleteSpaceConfirmed(spaceId) {
  await deleteSpace(spaceId);
  closeModal();

  // Remove old spacesSection if it still exists
  const oldSpacesSection = document.getElementById('spacesSection');
  if (oldSpacesSection) {
    oldSpacesSection.remove();
  }

  renderSpacesInSidebar();
  showToast('Space deleted successfully!');

  // Navigate to home if viewing deleted space
  const activeSpace = document.querySelector(`[data-space-id="${spaceId}"]`);
  if (activeSpace && activeSpace.classList.contains('active')) {
    document.querySelector('.nav-item')?.click();
  }
}

function openSpaceView(spaceId) {
  const spaces = loadSpaces();
  // Handle both string UUIDs and numeric IDs
  const space = spaces.find(s => String(s.id) === String(spaceId));

  if (!space) return;

  // Set current space for doc/excel saving
  currentSpaceId = spaceId;

  // Update active nav - clear all main nav items and set space as active
  document.querySelectorAll('.nav-item').forEach(item => {
    item.classList.remove('active');
  });

  document.querySelectorAll('.custom-space-item').forEach(item => {
    item.classList.remove('active');
  });

  const spaceBtn = document.querySelector(`[data-space-id="${spaceId}"]`);
  if (spaceBtn) spaceBtn.classList.add('active');

  // Render space view
  const viewsContainer = document.getElementById('viewsContainer');
  if (viewsContainer) {
    viewsContainer.innerHTML = renderSpaceDetailView(space);
  }

  updateBreadcrumb(space.name);
}

function renderSpaceDetailView(space) {
  const allDocs = loadDocs();
  const allExcels = loadExcels();
  const excelFavorites = loadExcelFavorites();

  // Filter docs and excels by space - use string comparison for UUID/number compatibility
  const docs = allDocs.filter(d => String(d.spaceId) === String(space.id));
  const excels = allExcels.filter(e => String(e.spaceId) === String(space.id));

  // Recent items (last 5 docs + excels combined)
  const allItems = [
    ...docs.map(d => ({ ...d, type: 'doc', updatedAt: d.updatedAt })),
    ...excels.map(e => ({ ...e, type: 'excel', updatedAt: e.updatedAt }))
  ];
  const recentItems = [...allItems]
    .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt))
    .slice(0, 5);

  // Bookmarked items
  const bookmarkedItems = allItems.filter(item =>
    (item.type === 'doc' && item.isFavorite) ||
    (item.type === 'excel' && isExcelFavorited(item.id))
  ).slice(0, 3);

  // Initialize checklist after render
  setTimeout(() => renderChecklistSidebar(space.id), 100);

  return `
    <div class="space-overview-container">
      <!-- Top Navigation Bar -->
      <div class="space-top-bar">
        <div class="space-top-left">
          <div class="space-breadcrumb">
            <span class="breadcrumb-item">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-right:6px;">
                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
              </svg>
              ${space.name}
            </span>
          </div>
        </div>
        
        <div class="space-top-center">
          <div class="space-view-tabs">
            <button class="view-tab active">Overview</button>
            <button class="view-tab">List</button>
            <button class="view-tab">Board</button>
            <button class="view-tab">Calendar</button>
            <button class="view-tab">Gantt</button>
            <button class="view-tab">Table</button>
            <button class="view-tab add-view">+</button>
          </div>
        </div>
        
        <div class="space-top-right">
          <button class="space-action-btn" onclick="openSpaceAgents('${space.id}')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <path d="M12 11v6"/><path d="M9 14l6-3"/>
            </svg>
            Agents
          </button>
          <button class="space-action-btn" onclick="openSpaceAutomation('${space.id}')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <polyline points="4,14 10,14 10,20"/><polyline points="20,10 14,10 14,4"/><line x1="14" y1="10" x2="21" y2="3"/><line x1="3" y1="21" x2="10" y2="14"/>
            </svg>
            Automate
          </button>
          <button class="space-action-btn" onclick="openSpaceAsk('${space.id}')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
            </svg>
            Ask
          </button>
          <button class="space-action-btn" onclick="openSpaceShare('${space.id}')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
            </svg>
            Share
          </button>
        </div>
      </div>
      
      <!-- Notification Banner -->
      <div class="notification-banner">
        <div class="banner-content">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/>
          </svg>
          <span>Layer needs your permission to send notifications</span>
        </div>
        <div class="banner-actions">
          <button class="banner-btn secondary">Remind me</button>
          <button class="banner-btn primary">Enable</button>
        </div>
      </div>
      
      <!-- Main Content Area -->
      <div class="space-main-content">
        <!-- Top Cards Row -->
        <div class="space-cards-row">
          <!-- Recent Card -->
          <div class="space-card">
            <div class="card-header">
              <h3 class="card-title">Recent</h3>
            </div>
            <div class="card-content">
              ${recentItems.length > 0 ? recentItems.map(item => `
                <div class="card-item" data-item-id="${item.id}" data-item-type="${item.type}" onclick="${item.type === 'doc' ? `openDocEditor('${item.id}')` : `openExcelEditor('${item.id}')`}">
                  <div class="item-icon">
                    ${item.type === 'doc' ? `
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                      </svg>
                    ` : `
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <line x1="3" y1="9" x2="21" y2="9"/>
                        <line x1="9" y1="3" x2="9" y2="21"/>
                      </svg>
                    `}
                  </div>
                  <div class="item-info">
                    <div class="item-title">${item.title}</div>
                    <div class="item-meta">in ${space.name}</div>
                  </div>
                  <button class="card-item-delete" onclick="event.stopPropagation(); deleteCardItem('${item.id}', '${item.type}', '${space.id}')" title="Delete ${item.type}">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                  </button>
                </div>
              `).join('') : `
                <div class="empty-state-small">
                  <div class="empty-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                      <polyline points="14 2 14 8 20 8"/>
                    </svg>
                  </div>
                  <div class="empty-text">No recent items</div>
                </div>
              `}
            </div>
          </div>
          
          <!-- Docs Card -->
          <div class="space-card docs-card-hover">
            <div class="card-header">
              <h3 class="card-title">Docs</h3>
              <button class="card-add-doc-btn" onclick="openDocEditor()" title="Create new Doc">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                  <path d="M12 5v14M5 12h14"/>
                </svg>
              </button>
            </div>
            <div class="card-content">
              ${docs.length > 0 ? docs.slice(0, 3).map(doc => `
                <div class="card-item" data-item-id="${doc.id}" data-item-type="doc" onclick="openDocEditor('${doc.id}')">
                  <div class="item-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                      <polyline points="14 2 14 8 20 8"/>
                    </svg>
                  </div>
                  <div class="item-info">
                    <div class="item-title">${doc.title}</div>
                    <div class="item-meta">in ${space.name}</div>
                  </div>
                  <button class="card-item-delete" onclick="event.stopPropagation(); deleteCardItem('${doc.id}', 'doc', '${space.id}')" title="Delete document">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                  </button>
                </div>
              `).join('') : `
                <div class="empty-state-small">
                  <div class="empty-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                      <polyline points="14 2 14 8 20 8"/>
                    </svg>
                  </div>
                  <div class="empty-text">No documents</div>
                </div>
              `}
            </div>
          </div>
          
          <!-- Bookmarks Card -->
          <div class="space-card">
            <div class="card-header">
              <h3 class="card-title">Bookmarks</h3>
            </div>
            <div class="card-content">
              ${bookmarkedItems.length > 0 ? bookmarkedItems.map(item => `
                <div class="card-item bookmark-item" data-item-id="${item.id}" data-item-type="${item.type}" onclick="${item.type === 'doc' ? `openDocEditor('${item.id}')` : `openExcelEditor('${item.id}')`}">
                  <div class="item-icon bookmark-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                    </svg>
                  </div>
                  <div class="item-info">
                    <div class="item-title">${item.title}</div>
                    <div class="item-meta">in ${space.name}</div>
                  </div>
                  <button class="card-item-delete" onclick="event.stopPropagation(); deleteCardItem('${item.id}', '${item.type}', '${space.id}')" title="Remove bookmark">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M19 7l-.867 12.142A2 2 0 0 1 16.138 21H7.862a2 2 0 0 1-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v3M4 7h16"/>
                    </svg>
                  </button>
                </div>
              `).join('') : `
                <div class="bookmarks-empty">
                  <div class="bookmark-large-icon">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                    </svg>
                  </div>
                  <div class="bookmarks-text">
                    Bookmarks make it easy to save Layer items or any URL from around the web.
                  </div>
                  <button class="add-bookmark-btn" onclick="openBookmarkManager('${space.id}')">
                    Manage Bookmarks
                  </button>
                </div>
              `}
            </div>
          </div>
        </div>
        
        <!-- Folders Section -->
        <div class="space-section">
          <div class="section-header">
            <h2 class="section-title">Folders</h2>
          </div>
          <div class="folders-placeholder">
            <div class="folder-icon-large">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
              </svg>
            </div>
            <div class="folders-text">Add new Folder to your Space</div>
            <button class="add-folder-btn" onclick="openFolderDropdown(this)">
              Add Folder
            </button>
          </div>
        </div>
        
        <!-- Lists Section -->
        <div class="space-section">
          <div class="section-header">
            <h2 class="section-title">Lists</h2>
          </div>
          <div class="lists-table">
            <div class="table-header">
              <div class="table-cell">Name</div>
              <div class="table-cell">Color</div>
              <div class="table-cell">Progress</div>
              <div class="table-cell">Start</div>
              <div class="table-cell">End</div>
              <div class="table-cell">Priority</div>
              <div class="table-cell">Owner</div>
              <div class="table-cell add-column">
                <button class="add-list-btn" onclick="showToast('Add list feature coming soon!', 'info')">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 8v8M8 12h8"/>
                  </svg>
                </button>
              </div>
            </div>
            <div class="table-placeholder">
              <div class="placeholder-text">No lists created yet</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
}

// ============================================
// Advanced Space Action Functions
// ============================================

// Space Agents - AI-powered automation and assistance
function openSpaceAgents(spaceId) {
  const space = getSpaceById(spaceId);
  if (!space) return;

  const content = `
    <div class="space-agents-container">
      <div class="agents-header">
        <h3>AI Agents for ${space.name}</h3>
        <p>Automate workflows and get intelligent assistance</p>
      </div>
      
      <div class="agents-grid">
        <div class="agent-card" onclick="configureAgent('${spaceId}', 'document-assistant')">
          <div class="agent-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
              <polyline points="14 2 14 8 20 8"/>
              <line x1="16" y1="13" x2="8" y2="13"/>
              <line x1="16" y1="17" x2="8" y2="17"/>
            </svg>
          </div>
          <h4>Document Assistant</h4>
          <p>Help with writing, editing, and organizing documents</p>
          <div class="agent-status active">Active</div>
        </div>
        
        <div class="agent-card" onclick="configureAgent('${spaceId}', 'task-manager')">
          <div class="agent-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="18" height="18" rx="2"/>
              <line x1="3" y1="9" x2="21" y2="9"/>
              <line x1="9" y1="3" x2="9" y2="21"/>
            </svg>
          </div>
          <h4>Task Manager</h4>
          <p>Automatically organize and prioritize tasks</p>
          <div class="agent-status inactive">Inactive</div>
        </div>
        
        <div class="agent-card" onclick="configureAgent('${spaceId}', 'meeting-assistant')">
          <div class="agent-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/>
              <polyline points="12 6 12 12 16 14"/>
            </svg>
          </div>
          <h4>Meeting Assistant</h4>
          <p>Schedule meetings and send reminders</p>
          <div class="agent-status inactive">Inactive</div>
        </div>
        
        <div class="agent-card" onclick="configureAgent('${spaceId}', 'analytics-bot')">
          <div class="agent-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 20V10M18 20V4M6 20v-6"/>
            </svg>
          </div>
          <h4>Analytics Bot</h4>
          <p>Generate reports and insights from your data</p>
          <div class="agent-status inactive">Inactive</div>
        </div>
      </div>
      
      <div class="agents-actions">
        <button class="btn btn-primary" onclick="createCustomAgent('${spaceId}')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/><path d="M12 8v8M8 12h8"/>
          </svg>
          Create Custom Agent
        </button>
      </div>
    </div>
  `;

  openModal('Space Agents', content, 'large');
}

// Space Automation - Workflow automation
function openSpaceAutomation(spaceId) {
  const space = getSpaceById(spaceId);
  if (!space) return;

  const automations = getSpaceAutomations(spaceId);

  const content = `
    <div class="space-automation-container">
      <div class="automation-header">
        <h3>Automation for ${space.name}</h3>
        <p>Streamline repetitive tasks and workflows</p>
      </div>
      
      <div class="automation-toolbar">
        <button class="btn btn-primary" onclick="createNewAutomation('${spaceId}')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/><path d="M12 8v8M8 12h8"/>
          </svg>
          New Automation
        </button>
        <div class="automation-filters">
          <select onchange="filterAutomations(this.value)">
            <option value="all">All Automations</option>
            <option value="active">Active</option>
            <option value="paused">Paused</option>
            <option value="draft">Draft</option>
          </select>
        </div>
      </div>
      
      <div class="automation-list">
        ${automations.length > 0 ? automations.map(auto => `
          <div class="automation-item ${auto.status}" onclick="editAutomation('${auto.id}')">
            <div class="automation-info">
              <h4>${auto.name}</h4>
              <p>${auto.description}</p>
              <div class="automation-meta">
                <span class="automation-trigger">${auto.trigger}</span>
                <span class="automation-actions">${auto.actions.length} actions</span>
                <span class="automation-runs">${auto.runCount || 0} runs</span>
              </div>
            </div>
            <div class="automation-status">
              <div class="status-indicator ${auto.status}"></div>
              <span>${auto.status}</span>
            </div>
          </div>
        `).join('') : `
          <div class="empty-state">
            <div class="empty-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="4,14 10,14 10,20"/><polyline points="20,10 14,10 14,4"/><line x1="14" y1="10" x2="21" y2="3"/><line x1="3" y1="21" x2="10" y2="14"/>
              </svg>
            </div>
            <h3>No automations yet</h3>
            <p>Create your first automation to streamline workflows</p>
            <button class="btn btn-primary" onclick="createNewAutomation('${spaceId}')">Create Automation</button>
          </div>
        `}
      </div>
    </div>
  `;

  openModal('Space Automation', content, 'large');
}

// Space Ask - AI-powered Q&A
function openSpaceAsk(spaceId) {
  const space = getSpaceById(spaceId);
  if (!space) return;

  const content = `
    <div class="space-ask-container">
      <div class="ask-header">
        <h3>Ask about ${space.name}</h3>
        <p>Get instant answers about your space, documents, and tasks</p>
      </div>
      
      <div class="ask-interface">
        <div class="ask-history" id="askHistory">
          <!-- Chat history will be populated here -->
        </div>
        
        <div class="ask-input-area">
          <div class="ask-input-container">
            <textarea 
              id="askInput" 
              placeholder="Ask anything about this space..." 
              onkeypress="if(event.key==='Enter' && !event.shiftKey){event.preventDefault(); sendAskQuestion('${spaceId}');}"
            ></textarea>
            <button class="ask-send-btn" onclick="sendAskQuestion('${spaceId}')">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/>
              </svg>
            </button>
          </div>
          <div class="ask-suggestions">
            <button class="suggestion-chip" onclick="setAskQuestion('What documents are in this space?')">What documents are in this space?</button>
            <button class="suggestion-chip" onclick="setAskQuestion('Show me upcoming deadlines')">Show me upcoming deadlines</button>
            <button class="suggestion-chip" onclick="setAskQuestion('Who are the team members?')">Who are the team members?</button>
          </div>
        </div>
      </div>
    </div>
  `;

  openModal('Ask AI', content, 'medium');

  // Load chat history
  loadAskHistory(spaceId);
}

// Space Share - Collaboration and sharing
function openSpaceShare(spaceId) {
  const space = getSpaceById(spaceId);
  if (!space) return;

  const members = getSpaceMembers(spaceId);
  const invites = getSpaceInvites(spaceId);

  const content = `
    <div class="space-share-container">
      <div class="share-header">
        <h3>Share ${space.name}</h3>
        <p>Invite team members and manage permissions</p>
      </div>
      
      <div class="share-tabs">
        <button class="share-tab active" onclick="switchShareTab('members')">Members</button>
        <button class="share-tab" onclick="switchShareTab('invites')">Pending Invites</button>
        <button class="share-tab" onclick="switchShareTab('settings')">Settings</button>
      </div>
      
      <div class="share-content">
        <div class="share-tab-content active" id="members-tab">
          <div class="invite-section">
            <h4>Invite Members</h4>
            <div class="invite-form">
              <input type="email" id="inviteEmail" placeholder="Enter email address" />
              <select id="inviteRole">
                <option value="member">Member</option>
                <option value="admin">Admin</option>
                <option value="viewer">Viewer</option>
              </select>
              <button class="btn btn-primary" onclick="sendSpaceInvite('${spaceId}')">Send Invite</button>
            </div>
          </div>
          
          <div class="members-list">
            <h4>Current Members (${members.length})</h4>
            ${members.map(member => `
              <div class="member-item">
                <div class="member-info">
                  <div class="member-avatar">
                    ${member.avatar ? `<img src="${member.avatar}" alt="${member.name}">` : member.name.charAt(0)}
                  </div>
                  <div class="member-details">
                    <div class="member-name">${member.name}</div>
                    <div class="member-email">${member.email}</div>
                  </div>
                </div>
                <div class="member-role">
                  <select onchange="updateMemberRole('${spaceId}', '${member.id}', this.value)" value="${member.role}">
                    <option value="member" ${member.role === 'member' ? 'selected' : ''}>Member</option>
                    <option value="admin" ${member.role === 'admin' ? 'selected' : ''}>Admin</option>
                    <option value="viewer" ${member.role === 'viewer' ? 'selected' : ''}>Viewer</option>
                  </select>
                </div>
                <button class="btn btn-danger btn-sm" onclick="removeSpaceMember('${spaceId}', '${member.id}')">Remove</button>
              </div>
            `).join('')}
          </div>
        </div>
        
        <div class="share-tab-content" id="invites-tab">
          <h4>Pending Invites (${invites.length})</h4>
          ${invites.length > 0 ? invites.map(invite => `
            <div class="invite-item">
              <div class="invite-email">${invite.email}</div>
              <div class="invite-role">${invite.role}</div>
              <div class="invite-date">Sent ${formatDate(invite.sentAt)}</div>
              <div class="invite-actions">
                <button class="btn btn-secondary btn-sm" onclick="resendInvite('${invite.id}')">Resend</button>
                <button class="btn btn-danger btn-sm" onclick="cancelInvite('${invite.id}')">Cancel</button>
              </div>
            </div>
          `).join('') : `
            <div class="empty-state-small">
              <p>No pending invites</p>
            </div>
          `}
        </div>
        
        <div class="share-tab-content" id="settings-tab">
          <h4>Sharing Settings</h4>
          <div class="setting-item">
            <label>
              <input type="checkbox" id="publicAccess" ${space.public ? 'checked' : ''} onchange="togglePublicAccess('${spaceId}', this.checked)">
              Public access
            </label>
            <p class="setting-description">Allow anyone with the link to view this space</p>
          </div>
          
          <div class="setting-item">
            <label>
              <input type="checkbox" id="inviteLinks" ${space.inviteLinks ? 'checked' : ''} onchange="toggleInviteLinks('${spaceId}', this.checked)">
              Enable invite links
            </label>
            <p class="setting-description">Generate shareable links for easy inviting</p>
          </div>
          
          ${space.inviteLinks ? `
            <div class="invite-link-section">
              <h5>Invite Link</h5>
              <div class="invite-link-container">
                <input type="text" id="inviteLink" value="${window.location.origin}/invite/${space.id}" readonly>
                <button class="btn btn-secondary" onclick="copyInviteLink()">Copy Link</button>
              </div>
            </div>
          ` : ''}
        </div>
      </div>
    </div>
  `;

  openModal('Share Space', content, 'medium');
}

// Helper functions for space actions
function configureAgent(spaceId, agentType) {
  showToast(`Configuring ${agentType} for space ${spaceId}`, 'info');
  // Implementation would open agent configuration modal
}

function createCustomAgent(spaceId) {
  showToast('Creating custom agent...', 'info');
  // Implementation would open custom agent creation wizard
}

function getSpaceAutomations(spaceId) {
  // Mock data - would fetch from database
  return [
    {
      id: 'auto-1',
      name: 'Daily Report Generator',
      description: 'Creates daily summary of completed tasks',
      trigger: 'Daily at 9 AM',
      actions: ['generate-report', 'send-email'],
      status: 'active',
      runCount: 42
    }
  ];
}

function createNewAutomation(spaceId) {
  showToast('Creating new automation...', 'info');
  // Implementation would open automation builder
}

function editAutomation(automationId) {
  showToast(`Editing automation ${automationId}`, 'info');
  // Implementation would open automation editor
}

function sendAskQuestion(spaceId) {
  const input = document.getElementById('askInput');
  const question = input.value.trim();
  if (!question) return;

  // Add question to history
  addToAskHistory(spaceId, { role: 'user', content: question });

  // Clear input
  input.value = '';

  // Simulate AI response (would call actual AI service)
  setTimeout(() => {
    const response = `I understand you're asking about "${question}". This is a simulated response. In a real implementation, this would connect to an AI service to provide accurate answers based on your space data.`;
    addToAskHistory(spaceId, { role: 'assistant', content: response });
  }, 1000);
}

function loadAskHistory(spaceId) {
  // Would load from localStorage or database
  const history = [];
  const container = document.getElementById('askHistory');
  if (container) {
    container.innerHTML = history.map(msg => `
      <div class="ask-message ${msg.role}">
        <div class="message-content">${msg.content}</div>
      </div>
    `).join('');
  }
}

function addToAskHistory(spaceId, message) {
  const container = document.getElementById('askHistory');
  if (container) {
    const messageEl = document.createElement('div');
    messageEl.className = `ask-message ${message.role}`;
    messageEl.innerHTML = `<div class="message-content">${message.content}</div>`;
    container.appendChild(messageEl);
    container.scrollTop = container.scrollHeight;
  }
}

function setAskQuestion(question) {
  const input = document.getElementById('askInput');
  if (input) {
    input.value = question;
    input.focus();
  }
}

function getSpaceMembers(spaceId) {
  // Mock data - would fetch from database
  return [
    { id: 'user-1', name: 'John Doe', email: 'john@example.com', role: 'admin', avatar: null },
    { id: 'user-2', name: 'Jane Smith', email: 'jane@example.com', role: 'member', avatar: null }
  ];
}

function getSpaceInvites(spaceId) {
  // Mock data - would fetch from database
  return [];
}

function sendSpaceInvite(spaceId) {
  const email = document.getElementById('inviteEmail').value;
  const role = document.getElementById('inviteRole').value;

  if (!email) {
    showToast('Please enter an email address', 'error');
    return;
  }

  // Implementation would send invite via email/SMS
  showToast(`Invite sent to ${email}`, 'success');
  document.getElementById('inviteEmail').value = '';
}

function updateMemberRole(spaceId, memberId, role) {
  showToast(`Updated member role to ${role}`, 'success');
  // Implementation would update database
}

function removeSpaceMember(spaceId, memberId) {
  if (confirm('Are you sure you want to remove this member?')) {
    showToast('Member removed', 'success');
    // Implementation would update database
  }
}

function switchShareTab(tabName) {
  // Hide all tabs
  document.querySelectorAll('.share-tab-content').forEach(tab => {
    tab.classList.remove('active');
  });
  document.querySelectorAll('.share-tab').forEach(tab => {
    tab.classList.remove('active');
  });

  // Show selected tab
  document.getElementById(`${tabName}-tab`).classList.add('active');
  event.target.classList.add('active');
}

function togglePublicAccess(spaceId, enabled) {
  showToast(`Public access ${enabled ? 'enabled' : 'disabled'}`, 'success');
  // Implementation would update space settings
}

function toggleInviteLinks(spaceId, enabled) {
  showToast(`Invite links ${enabled ? 'enabled' : 'disabled'}`, 'success');
  // Implementation would update space settings and regenerate/regenerate link
}

function copyInviteLink() {
  const linkInput = document.getElementById('inviteLink');
  if (linkInput) {
    linkInput.select();
    document.execCommand('copy');
    showToast('Invite link copied to clipboard', 'success');
  }
}
function filterSpaceDocs(spaceId) {
  const searchInput = document.getElementById('docsSearchInput');
  const query = searchInput ? searchInput.value.toLowerCase() : '';
  const allDocs = loadDocs();
  const docs = allDocs.filter(d => String(d.spaceId) === String(spaceId));

  const container = document.getElementById('docsTreeContainer');
  if (!container) return;

  const treeItems = container.querySelectorAll('.docs-tree-item[data-doc-id]');
  treeItems.forEach(item => {
    const text = item.querySelector('.docs-tree-item-text');
    if (text) {
      const title = text.textContent.toLowerCase();
      if (query && !title.includes(query)) {
        item.style.display = 'none';
      } else {
        item.style.display = '';
      }
    }
  });
}

// ============================================
// Delete Confirmations for Docs and Excels
// ============================================
function confirmDeleteDoc(docId, docTitle) {
  const content = `
    <div style="text-align: center;">
      <div style="margin-bottom: 16px; display: flex; justify-content: center;">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width:48px;height:48px;color:var(--destructive);">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
          <polyline points="14 2 14 8 20 8"/>
          <line x1="9" y1="15" x2="15" y2="15"/>
        </svg>
      </div>
      <p style="color: var(--muted-foreground); margin-bottom: 24px;">
        Are you sure you want to delete "<strong>${docTitle}</strong>"? This action cannot be undone.
      </p>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="button" class="btn btn-danger" onclick="deleteDocConfirmed('${docId}')">Delete Document</button>
      </div>
    </div>
  `;
  openModal('Delete Document', content);
}

async function deleteDocConfirmed(docId) {
  await deleteDoc(docId);
  closeModal();
  showToast('Document deleted successfully!');

  // Refresh current view
  const activeSpace = document.querySelector('.custom-space-item.active');
  if (activeSpace) {
    const spaceId = activeSpace.dataset.spaceId;
    openSpaceView(spaceId);
  }
}

function confirmDeleteExcel(excelId, excelTitle) {
  const content = `
    <div style="text-align: center;">
      <div style="font-size: 48px; margin-bottom: 16px;">📊</div>
      <p style="color: var(--muted-foreground); margin-bottom: 24px;">
        Are you sure you want to delete "<strong>${excelTitle}</strong>"? This action cannot be undone.
      </p>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="button" class="btn btn-danger" onclick="deleteExcelConfirmed('${excelId}')">Delete Spreadsheet</button>
      </div>
    </div>
  `;
  openModal('Delete Spreadsheet', content);
}

async function deleteExcelConfirmed(excelId) {
  await deleteExcel(excelId);
  closeModal();
  showToast('Spreadsheet deleted successfully!');

  // Refresh current view
  const activeSpace = document.querySelector('.custom-space-item.active');
  if (activeSpace) {
    const spaceId = activeSpace.dataset.spaceId;
    openSpaceView(spaceId);
  }
}

// ============================================
// Toast Notification
// ============================================
function showToast(message) {
  const existing = document.querySelector('.layer-toast');
  if (existing) existing.remove();

  const toast = document.createElement('div');
  toast.className = 'layer-toast';
  toast.innerHTML = `
    <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;color:hsl(142, 71%, 45%);">
      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
      <polyline points="22 4 12 14.01 9 11.01"/>
    </svg>
    <span>${message}</span>
  `;
  toast.style.cssText = `
    position: fixed;
    bottom: 24px;
    right: 24px;
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px 24px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    color: var(--foreground);
    font-size: 14px;
    font-weight: 500;
    z-index: 9999;
    animation: toastSlideIn 0.3s ease;
  `;

  document.body.appendChild(toast);

  setTimeout(() => {
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(10px)';
    setTimeout(() => toast.remove(), 300);
  }, 3000);
}

// Initialize spaces on load
document.addEventListener('DOMContentLoaded', () => {
  // Remove old spacesSection if it exists
  const oldSpacesSection = document.getElementById('spacesSection');
  if (oldSpacesSection) {
    oldSpacesSection.remove();
  }

  renderSpacesInSidebar();
});


// Make functions globally accessible
window.openFocusModeModal = openFocusModeModal;
window.toggleFocusModeExpand = toggleFocusModeExpand;
window.selectFocusDuration = selectFocusDuration;
window.startFocusMode = startFocusMode;
window.toggleTimerExpand = toggleTimerExpand;
window.toggleTimerPause = toggleTimerPause;
window.stopFocusMode = stopFocusMode;
window.toggleFocusTask = toggleFocusTask;
window.openAddRecurringModal = openAddRecurringModal;
window.handleAddRecurringSubmit = handleAddRecurringSubmit;
window.deleteRecurringTask = deleteRecurringTask;


window.openShareModal = openShareModal;
window.openPageStylesSidebar = openPageStylesSidebar;
window.closePageStylesSidebar = closePageStylesSidebar;
window.togglePageStyleOption = togglePageStyleOption;
window.togglePageStyleToggle = togglePageStyleToggle;
window.addShareEmail = addShareEmail;
window.copyShareLink = copyShareLink;

// ============================================
// Share Modal Function
// ============================================
let pendingShareEmails = [];

function openShareModal() {
  pendingShareEmails = [];

  const content = `
    <div class="share-modal-content">
      <div class="share-input-group">
        <input type="email" class="share-email-input" id="shareEmailInput" placeholder="Enter email address" />
        <button class="share-add-btn" onclick="addShareEmail()">Add</button>
      </div>
      
      <div class="share-people-list" id="sharePeopleList">
        <div class="share-people-title">People with access</div>
        <div id="sharePersonItems">
          <div style="padding: 16px; text-align: center; color: var(--muted-foreground); font-size: 13px;">
            No one has been added yet. Add people by email above.
          </div>
        </div>
      </div>
      
      <div class="share-link-section">
        <div class="share-people-title">Share link</div>
        <div class="share-link-row">
          <input type="text" class="share-link-input" id="shareLinkInput" value="${window.location.origin}/doc/${currentDocId}" readonly />
          <button class="share-copy-btn" onclick="copyShareLink()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
            </svg>
            Copy
          </button>
        </div>
      </div>
      
      <div class="form-actions" style="margin-top: 24px;">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-primary" onclick="shareDocConfirm()">Share</button>
      </div>
    </div>
  `;

  openModal('Share Document', content);

  setTimeout(() => {
    document.getElementById('shareEmailInput')?.focus();
  }, 100);
}

function addShareEmail() {
  const input = document.getElementById('shareEmailInput');
  const email = input.value.trim();

  if (!email || !email.includes('@')) {
    input.style.borderColor = 'hsl(0, 84%, 60%)';
    setTimeout(() => input.style.borderColor = '', 2000);
    return;
  }

  if (pendingShareEmails.find(e => e.email === email)) {
    showToast('Email already added');
    return;
  }

  pendingShareEmails.push({ email, role: 'Can view' });
  input.value = '';
  renderSharePeople();
}

function renderSharePeople() {
  const container = document.getElementById('sharePersonItems');
  if (!container) return;

  if (pendingShareEmails.length === 0) {
    container.innerHTML = `
      <div style="padding: 16px; text-align: center; color: var(--muted-foreground); font-size: 13px;">
        No one has been added yet. Add people by email above.
      </div>
    `;
    return;
  }

  container.innerHTML = pendingShareEmails.map((person, index) => `
    <div class="share-person-item">
      <div class="share-person-avatar">${person.email.charAt(0).toUpperCase()}</div>
      <div class="share-person-info">
        <div class="share-person-name">${person.email.split('@')[0]}</div>
        <div class="share-person-email">${person.email}</div>
      </div>
      <select class="share-person-role" onchange="updateShareRole(${index}, this.value)">
        <option value="Can view" ${person.role === 'Can view' ? 'selected' : ''}>Can view</option>
        <option value="Can edit" ${person.role === 'Can edit' ? 'selected' : ''}>Can edit</option>
        <option value="Can comment" ${person.role === 'Can comment' ? 'selected' : ''}>Can comment</option>
      </select>
      <button onclick="removeSharePerson(${index})" style="background:none;border:none;cursor:pointer;color:var(--muted-foreground);padding:4px;">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
  `).join('');
}

function updateShareRole(index, role) {
  if (pendingShareEmails[index]) {
    pendingShareEmails[index].role = role;
  }
}

function removeSharePerson(index) {
  pendingShareEmails.splice(index, 1);
  renderSharePeople();
}

async function shareDocConfirm() {
  if (pendingShareEmails.length === 0) {
    showToast('Add at least one email to share');
    return;
  }

  // Save share settings to database (primary) and localStorage (fallback)
  try {
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      console.log('🔴 Saving share to database for doc:', currentDocId);
      await window.LayerDB.updateDoc(currentDocId, { shared_with: pendingShareEmails });
      console.log('✅ Share saved to database successfully');
    }

    // Also update localStorage for immediate local consistency
    const docs = loadDocs();
    const docIndex = docs.findIndex(d => d.id === currentDocId);
    if (docIndex !== -1) {
      docs[docIndex].sharedWith = pendingShareEmails;
      saveDocs(docs);
    }

    // Clear cache to ensure fresh data on next load
    clearSharedUsersCache('doc', currentDocId);

    closeModal();
    showToast(`Document shared with ${pendingShareEmails.length} people`);

    // Refresh shared content widget after a short delay to allow DB propagation
    setTimeout(() => {
      loadSharedContentWidget();
    }, 500);

    // Update current document's shared users display if in editor
    if (currentDocId) {
      setTimeout(async () => {
        await updateCurrentDocSharedUsers();
      }, 600);
    }
  } catch (error) {
    console.error('❌ Failed to share document:', error);
    showToast('Failed to share document. Please try again.', 'error');
  }
}

function copyShareLink() {
  const input = document.getElementById('shareLinkInput');
  if (input) {
    input.select();
    document.execCommand('copy');
    showToast('Link copied to clipboard');
  }
}

// ============================================
// Page Styles Sidebar
// ============================================
let pageStylesSettings = {
  fontStyle: 'system',
  fontSize: 'default',
  pageWidth: 'default',
  coverImage: false,
  pageIcon: true,
  owners: true,
  contributors: false,
  subtitle: false,
  lastModified: true,
  pageOutline: false,
  focusBlock: false,
  focusPage: false
};

function openPageStylesSidebar() {
  // Create overlay
  let overlay = document.getElementById('pageStylesOverlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.className = 'page-styles-overlay';
    overlay.id = 'pageStylesOverlay';
    overlay.onclick = (e) => {
      if (e.target === overlay) closePageStylesSidebar();
    };

    overlay.innerHTML = `
      <div class="page-styles-sidebar" id="pageStylesSidebar">
        <div class="page-styles-container">
          <!-- Left Tabs -->
          <div class="page-styles-tabs">
            <button class="page-styles-tab" title="Document">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
              </svg>
            </button>
            <button class="page-styles-tab active" title="Typography">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="4 7 4 4 20 4 20 7"/>
                <line x1="9" y1="20" x2="15" y2="20"/>
                <line x1="12" y1="4" x2="12" y2="20"/>
              </svg>
            </button>
            <button class="page-styles-tab" title="Layout">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                <line x1="3" y1="9" x2="21" y2="9"/>
                <line x1="9" y1="21" x2="9" y2="9"/>
              </svg>
            </button>
            <button class="page-styles-tab" title="Export">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7 10 12 15 17 10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
              </svg>
            </button>
          </div>
          
          <!-- Content -->
          <div class="page-styles-content">
            <div class="page-styles-header">
              <span class="page-styles-title">Page Styles</span>
              <button class="page-styles-close" onclick="closePageStylesSidebar()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
                  <polyline points="13 17 18 12 13 7"/>
                  <polyline points="6 17 11 12 6 7"/>
                </svg>
              </button>
            </div>
            
            <!-- Font Style -->
            <div class="page-styles-section">
              <div class="page-styles-section-title">Font style</div>
              <div class="page-styles-options">
                <button class="page-styles-option ${pageStylesSettings.fontStyle === 'system' ? 'active' : ''}" onclick="togglePageStyleOption('fontStyle', 'system')">
                  <span style="font-family: -apple-system, sans-serif; font-size: 16px; font-weight: 600;">Aa</span>
                  <span>System</span>
                </button>
                <button class="page-styles-option ${pageStylesSettings.fontStyle === 'serif' ? 'active' : ''}" onclick="togglePageStyleOption('fontStyle', 'serif')">
                  <span style="font-family: Georgia, serif; font-size: 16px; font-weight: 600;">Ss</span>
                  <span>Serif</span>
                </button>
                <button class="page-styles-option ${pageStylesSettings.fontStyle === 'mono' ? 'active' : ''}" onclick="togglePageStyleOption('fontStyle', 'mono')">
                  <span style="font-family: monospace; font-size: 14px; font-weight: 600;">00</span>
                  <span>Mono</span>
                </button>
              </div>
            </div>
            
            <!-- Font Size -->
            <div class="page-styles-section">
              <div class="page-styles-section-title">Font size</div>
              <div class="page-styles-options">
                <button class="page-styles-option ${pageStylesSettings.fontSize === 'small' ? 'active' : ''}" onclick="togglePageStyleOption('fontSize', 'small')">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:18px;height:18px;">
                    <path d="M4 7V4h16v3"/><path d="M9 20h6"/><path d="M12 4v16"/>
                  </svg>
                  <span>Small</span>
                </button>
                <button class="page-styles-option ${pageStylesSettings.fontSize === 'default' ? 'active' : ''}" onclick="togglePageStyleOption('fontSize', 'default')">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;">
                    <path d="M4 7V4h16v3"/><path d="M9 20h6"/><path d="M12 4v16"/>
                  </svg>
                  <span>Default</span>
                </button>
                <button class="page-styles-option ${pageStylesSettings.fontSize === 'large' ? 'active' : ''}" onclick="togglePageStyleOption('fontSize', 'large')">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:24px;height:24px;">
                    <path d="M4 7V4h16v3"/><path d="M9 20h6"/><path d="M12 4v16"/>
                  </svg>
                  <span>Large</span>
                </button>
              </div>
            </div>
            
            <!-- Page Width -->
            <div class="page-styles-section">
              <div class="page-styles-section-title">Page width</div>
              <div class="page-styles-options" style="grid-template-columns: 1fr 1fr;">
                <button class="page-styles-option ${pageStylesSettings.pageWidth === 'default' ? 'active' : ''}" onclick="togglePageStyleOption('pageWidth', 'default')">
                  <span>Default</span>
                </button>
                <button class="page-styles-option ${pageStylesSettings.pageWidth === 'full' ? 'active' : ''}" onclick="togglePageStyleOption('pageWidth', 'full')">
                  <span>Full width</span>
                </button>
              </div>
            </div>
            
            <button class="page-styles-apply-btn" onclick="applyToAllPages()">Apply typography to all pages</button>
            
            <!-- Header Section -->
            <div class="page-styles-section" style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border);">
              <div class="page-styles-section-title">Header</div>
              
              <div class="page-styles-toggle-row">
                <div class="page-styles-toggle-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                    <circle cx="8.5" cy="8.5" r="1.5"/>
                    <polyline points="21 15 16 10 5 21"/>
                  </svg>
                  Cover image
                </div>
                <div class="page-styles-toggle ${pageStylesSettings.coverImage ? 'active' : ''}" onclick="togglePageStyleToggle('coverImage')"></div>
              </div>
              
              <div class="page-styles-toggle-row">
                <div class="page-styles-toggle-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M8 14s1.5 2 4 2 4-2 4-2"/>
                    <line x1="9" y1="9" x2="9.01" y2="9"/>
                    <line x1="15" y1="9" x2="15.01" y2="9"/>
                  </svg>
                  Page icon & title
                </div>
                <div class="page-styles-toggle ${pageStylesSettings.pageIcon ? 'active' : ''}" onclick="togglePageStyleToggle('pageIcon')"></div>
              </div>
              
              <div class="page-styles-toggle-row">
                <div class="page-styles-toggle-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                    <circle cx="12" cy="7" r="4"/>
                  </svg>
                  Owners
                </div>
                <div class="page-styles-toggle ${pageStylesSettings.owners ? 'active' : ''}" onclick="togglePageStyleToggle('owners')"></div>
              </div>
              
              <div class="page-styles-toggle-row">
                <div class="page-styles-toggle-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                    <circle cx="9" cy="7" r="4"/>
                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                    <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                  </svg>
                  Contributors
                </div>
                <div class="page-styles-toggle ${pageStylesSettings.contributors ? 'active' : ''}" onclick="togglePageStyleToggle('contributors')"></div>
              </div>
              
              <div class="page-styles-toggle-row">
                <div class="page-styles-toggle-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="4 7 4 4 20 4 20 7"/>
                    <line x1="9" y1="20" x2="15" y2="20"/>
                    <line x1="12" y1="4" x2="12" y2="20"/>
                  </svg>
                  Subtitle
                </div>
                <div class="page-styles-toggle ${pageStylesSettings.subtitle ? 'active' : ''}" onclick="togglePageStyleToggle('subtitle')"></div>
              </div>
              
              <div class="page-styles-toggle-row">
                <div class="page-styles-toggle-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <polyline points="12 6 12 12 16 14"/>
                  </svg>
                  Last modified
                </div>
                <div class="page-styles-toggle ${pageStylesSettings.lastModified ? 'active' : ''}" onclick="togglePageStyleToggle('lastModified')"></div>
              </div>
            </div>
            
            <!-- Sections -->
            <div class="page-styles-section" style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border);">
              <div class="page-styles-section-title">Sections</div>
              
              <div class="page-styles-link-row">
                <div class="page-styles-link-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                  </svg>
                  Subpages
                </div>
                <div class="page-styles-link-value">
                  Table
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                    <polyline points="9 18 15 12 9 6"/>
                  </svg>
                </div>
              </div>
              
              <div class="page-styles-link-row">
                <div class="page-styles-link-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="18" cy="5" r="3"/>
                    <circle cx="6" cy="12" r="3"/>
                    <circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                  </svg>
                  Relationships
                </div>
                <div class="page-styles-link-value">
                  Dialog
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                    <polyline points="9 18 15 12 9 6"/>
                  </svg>
                </div>
              </div>
              
              <div class="page-styles-toggle-row">
                <div class="page-styles-toggle-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="3" y1="12" x2="21" y2="12"/>
                    <line x1="3" y1="6" x2="21" y2="6"/>
                    <line x1="3" y1="18" x2="21" y2="18"/>
                  </svg>
                  Page outline
                </div>
                <div class="page-styles-toggle ${pageStylesSettings.pageOutline ? 'active' : ''}" onclick="togglePageStyleToggle('pageOutline')"></div>
              </div>
            </div>
            
            <!-- Focus mode -->
            <div class="page-styles-section" style="margin-top: 24px; padding-top: 20px; border-top: 1px solid var(--border);">
              <div class="page-styles-section-title">Focus mode</div>
              
              <div class="page-styles-toggle-row">
                <div class="page-styles-toggle-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="3" y1="12" x2="21" y2="12"/>
                    <line x1="3" y1="6" x2="21" y2="6"/>
                    <line x1="3" y1="18" x2="21" y2="18"/>
                  </svg>
                  Block
                </div>
                <div class="page-styles-toggle ${pageStylesSettings.focusBlock ? 'active' : ''}" onclick="togglePageStyleToggle('focusBlock')"></div>
              </div>
              
              <div class="page-styles-toggle-row">
                <div class="page-styles-toggle-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                  </svg>
                  Page
                </div>
                <div class="page-styles-toggle ${pageStylesSettings.focusPage ? 'active' : ''}" onclick="togglePageStyleToggle('focusPage')"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(overlay);
  }

  // Show
  requestAnimationFrame(() => {
    overlay.classList.add('show');
    document.getElementById('pageStylesSidebar')?.classList.add('show');
  });
}

function closePageStylesSidebar() {
  const overlay = document.getElementById('pageStylesOverlay');
  const sidebar = document.getElementById('pageStylesSidebar');

  if (sidebar) sidebar.classList.remove('show');
  if (overlay) {
    overlay.classList.remove('show');
    setTimeout(() => overlay.remove(), 250);
  }

  // Apply styles to document
  applyPageStyles();
}

function togglePageStyleOption(key, value) {
  pageStylesSettings[key] = value;

  // Update UI
  const section = document.querySelector(`[onclick*="'${key}'"]`)?.closest('.page-styles-section');
  if (section) {
    section.querySelectorAll('.page-styles-option').forEach(btn => {
      btn.classList.remove('active');
      if (btn.onclick.toString().includes(`'${value}'`)) {
        btn.classList.add('active');
      }
    });
  }

  applyPageStyles();
}

function togglePageStyleToggle(key) {
  pageStylesSettings[key] = !pageStylesSettings[key];

  // Update UI
  const toggles = document.querySelectorAll('.page-styles-toggle');
  toggles.forEach(toggle => {
    if (toggle.onclick.toString().includes(`'${key}'`)) {
      toggle.classList.toggle('active', pageStylesSettings[key]);
    }
  });

  applyPageStyles();
}

function applyPageStyles() {
  const editor = document.getElementById('docEditorContent') || document.querySelector('.notion-editor-content');
  const titleInput = document.getElementById('docTitleInput');
  const metaSection = document.querySelector('.notion-meta');

  if (editor) {
    // Font style
    switch (pageStylesSettings.fontStyle) {
      case 'serif':
        editor.style.fontFamily = 'Georgia, "Times New Roman", serif';
        if (titleInput) titleInput.style.fontFamily = 'Georgia, "Times New Roman", serif';
        break;
      case 'mono':
        editor.style.fontFamily = '"SF Mono", Monaco, Consolas, monospace';
        if (titleInput) titleInput.style.fontFamily = '"SF Mono", Monaco, Consolas, monospace';
        break;
      default:
        editor.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        if (titleInput) titleInput.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    }

    // Font size
    switch (pageStylesSettings.fontSize) {
      case 'small':
        editor.style.fontSize = '14px';
        break;
      case 'large':
        editor.style.fontSize = '18px';
        break;
      default:
        editor.style.fontSize = '16px';
    }

    // Page width
    const container = document.querySelector('.notion-page-container');
    if (container) {
      container.style.maxWidth = pageStylesSettings.pageWidth === 'full' ? '100%' : '720px';
    }
  }

  // Show/hide meta section
  if (metaSection) {
    metaSection.style.display = (pageStylesSettings.owners || pageStylesSettings.lastModified) ? 'flex' : 'none';
  }
}

function applyToAllPages() {
  showToast('Typography applied to all pages');
}

/* ============================================
   Feature 2: Dashboard Space Widgets
   ============================================ */

function getSpaceIconSVGById(iconId) {
  const iconData = SPACE_ICON_SVGS.find(i => i.id === iconId);
  if (iconData) return iconData.svg;
  return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>`;
}

function renderSpaceWidgets() {
  const spaces = loadSpaces();
  const allDocs = loadDocs();
  const allExcels = loadExcels();

  if (spaces.length === 0) return '';

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  return `
    <div class="dashboard-spaces-section">
      <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 20px; color: var(--foreground);">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;vertical-align:-4px;margin-right:8px;">
          <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
        </svg>
        Your Spaces
      </h3>
      <div class="dashboard-spaces-grid">
        ${spaces.map(space => {
    const docs = allDocs.filter(d => String(d.spaceId) === String(space.id));
    const excels = allExcels.filter(e => String(e.spaceId) === String(space.id));
    const dueDate = space.dueDate ? new Date(space.dueDate) : null;
    let dueDateClass = '';
    let dueDateText = '';

    if (dueDate) {
      dueDate.setHours(0, 0, 0, 0);
      const daysUntilDue = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));

      if (daysUntilDue < 0) {
        dueDateClass = 'overdue';
        dueDateText = 'Overdue';
      } else if (daysUntilDue <= 3) {
        dueDateClass = 'soon';
        dueDateText = daysUntilDue === 0 ? 'Due today' : daysUntilDue === 1 ? 'Due tomorrow' : 'Due in ' + daysUntilDue + ' days';
      } else {
        dueDateText = formatDate(space.dueDate);
      }
    }

    const colorVar = space.colorTag && space.colorTag !== 'none' ? 'var(--event-' + space.colorTag + ')' : 'var(--primary)';
    const spaceWidgetTodos = getSpaceWidgetTodos(space.id);
    const spaceWidgetNote = getSpaceWidgetNote(space.id);

    return `<div class="space-widget" style="--space-accent: ${colorVar}; --space-accent-rgb: ${colorVar.includes('event-') ? 'var(--event-' + space.colorTag + '-rgb)' : 'var(--primary-rgb)'};">
            <!-- Hover Actions Bar -->
            <div class="space-widget-hover-actions">
              <button class="space-hover-action-btn" onclick="event.stopPropagation(); showSpaceWidgetTodo('${space.id}')" title="Create To-Do">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>
              </button>
              <button class="space-hover-action-btn" onclick="event.stopPropagation(); showSpaceWidgetNote('${space.id}')" title="Add Note">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
              </button>
              <button class="space-hover-action-btn" onclick="event.stopPropagation(); openEditSpaceModal('${space.id}')" title="Edit Space">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
              </button>
            </div>
            
            <!-- To-Do Overlay -->
            <div class="space-widget-overlay space-widget-todo-overlay" id="spaceTodoOverlay-${space.id}">
              <div class="space-overlay-header">
                <span>To-Do List</span>
                <button class="space-overlay-close" onclick="event.stopPropagation(); hideSpaceWidgetOverlay('${space.id}', 'todo')">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>
                </button>
              </div>
              <div class="space-todo-list" id="spaceTodoList-${space.id}">
                ${spaceWidgetTodos.map((todo, idx) => `
                  <div class="space-todo-item ${todo.done ? 'done' : ''}">
                    <div class="space-todo-checkbox" onclick="event.stopPropagation(); toggleSpaceWidgetTodo('${space.id}', ${idx})">
                      ${todo.done ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>' : ''}
                    </div>
                    <span class="space-todo-text">${todo.text}</span>
                    <button class="space-todo-delete" onclick="event.stopPropagation(); deleteSpaceWidgetTodo('${space.id}', ${idx})">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>
                    </button>
                  </div>
                `).join('')}
              </div>
              <div class="space-todo-add">
                <input type="text" class="space-todo-input" id="spaceTodoInput-${space.id}" placeholder="Add a task..." 
                       onclick="event.stopPropagation();"
                       onkeypress="if(event.key==='Enter'){event.stopPropagation(); addSpaceWidgetTodo('${space.id}', this.value); this.value='';}" />
              </div>
            </div>
            
            <!-- Note Overlay -->
            <div class="space-widget-overlay space-widget-note-overlay" id="spaceNoteOverlay-${space.id}">
              <div class="space-overlay-header">
                <span>Quick Note</span>
                <button class="space-overlay-close" onclick="event.stopPropagation(); hideSpaceWidgetOverlay('${space.id}', 'note')">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>
                </button>
              </div>
              <textarea class="space-note-textarea" id="spaceNoteTextarea-${space.id}" placeholder="Write a quick note..." 
                        onclick="event.stopPropagation();"
                        oninput="autoSaveSpaceWidgetNote('${space.id}', this.value)">${spaceWidgetNote}</textarea>
              <div class="space-note-saved" id="spaceNoteSaved-${space.id}">Auto-saved</div>
            </div>
            
            <!-- Default Content -->
            <div class="space-widget-content" onclick="openSpaceView('${space.id}')">
              <div class="space-widget-header">
                <div class="space-widget-title-section">
                  <div class="space-widget-icon">${getSpaceIconSVGById(space.icon)}</div>
                  <div>
                    <h4 class="space-widget-title">${space.name}</h4>
                    ${space.description ? '<p class="space-widget-description">' + space.description + '</p>' : ''}
                  </div>
                </div>
              </div>
              <div class="space-widget-stats">
                <div class="space-widget-stat">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
                  <span>${docs.length} docs</span>
                </div>
                <button class="quick-action-btn" onclick="openExcelEditor()">
                  <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <style>
                      @keyframes tablePop {
                        0%, 100% {
                          transform: scale(1);
                        }
                        50% {
                          transform: scale(1.08);
                        }
                      }
                      
                      @keyframes gridDraw {
                        0% {
                          stroke-dashoffset: 18;
                          opacity: 0;
                        }
                        100% {
                          stroke-dashoffset: 0;
                          opacity: 1;
                        }
                      }
                      
                      @keyframes gridPulse {
                        0%, 100% {
                          stroke-width: 2;
                        }
                        50% {
                          stroke-width: 2.5;
                        }
                      }
                      
                      .quick-action-btn:hover .table-frame {
                        animation: tablePop 0.4s ease-in-out;
                      }
                      
                      .quick-action-btn:hover .grid-line {
                        animation: gridDraw 0.4s ease-out, gridPulse 0.5s ease-in-out;
                        stroke-dasharray: 18;
                      }
                      
                      .quick-action-btn:hover .grid-line:nth-child(2) {
                        animation-delay: 0.1s;
                      }
                      
                      .quick-action-btn:hover .grid-line:nth-child(3) {
                        animation-delay: 0.2s;
                      }
                    </style>
                    
                    <rect class="table-frame" x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <line class="grid-line" x1="3" y1="9" x2="21" y2="9"></line>
                    <line class="grid-line" x1="9" y1="3" x2="9" y2="21"></line>
                    <line class="grid-line" x1="9" y1="3" x2="9" y2="21"></line>
                  </svg>
                  New Sheet
                </button>
                <span>${excels.length} sheets</span>
              </div>
              ${dueDate ? '<div class="space-widget-due ' + dueDateClass + '"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span>' + dueDateText + '</span></div>' : ''}
            </div>
          </div>`;
  }).join('')}
      </div>
    </div>
  `;
}

// Space Widget To-Do & Note Storage
const SPACE_WIDGET_TODOS_KEY = 'layerSpaceWidgetTodos';
const SPACE_WIDGET_NOTES_KEY = 'layerSpaceWidgetNotes';

function getSpaceWidgetTodos(spaceId) {
  try {
    const all = JSON.parse(localStorage.getItem(SPACE_WIDGET_TODOS_KEY)) || {};
    return all[spaceId] || [];
  } catch { return []; }
}

function saveSpaceWidgetTodos(spaceId, todos) {
  const all = JSON.parse(localStorage.getItem(SPACE_WIDGET_TODOS_KEY) || '{}');
  all[spaceId] = todos;
  localStorage.setItem(SPACE_WIDGET_TODOS_KEY, JSON.stringify(all));
}

function getSpaceWidgetNote(spaceId) {
  try {
    const all = JSON.parse(localStorage.getItem(SPACE_WIDGET_NOTES_KEY)) || {};
    return all[spaceId] || '';
  } catch { return ''; }
}

function saveSpaceWidgetNote(spaceId, note) {
  const all = JSON.parse(localStorage.getItem(SPACE_WIDGET_NOTES_KEY) || '{}');
  all[spaceId] = note;
  localStorage.setItem(SPACE_WIDGET_NOTES_KEY, JSON.stringify(all));
}

function showSpaceWidgetTodo(spaceId) {
  const overlay = document.getElementById('spaceTodoOverlay-' + spaceId);
  if (overlay) {
    overlay.classList.add('active');
    setTimeout(() => {
      document.getElementById('spaceTodoInput-' + spaceId)?.focus();
    }, 100);
  }
}

function showSpaceWidgetNote(spaceId) {
  const overlay = document.getElementById('spaceNoteOverlay-' + spaceId);
  if (overlay) {
    overlay.classList.add('active');
    setTimeout(() => {
      document.getElementById('spaceNoteTextarea-' + spaceId)?.focus();
    }, 100);
  }
}

function hideSpaceWidgetOverlay(spaceId, type) {
  const overlayId = type === 'todo' ? 'spaceTodoOverlay-' + spaceId : 'spaceNoteOverlay-' + spaceId;
  const overlay = document.getElementById(overlayId);
  if (overlay) overlay.classList.remove('active');
}

function addSpaceWidgetTodo(spaceId, text) {
  if (!text || !text.trim()) return;
  const todos = getSpaceWidgetTodos(spaceId);
  todos.push({ text: text.trim(), done: false });
  saveSpaceWidgetTodos(spaceId, todos);
  refreshSpaceWidgetTodoList(spaceId);
}

function toggleSpaceWidgetTodo(spaceId, idx) {
  const todos = getSpaceWidgetTodos(spaceId);
  if (todos[idx]) {
    todos[idx].done = !todos[idx].done;
    saveSpaceWidgetTodos(spaceId, todos);
    refreshSpaceWidgetTodoList(spaceId);
  }
}

function deleteSpaceWidgetTodo(spaceId, idx) {
  const todos = getSpaceWidgetTodos(spaceId);
  todos.splice(idx, 1);
  saveSpaceWidgetTodos(spaceId, todos);
  refreshSpaceWidgetTodoList(spaceId);
}

function refreshSpaceWidgetTodoList(spaceId) {
  const container = document.getElementById('spaceTodoList-' + spaceId);
  if (!container) return;
  const todos = getSpaceWidgetTodos(spaceId);
  container.innerHTML = todos.map((todo, idx) => `
    <div class="space-todo-item ${todo.done ? 'done' : ''}">
      <div class="space-todo-checkbox" onclick="event.stopPropagation(); toggleSpaceWidgetTodo('${spaceId}', ${idx})">
        ${todo.done ? '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><polyline points="20 6 9 17 4 12"/></svg>' : ''}
      </div>
      <span class="space-todo-text">${todo.text}</span>
      <button class="space-todo-delete" onclick="event.stopPropagation(); deleteSpaceWidgetTodo('${spaceId}', ${idx})">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>
      </button>
    </div>
  `).join('');
}

let spaceWidgetNoteSaveTimeout = null;
function autoSaveSpaceWidgetNote(spaceId, value) {
  clearTimeout(spaceWidgetNoteSaveTimeout);
  spaceWidgetNoteSaveTimeout = setTimeout(() => {
    saveSpaceWidgetNote(spaceId, value);
    const savedIndicator = document.getElementById('spaceNoteSaved-' + spaceId);
    if (savedIndicator) {
      savedIndicator.classList.add('show');
      setTimeout(() => savedIndicator.classList.remove('show'), 1500);
    }
  }, 500);
}

function openEditSpaceModal(spaceId) {
  const spaces = loadSpaces();
  const space = spaces.find(s => String(s.id) === String(spaceId));
  if (!space) return;

  const escapedSpaceId = String(spaceId).replace(/'/g, "\\'");
  const content = `
    <form id="editSpaceForm" onsubmit="handleEditSpace(event, '${escapedSpaceId}')">
      <div class="form-group">
        <label class="form-label">Space Name <span class="required">*</span></label>
        <input type="text" name="name" class="form-input" required value="${space.name}" />
      </div>
      <div class="form-group">
        <label class="form-label">Description</label>
        <textarea name="description" class="form-textarea" rows="2">${space.description || ''}</textarea>
      </div>
      <div class="form-group">
        <label class="form-label">Due Date</label>
        <input type="date" name="dueDate" class="form-input" value="${space.dueDate || ''}" />
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Save Changes</button>
      </div>
    </form>
  `;
  openModal('Edit Space', content);
}

function handleEditSpace(event, spaceId) {
  event.preventDefault();
  const form = event.target;
  const name = form.name.value.trim();
  const description = form.description.value.trim();
  const dueDate = form.dueDate.value || null;

  if (!name) return;

  const spaces = loadSpaces();
  const idx = spaces.findIndex(s => String(s.id) === String(spaceId));
  if (idx !== -1) {
    spaces[idx] = { ...spaces[idx], name, description, dueDate };
    saveSpaces(spaces);
  }

  closeModal();
  renderSpacesInSidebar();
  renderCurrentView();
  showToast('Space updated!');
}

// Widget Backlog Functions for Task Completion Widget
function renderWidgetBacklogTasks() {
  const tasks = loadBacklogTasks();
  const activeTasks = tasks.filter(t => !t.done).slice(0, 5);

  if (activeTasks.length === 0) {
    return '<div class="widget-backlog-empty">No tasks in backlog</div>';
  }

  return activeTasks.map((task, idx) => {
    const originalIdx = tasks.findIndex(t => t.id === task.id);
    return `
      <div class="widget-backlog-item">
        <div class="widget-backlog-checkbox" onclick="event.stopPropagation(); handleToggleWidgetBacklogTask(${originalIdx})"></div>
        <span class="widget-backlog-text">${task.title}</span>
      </div>
    `;
  }).join('') + (tasks.filter(t => !t.done).length > 5 ? '<div class="widget-backlog-more">+' + (tasks.filter(t => !t.done).length - 5) + ' more tasks</div>' : '');
}

function handleToggleWidgetBacklogTask(index) {
  toggleBacklogTask(index);
  const listEl = document.getElementById('widgetBacklogList');
  if (listEl) listEl.innerHTML = renderWidgetBacklogTasks();
}

function flipTaskCompletionWidget() {
  const widget = document.getElementById('taskCompletionWidget');
  if (widget) {
    widget.classList.toggle('flipped');
    // Update backlog list when flipping to back
    if (widget.classList.contains('flipped')) {
      const listEl = document.getElementById('widgetBacklogList');
      if (listEl) listEl.innerHTML = renderWidgetBacklogTasks();
    }
  }
}

/* ============================================
   Feature 3: Checklist Sidebar for Spaces
   ============================================ */

const CHECKLISTS_KEY = 'layerSpaceChecklists';

// Load checklists from localStorage (cached from DB)
function loadChecklists() {
  // Only return checklists if user is authenticated
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return {};
  }

  try {
    return JSON.parse(localStorage.getItem(CHECKLISTS_KEY)) || {};
  } catch {
    return {};
  }
}

// Save checklists to localStorage and sync to database
async function saveChecklists(checklists) {
  try {
    localStorage.setItem(CHECKLISTS_KEY, JSON.stringify(checklists));

    // Sync to database if authenticated
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      // Update each space's checklist in the database
      const spaces = loadSpaces();
      for (const space of spaces) {
        const spaceId = String(space.id);
        if (checklists[spaceId]) {
          try {
            await window.LayerDB.updateSpace(space.id, { checklist: checklists[spaceId] });
          } catch (error) {
            console.error('Failed to sync checklist to database for space:', space.id, error);
          }
        }
      }
    }
  } catch (e) {
    console.error('Failed to save checklists:', e);
  }
}

function getSpaceChecklist(spaceId) {
  // Only return checklist if user is authenticated
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return [];
  }

  const checklists = loadChecklists();
  const spaceIdStr = String(spaceId);
  return checklists[spaceIdStr] || [];
}

async function saveSpaceChecklist(spaceId, items) {
  // Require authentication
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to save checklists', 'error');
    return;
  }

  const checklists = loadChecklists();
  const spaceIdStr = String(spaceId);
  checklists[spaceIdStr] = items;

  // Save to localStorage first for immediate UI update
  localStorage.setItem(CHECKLISTS_KEY, JSON.stringify(checklists));

  // Sync to database
  try {
    const spaces = loadSpaces();
    const space = spaces.find(s => String(s.id) === spaceIdStr);
    if (space) {
      await window.LayerDB.updateSpace(space.id, { checklist: items });
    }
  } catch (error) {
    console.error('Failed to save checklist to database:', error);
    showToast('Failed to save checklist', 'error');
  }
}

async function addChecklistItem(spaceId, text) {
  if (!text || !text.trim()) return;

  // Require authentication
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to add checklist items', 'error');
    return;
  }

  const items = getSpaceChecklist(spaceId);
  const newItem = {
    id: Date.now(),
    text: text.trim(),
    completed: false,
    createdAt: new Date().toISOString()
  };
  items.push(newItem);

  // Optimistic update - update UI immediately
  const checklists = loadChecklists();
  const spaceIdStr = String(spaceId);
  checklists[spaceIdStr] = items;
  localStorage.setItem(CHECKLISTS_KEY, JSON.stringify(checklists));
  renderChecklistSidebar(spaceId);

  // Sync to database in background
  saveSpaceChecklist(spaceId, items).catch(error => {
    console.error('Failed to save checklist item:', error);
    // Revert on error
    items.pop();
    checklists[spaceIdStr] = items;
    localStorage.setItem(CHECKLISTS_KEY, JSON.stringify(checklists));
    renderChecklistSidebar(spaceId);
    showToast('Failed to save checklist item', 'error');
  });
}

async function toggleChecklistItem(spaceId, itemId) {
  // Require authentication
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to update checklist items', 'error');
    return;
  }

  const items = getSpaceChecklist(spaceId);
  const item = items.find(i => i.id === itemId);
  if (item) {
    const oldState = item.completed;
    item.completed = !item.completed;

    // Optimistic update - update UI immediately
    const checklists = loadChecklists();
    const spaceIdStr = String(spaceId);
    checklists[spaceIdStr] = items;
    localStorage.setItem(CHECKLISTS_KEY, JSON.stringify(checklists));
    renderChecklistSidebar(spaceId);

    // Sync to database in background
    saveSpaceChecklist(spaceId, items).catch(error => {
      console.error('Failed to toggle checklist item:', error);
      // Revert on error
      item.completed = oldState;
      checklists[spaceIdStr] = items;
      localStorage.setItem(CHECKLISTS_KEY, JSON.stringify(checklists));
      renderChecklistSidebar(spaceId);
      showToast('Failed to update checklist item', 'error');
    });
  }
}

async function deleteChecklistItem(spaceId, itemId) {
  // Require authentication
  if (!window.LayerDB || !window.LayerDB.isAuthenticated()) {
    showToast('Please sign in to delete checklist items', 'error');
    return;
  }

  let items = getSpaceChecklist(spaceId);
  const deletedItem = items.find(i => i.id === itemId);
  items = items.filter(i => i.id !== itemId);

  // Optimistic update - update UI immediately
  const checklists = loadChecklists();
  const spaceIdStr = String(spaceId);
  checklists[spaceIdStr] = items;
  localStorage.setItem(CHECKLISTS_KEY, JSON.stringify(checklists));
  renderChecklistSidebar(spaceId);

  // Sync to database in background
  saveSpaceChecklist(spaceId, items).catch(error => {
    console.error('Failed to delete checklist item:', error);
    // Revert on error
    if (deletedItem) {
      items.push(deletedItem);
      checklists[spaceIdStr] = items;
      localStorage.setItem(CHECKLISTS_KEY, JSON.stringify(checklists));
      renderChecklistSidebar(spaceId);
    }
    showToast('Failed to delete checklist item', 'error');
  });
}

function renderChecklistSidebar(spaceId) {
  const container = document.getElementById('checklistContainer');
  if (!container) return;

  const items = getSpaceChecklist(spaceId);
  const completedCount = items.filter(i => i.completed).length;
  const totalCount = items.length;
  const progressPercent = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;

  // Properly escape spaceId for use in onclick handlers (handle both UUID strings and numbers)
  const spaceIdEscaped = typeof spaceId === 'string' ? `'${spaceId.replace(/'/g, "\\'")}'` : spaceId;

  container.innerHTML = `
    <div class="checklist-header">
      <div class="checklist-title">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M9 11l3 3L22 4"/>
          <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
        </svg>
        To-Do
      </div>
    </div>
    ${totalCount > 0 ? `
      <div class="checklist-progress">
        <div class="checklist-progress-bar">
          <div class="checklist-progress-fill" style="width: ${progressPercent}%;"></div>
        </div>
        <div class="checklist-progress-text">${completedCount} of ${totalCount} completed</div>
      </div>
    ` : ''}
    <div class="checklist-content">
      ${items.length > 0 ? `
        <div class="checklist-items">
          ${items.map(item => `
            <div class="checklist-item ${item.completed ? 'completed' : ''}">
              <div class="checklist-checkbox" onclick="toggleChecklistItem(${spaceIdEscaped}, ${item.id})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                  <polyline points="20 6 9 17 4 12"/>
                </svg>
              </div>
              <div class="checklist-item-content">
                <div class="checklist-item-text">${item.text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
              </div>
              <button class="checklist-item-delete" onclick="deleteChecklistItem(${spaceIdEscaped}, ${item.id})">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
              </button>
            </div>
          `).join('')}
        </div>
      ` : `
        <div class="checklist-empty">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M9 11l3 3L22 4"/>
            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
          </svg>
          <p>No tasks yet.<br>Add your first to-do item below.</p>
        </div>
      `}
    </div>
    <div class="checklist-add-input-wrapper">
      <input type="text" class="checklist-add-input" id="checklistAddInput" 
             placeholder="Add a task..." 
             onkeypress="if(event.key==='Enter'){addChecklistItem(${spaceIdEscaped}, this.value); this.value='';}" />
    </div>
  `;
}

function renderChecklistSidebarHTML(spaceId) {
  return `
    <div class="docs-checklist-sidebar" id="checklistContainer">
      <!-- Content will be rendered by renderChecklistSidebar -->
    </div>
  `;
}

/* ============================================
   Feature 4: In-Editor Share Panel
   ============================================ */

// Clear cache when sharing is updated to ensure fresh data
function clearSharedUsersCache(type, itemId) {
  const cacheKey = `${type}_${itemId}`;
  sharedUsersCache.delete(cacheKey);
  console.log('🗑️ Cleared shared users cache for:', cacheKey);
}

// Cache for shared users to avoid repeated database calls
const sharedUsersCache = new Map();

async function loadExistingSharedUsers(type) {
  const itemId = type === 'doc' ? currentDocId : currentExcelId;

  console.log('🟢 Loading existing shared users - Type:', type, 'Item ID:', itemId);

  if (!itemId) {
    console.log('🟢 No item ID, clearing shared users');
    inEditorShareEmails = [];
    return;
  }

  // Check cache first for instant loading
  const cacheKey = `${type}_${itemId}`;
  if (sharedUsersCache.has(cacheKey)) {
    console.log('🟢 Loading shared users from cache');
    inEditorShareEmails = sharedUsersCache.get(cacheKey);
    return;
  }

  try {
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      console.log('🟢 Loading from database');
      // Load from database
      let item;
      if (type === 'doc') {
        const { data, error } = await window.LayerDB.supabase
          .from('docs')
          .select('shared_with')
          .eq('id', itemId)
          .single();
        console.log('🟢 Doc query result:', { data, error });
        item = data;
      } else if (type === 'excel') {
        const { data, error } = await window.LayerDB.supabase
          .from('excels')
          .select('shared_with')
          .eq('id', itemId)
          .single();
        console.log('🟢 Excel query result:', { data, error });
        item = data;
      }

      inEditorShareEmails = item?.shared_with || [];
      console.log('🟢 Loaded shared users from database:', inEditorShareEmails);

      // Cache the result for instant loading next time
      sharedUsersCache.set(cacheKey, inEditorShareEmails);
    } else {
      console.log('🟢 Using localStorage fallback');
      // Fallback to localStorage - check both field names for backward compatibility
      if (type === 'doc') {
        const docs = loadDocs();
        const doc = docs.find(d => d.id === itemId);
        inEditorShareEmails = doc?.sharedWith || doc?.shared_with || [];
        console.log('🟢 Loaded from localStorage docs:', inEditorShareEmails);
      } else if (type === 'excel') {
        const excels = loadExcels();
        const excel = excels.find(e => e.id === itemId);
        inEditorShareEmails = excel?.sharedWith || excel?.shared_with || [];
        console.log('🟢 Loaded from localStorage excels:', inEditorShareEmails);
      }

      // Cache the result for instant loading next time
      sharedUsersCache.set(cacheKey, inEditorShareEmails);
    }
  } catch (error) {
    console.error('❌ Failed to load existing shared users:', error);
    inEditorShareEmails = [];
  }
}

function openInEditorSharePanel(type) {
  // type = 'doc' or 'excel'
  let overlay = document.getElementById('inEditorShareOverlay');
  let panel = document.getElementById('inEditorSharePanel');

  if (!overlay) {
    overlay = document.createElement('div');
    overlay.className = 'in-editor-share-overlay';
    overlay.id = 'inEditorShareOverlay';
    overlay.onclick = closeInEditorSharePanel;
    document.body.appendChild(overlay);
  }

  if (!panel) {
    panel = document.createElement('div');
    panel.className = 'in-editor-share-panel';
    panel.id = 'inEditorSharePanel';
    document.body.appendChild(panel);
  }

  const itemId = type === 'doc' ? currentDocId : currentExcelId;
  const shareLink = 'https://layer.app/share/' + type + '/' + itemId;

  // Get team members data
  const getTeamMembersForShare = async () => {
    let teamMembers = [];

    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      try {
        const currentUser = window.LayerDB.getCurrentUser();
        const currentUserInfo = {
          id: currentUser?.id,
          email: currentUser?.email,
          name: currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0] || 'User',
          avatar_url: currentUser?.user_metadata?.avatar_url
        };

        const followers = await window.LayerDB.getFollowers();
        const realFollowers = followers.filter(f => f.status === 'accepted');

        // Process followers to get team members (excluding current user)
        const seenUserIds = new Set([currentUserInfo?.id]);

        realFollowers.forEach(f => {
          let otherPerson = null;

          if (f.follower_id === currentUserInfo?.id) {
            // Current user is the follower, so show the person they're following
            otherPerson = {
              id: f.following_id,
              name: f.following_profile?.name || f.following_profile?.email?.split('@')[0] || 'Unknown',
              email: f.following_profile?.email || '',
              avatar_url: f.following_profile?.avatar_url || '',
              status: f.status
            };
          } else if (f.following_id === currentUserInfo?.id) {
            // Current user is being followed, so show the follower
            otherPerson = {
              id: f.follower_id,
              name: f.follower_profile?.name || f.follower_profile?.email?.split('@')[0] || 'Unknown',
              email: f.follower_profile?.email || '',
              avatar_url: f.follower_profile?.avatar_url || '',
              status: f.status
            };
          }

          if (otherPerson && otherPerson.id && !seenUserIds.has(otherPerson.id)) {
            seenUserIds.add(otherPerson.id);
            teamMembers.push(otherPerson);
          }
        });
      } catch (error) {
        console.error('Error loading team members for share:', error);
      }
    }

    return teamMembers;
  };

  // Generate team members HTML
  const generateTeamMembersHtml = (teamMembers) => {
    if (teamMembers.length === 0) {
      return '';
    }

    return `
      <div class="share-team-section" style="margin-top: 16px;">
        <label style="font-size: 13px; font-weight: 500; color: var(--muted-foreground); margin-bottom: 8px; display: block;">Team members</label>
        <div class="share-team-grid">
          ${teamMembers.map(member => {
      const initials = member.name ? member.name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2) : '??';
      const avatarHtml = member.avatar_url
        ? `<img src="${member.avatar_url}" alt="${member.name}" style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover;" />`
        : `<div style="width: 32px; height: 32px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; font-weight: 600;">${initials}</div>`;

      return `
              <div class="share-team-member" onclick="addTeamMemberToShare('${member.email}', '${member.name}', '${member.avatar_url || ''}')" style="display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; border: 1px solid var(--border);">
                ${avatarHtml}
                <div style="flex: 1; min-width: 0;">
                  <div style="font-size: 13px; font-weight: 500; color: var(--foreground); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${member.name}</div>
                  <div style="font-size: 11px; color: var(--muted-foreground); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${member.email}</div>
                </div>
                <button class="share-team-add-btn" style="background: var(--primary); color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 11px; cursor: pointer; transition: opacity 0.2s;">
                  Add
                </button>
              </div>
            `;
    }).join('')}
        </div>
      </div>
    `;
  };

  // Async function to render the panel with team members
  const renderPanel = async () => {
    const teamMembers = await getTeamMembersForShare();
    const teamMembersHtml = generateTeamMembersHtml(teamMembers);

    // Load existing shared users from database
    await loadExistingSharedUsers(type);

    panel.innerHTML = `
      <div class="in-editor-share-header">
        <div class="in-editor-share-title">Share ${type === 'doc' ? 'Document' : 'Spreadsheet'}</div>
        <button class="in-editor-share-close" onclick="closeInEditorSharePanel()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 6L6 18M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <div class="in-editor-share-content">
        <div class="share-input-section">
          <label style="font-size: 13px; font-weight: 500; color: var(--muted-foreground); margin-bottom: 8px; display: block;">Add people by email</label>
          <div class="share-input-row">
            <input type="email" class="share-email-input" id="inEditorShareEmailInput" placeholder="name@email.com" />
            <button class="share-add-btn" onclick="addInEditorShareEmail()">Add</button>
          </div>
        </div>
        
        ${teamMembersHtml}
        
        <div class="share-people-section" style="margin-top: 20px;">
          <label style="font-size: 13px; font-weight: 500; color: var(--muted-foreground); margin-bottom: 12px; display: block;">People with access</label>
          <div id="inEditorSharePersonItems">
            <!-- Will be populated by renderInEditorSharePeople -->
          </div>
        </div>
        
        <div class="share-link-section">
          <label style="font-size: 13px; font-weight: 500; color: var(--muted-foreground); margin-bottom: 8px; display: block;">Or share via link</label>
          <div class="share-link-row">
            <input type="text" class="share-link-input" id="inEditorShareLinkInput" value="${shareLink}" readonly />
            <button class="share-copy-btn" onclick="copyInEditorShareLink()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
              </svg>
              Copy
            </button>
          </div>
        </div>
        
        <div style="margin-top: 24px; display: flex; gap: 12px; justify-content: flex-end;">
          <button class="btn btn-secondary" onclick="closeInEditorSharePanel()">Cancel</button>
          <button class="btn btn-primary" onclick="confirmInEditorShare()">Share</button>
        </div>
      </div>
    `;

    // Render existing shared users in the UI
    renderInEditorSharePeople();

    // Show with animation
    requestAnimationFrame(() => {
      overlay.classList.add('open');
      panel.classList.add('open');
    });

    setTimeout(() => {
      document.getElementById('inEditorShareEmailInput')?.focus();
    }, 300);
  };

  renderPanel();
}

function closeInEditorSharePanel() {
  const overlay = document.getElementById('inEditorShareOverlay');
  const panel = document.getElementById('inEditorSharePanel');

  if (overlay) overlay.classList.remove('open');
  if (panel) panel.classList.remove('open');

  setTimeout(() => {
    if (overlay) overlay.remove();
    if (panel) panel.remove();
  }, 300);
}

let inEditorShareEmails = [];

function addTeamMemberToShare(email, name, avatarUrl) {
  // Check if email is already added
  const existingIndex = inEditorShareEmails.findIndex(item => item.email === email);
  if (existingIndex !== -1) {
    showToast('This person is already added to the share list');
    return;
  }

  // Add to the share emails list
  inEditorShareEmails.push({
    email: email,
    name: name,
    avatar_url: avatarUrl || null, // Store the avatar URL from Google account
    role: 'viewer' // Default role
  });

  // Re-render the people list
  renderInEditorSharePeople();

  // Show success message
  showToast(`${name} added to share list`);
}

async function addInEditorShareEmail() {
  const input = document.getElementById('inEditorShareEmailInput');
  const email = input.value.trim();

  if (!email || !email.includes('@')) {
    input.style.borderColor = 'hsl(0, 84%, 60%)';
    setTimeout(() => input.style.borderColor = '', 2000);
    return;
  }

  if (inEditorShareEmails.find(e => e.email === email)) {
    showToast('Email already added');
    return;
  }

  // Try to fetch user profile to get avatar and name
  let userAvatarUrl = null;
  let userName = email.split('@')[0];

  try {
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      // Try to get user profile by email
      const { data: profiles } = await window.LayerDB.supabase
        .from('user_profiles')
        .select('name, avatar_url')
        .eq('email', email)
        .limit(1);

      if (profiles && profiles.length > 0) {
        userName = profiles[0].name || userName;
        userAvatarUrl = profiles[0].avatar_url;
      }
    }
  } catch (error) {
    console.log('Could not fetch user profile for avatar:', error);
  }

  inEditorShareEmails.push({
    email,
    name: userName,
    avatar_url: userAvatarUrl,
    role: 'Can view'
  });
  input.value = '';
  renderInEditorSharePeople();
}

function renderInEditorSharePeople() {
  console.log('🟡 Rendering share people - Current users:', inEditorShareEmails);

  const container = document.getElementById('inEditorSharePersonItems');
  if (!container) {
    console.log('🟡 Container not found');
    return;
  }

  if (inEditorShareEmails.length === 0) {
    container.innerHTML = `
      <div style="padding: 16px; text-align: center; color: var(--muted-foreground); font-size: 13px;">
        No one has been added yet. Add people by email above.
      </div>
    `;
    // Clear header avatars when no users
    updateDocHeaderAvatars([]);
    updateExcelHeaderAvatars([]);
    console.log('🟡 No users to display, cleared headers');
    return;
  }

  container.innerHTML = inEditorShareEmails.map((person, index) => {
    // Generate avatar HTML
    const getAvatarHtml = (person) => {
      if (person.avatar_url) {
        return `<img src="${person.avatar_url}" alt="${person.name || person.email}" style="width: 36px; height: 36px; border-radius: 50%; object-fit: cover; border: 2px solid var(--border);" />`;
      } else {
        const initials = person.name
          ? person.name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2)
          : person.email.charAt(0).toUpperCase();
        const colors = [
          'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
          'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
          'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
          'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
          'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
          'linear-gradient(135deg, #30cfd0 0%, #330867 100%)'
        ];
        const colorIndex = person.email.charCodeAt(0) % colors.length;
        return `<div style="width: 36px; height: 36px; border-radius: 50%; background: ${colors[colorIndex]}; display: flex; align-items: center; justify-content: center; color: white; font-size: 14px; font-weight: 600; border: 2px solid var(--border);">${initials}</div>`;
      }
    };

    const displayName = person.name || person.email.split('@')[0];
    const avatarHtml = getAvatarHtml(person);

    return `
      <div class="share-person-item" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--surface); border-radius: 8px; border: 1px solid var(--border); margin-bottom: 8px;">
        ${avatarHtml}
        <div class="share-person-info" style="flex: 1; min-width: 0;">
          <div class="share-person-name" style="font-size: 14px; font-weight: 500; color: var(--foreground); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${displayName}</div>
          <div class="share-person-email" style="font-size: 12px; color: var(--muted-foreground); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${person.email}</div>
        </div>
        <select class="share-person-role" onchange="updateInEditorShareRole(${index}, this.value)" style="padding: 6px 8px; border: 1px solid var(--border); border-radius: 6px; background: var(--surface); color: var(--foreground); font-size: 12px;">
          <option value="Can view" ${person.role === 'Can view' ? 'selected' : ''}>Can view</option>
          <option value="Can edit" ${person.role === 'Can edit' ? 'selected' : ''}>Can edit</option>
        </select>
        <button onclick="removeInEditorSharePerson(${index})" style="background:none;border:none;cursor:pointer;color:var(--muted-foreground);padding:6px;border-radius:4px;transition:all 0.2s;" title="Remove">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
            <path d="M18 6L6 18M6 6l12 12"/>
          </svg>
        </button>
      </div>
    `;
  }).join('');

  // Update header avatars
  console.log('🟡 Updating header avatars with users:', inEditorShareEmails);
  updateDocHeaderAvatars(inEditorShareEmails);
  updateExcelHeaderAvatars(inEditorShareEmails);
}

function updateDocHeaderAvatars(sharedUsers) {
  const container = document.getElementById('docSharedAvatars');
  if (!container) return;

  if (sharedUsers.length === 0) {
    container.innerHTML = '';
    return;
  }

  const maxDisplay = 3;
  const displayUsers = sharedUsers.slice(0, maxDisplay);
  const remainingCount = sharedUsers.length - maxDisplay;

  const getAvatarHtml = (person, size = 28) => {
    if (person.avatar_url) {
      return `<img src="${person.avatar_url}" alt="${person.name || person.email}" style="width: ${size}px; height: ${size}px; border-radius: 50%; object-fit: cover; border: 2px solid var(--background); margin-left: -8px;" title="${person.name || person.email}" />`;
    } else {
      const initials = person.name
        ? person.name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2)
        : person.email.charAt(0).toUpperCase();
      const colors = [
        'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
        'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
        'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
        'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
        'linear-gradient(135deg, #30cfd0 0%, #330867 100%)'
      ];
      const colorIndex = person.email.charCodeAt(0) % colors.length;
      return `<div style="width: ${size}px; height: ${size}px; border-radius: 50%; background: ${colors[colorIndex]}; display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: 600; border: 2px solid var(--background); margin-left: -8px; cursor: pointer;" title="${person.name || person.email}">${initials}</div>`;
    }
  };

  let avatarsHtml = displayUsers.map((user, index) => getAvatarHtml(user)).join('');

  if (remainingCount > 0) {
    avatarsHtml += `
      <div style="width: 28px; height: 28px; border-radius: 50%; background: var(--muted); display: flex; align-items: center; justify-content: center; color: var(--foreground); font-size: 10px; font-weight: 600; border: 2px solid var(--background); margin-left: -8px; cursor: pointer;" title="${remainingCount} more people">
        +${remainingCount}
      </div>
    `;
  }

  container.innerHTML = avatarsHtml;
}

// Update current document's shared users with user profiles
async function updateCurrentDocSharedUsers() {
  if (!currentDocId || !window.LayerDB || !window.LayerDB.isAuthenticated()) {
    return;
  }

  try {
    // Get current document from database
    const docs = await window.LayerDB.loadDocs();
    const currentDoc = docs.find(d => d.id === currentDocId);

    if (!currentDoc || !currentDoc.sharedWith || currentDoc.sharedWith.length === 0) {
      updateDocHeaderAvatars([]);
      return;
    }

    // Fetch user profiles for shared users
    const sharedUsers = currentDoc.sharedWith;
    const userEmails = sharedUsers.map(user => user.email || user);

    // Get user profiles for each shared email
    const userProfiles = [];
    for (const email of userEmails) {
      try {
        // Try to find user by email in profiles
        const { data: profile } = await window.LayerDB.supabaseClient
          .from('profiles')
          .select('id, email, name, avatar_url')
          .ilike('email', email)
          .maybeSingle();

        if (profile) {
          userProfiles.push(profile);
        } else {
          // Fallback to email-only object if profile not found
          userProfiles.push({
            email: email,
            name: email.split('@')[0],
            avatar_url: null
          });
        }
      } catch (error) {
        console.log('Could not fetch profile for email:', email);
        userProfiles.push({
          email: email,
          name: email.split('@')[0],
          avatar_url: null
        });
      }
    }

    updateDocHeaderAvatars(userProfiles);
  } catch (error) {
    console.error('Failed to update current doc shared users:', error);
  }
}

function updateExcelHeaderAvatars(sharedUsers) {
  const container = document.getElementById('excelSharedAvatars');
  if (!container) return;

  if (sharedUsers.length === 0) {
    container.innerHTML = '';
    return;
  }

  const maxDisplay = 3;
  const displayUsers = sharedUsers.slice(0, maxDisplay);
  const remainingCount = sharedUsers.length - maxDisplay;

  const getAvatarHtml = (person, size = 28) => {
    if (person.avatar_url) {
      return `<img src="${person.avatar_url}" alt="${person.name || person.email}" style="width: ${size}px; height: ${size}px; border-radius: 50%; object-fit: cover; border: 2px solid var(--background); margin-left: -8px;" title="${person.name || person.email}" />`;
    } else {
      const initials = person.name
        ? person.name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2)
        : person.email.charAt(0).toUpperCase();
      const colors = [
        'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
        'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
        'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
        'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
        'linear-gradient(135deg, #30cfd0 0%, #330867 100%)'
      ];
      const colorIndex = person.email.charCodeAt(0) % colors.length;
      return `<div style="width: ${size}px; height: ${size}px; border-radius: 50%; background: ${colors[colorIndex]}; display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: 600; border: 2px solid var(--background); margin-left: -8px; cursor: pointer;" title="${person.name || person.email}">${initials}</div>`;
    }
  };

  let avatarsHtml = displayUsers.map((user, index) => getAvatarHtml(user)).join('');

  if (remainingCount > 0) {
    avatarsHtml += `
      <div style="width: 28px; height: 28px; border-radius: 50%; background: var(--muted); display: flex; align-items: center; justify-content: center; color: var(--foreground); font-size: 10px; font-weight: 600; border: 2px solid var(--background); margin-left: -8px; cursor: pointer;" title="${remainingCount} more people">
        +${remainingCount}
      </div>
    `;
  }

  container.innerHTML = avatarsHtml;
}

function updateInEditorShareRole(index, role) {
  if (inEditorShareEmails[index]) {
    inEditorShareEmails[index].role = role;

    // Immediately save changes to database
    const itemId = currentDocId || currentExcelId;
    const type = currentDocId ? 'doc' : 'excel';

    if (itemId && window.LayerDB && window.LayerDB.isAuthenticated()) {
      saveInEditorShareChanges(type, itemId);
    } else {
      saveInEditorShareChangesToLocalStorage(type, itemId);
    }

    console.log('🔧 Updated role for', inEditorShareEmails[index].email, 'to', role);

    // Refresh shared content widget to reflect role change
    setTimeout(() => {
      refreshSharedContent();
    }, 500);
  }
}

function removeInEditorSharePerson(index) {
  const removedPerson = inEditorShareEmails[index];
  inEditorShareEmails.splice(index, 1);

  console.log('🔴 Removing person from share:', removedPerson);

  // Immediately save changes to database
  const itemId = currentDocId || currentExcelId;
  const type = currentDocId ? 'doc' : 'excel';

  if (itemId && window.LayerDB && window.LayerDB.isAuthenticated()) {
    // Save to database immediately
    saveInEditorShareChanges(type, itemId);
  } else {
    // Fallback to localStorage
    saveInEditorShareChangesToLocalStorage(type, itemId);
  }

  renderInEditorSharePeople();
  showToast(`${removedPerson.name || removedPerson.email} removed from share`);

  // Refresh shared content widget to reflect removal
  setTimeout(() => {
    refreshSharedContent();
  }, 500);
}

// Helper function to save share changes to database
async function saveInEditorShareChanges(type, itemId) {
  try {
    console.log('🔴 Saving share changes to database - Type:', type, 'Item ID:', itemId);

    if (type === 'doc') {
      const result = await window.LayerDB.updateDoc(itemId, { shared_with: inEditorShareEmails });
      console.log('🔴 Doc update result:', result);
    } else if (type === 'excel') {
      const result = await window.LayerDB.updateExcel(itemId, { shared_with: inEditorShareEmails });
      console.log('🔴 Excel update result:', result);
    }

    // Immediately refresh shared content widget to notify the shared user
    console.log('🔄 Refreshing shared content widget after sharing...');
    setTimeout(() => {
      loadSharedContentWidget();
    }, 500);

  } catch (error) {
    console.error('🔴 Failed to save share changes:', error);
    showToast('Failed to save share changes', 'error');
  }
}

// Helper function to save share changes to localStorage
function saveInEditorShareChangesToLocalStorage(type, itemId) {
  console.log('🔴 Saving share changes to localStorage - Type:', type, 'Item ID:', itemId);

  if (type === 'doc') {
    const docs = loadDocs();
    const docIndex = docs.findIndex(d => d.id === itemId);
    if (docIndex !== -1) {
      docs[docIndex].sharedWith = inEditorShareEmails;
      docs[docIndex].shared_with = inEditorShareEmails;
      saveDocs(docs);
      console.log('🔴 Saved to localStorage docs:', docs[docIndex]);
      // Clear cache to ensure fresh data on next load
      clearSharedUsersCache('doc', itemId);
    }
  } else if (type === 'excel') {
    const excels = loadExcels();
    const excelIndex = excels.findIndex(e => e.id === itemId);
    if (excelIndex !== -1) {
      excels[excelIndex].sharedWith = inEditorShareEmails;
      excels[excelIndex].shared_with = inEditorShareEmails;
      saveExcels(excels);
      console.log('🔴 Saved to localStorage excels:', excels[excelIndex]);
      // Clear cache to ensure fresh data on next load
      clearSharedUsersCache('excel', itemId);
    }
  }
}

function copyInEditorShareLink() {
  const input = document.getElementById('inEditorShareLinkInput');
  if (input) {
    input.select();
    document.execCommand('copy');
    showToast('Link copied to clipboard!');
  }
}

async function confirmInEditorShare() {
  if (inEditorShareEmails.length === 0) {
    showToast('Add at least one email to share');
    return;
  }

  console.log('🔵 Starting to save sharing settings:', inEditorShareEmails);
  console.log('🔵 Current doc ID:', currentDocId, 'Current excel ID:', currentExcelId);
  console.log('🔵 Is authenticated:', window.LayerDB?.isAuthenticated());

  try {
    // Save to database if authenticated
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      const itemId = currentDocId || currentExcelId;
      const type = currentDocId ? 'doc' : 'excel';

      console.log('🔵 Saving to database - Type:', type, 'Item ID:', itemId);

      if (type === 'doc') {
        const result = await window.LayerDB.updateDoc(itemId, { shared_with: inEditorShareEmails });
        console.log('🔵 Doc update result:', result);
      } else if (type === 'excel') {
        const result = await window.LayerDB.updateExcel(itemId, { shared_with: inEditorShareEmails });
        console.log('🔵 Excel update result:', result);
      }

      showToast('Shared with ' + inEditorShareEmails.length + ' people!');

      // Refresh shared content widget to show real-time updates
      setTimeout(() => {
        refreshSharedContent();
      }, 500);
    } else {
      console.log('🔵 Using localStorage fallback');
      // Fallback to localStorage - save both field names for consistency
      if (currentDocId) {
        const docs = loadDocs();
        const docIndex = docs.findIndex(d => d.id === currentDocId);
        if (docIndex !== -1) {
          docs[docIndex].sharedWith = inEditorShareEmails;
          docs[docIndex].shared_with = inEditorShareEmails; // Also save with snake_case for consistency
          saveDocs(docs);
          console.log('🔵 Saved to localStorage docs:', docs[docIndex]);
          // Clear cache to ensure fresh data on next load
          clearSharedUsersCache('doc', currentDocId);
        }
      } else if (currentExcelId) {
        const excels = loadExcels();
        const excelIndex = excels.findIndex(e => e.id === currentExcelId);
        if (excelIndex !== -1) {
          excels[excelIndex].sharedWith = inEditorShareEmails;
          excels[excelIndex].shared_with = inEditorShareEmails; // Also save with snake_case for consistency
          saveExcels(excels);
          console.log('🔵 Saved to localStorage excels:', excels[excelIndex]);
          // Clear cache to ensure fresh data on next load
          clearSharedUsersCache('excel', currentExcelId);
        }
      }
      showToast('Shared with ' + inEditorShareEmails.length + ' people!');
    }
  } catch (error) {
    console.error('❌ Failed to save sharing settings:', error);
    showToast('Failed to save sharing settings', 'error');
  }

  inEditorShareEmails = [];
  closeInEditorSharePanel();
}

/* ============================================
   Milestone Functions
   ============================================ */

function addMilestone(projectIndex) {
  const content = `
    <form id="addMilestoneForm" onsubmit="handleAddMilestoneSubmit(event, ${projectIndex})">
      <div class="form-group">
        <label class="form-label">Milestone Name <span class="required">*</span></label>
        <input type="text" name="name" class="form-input" placeholder="e.g., Phase 1, MVP, Beta Release..." required>
      </div>
      <div class="form-group">
        <label class="form-label">Total Tasks</label>
        <input type="number" name="total" class="form-input" placeholder="0" min="0" value="0">
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Add Milestone</button>
      </div>
    </form>
  `;
  openModal('Add Milestone', content);
}

function handleAddMilestoneSubmit(event, projectIndex) {
  event.preventDefault();
  const form = event.target;
  const formData = new FormData(form);

  const name = formData.get('name')?.trim();
  const total = parseInt(formData.get('total') || '0');

  if (!name) return;

  const projects = loadProjects();
  if (!projects[projectIndex]) return;

  if (!projects[projectIndex].milestones) {
    projects[projectIndex].milestones = [];
  }

  projects[projectIndex].milestones.push({
    id: Date.now(),
    name: name,
    total: total,
    completed: 0,
    createdAt: new Date().toISOString()
  });

  saveProjects(projects);
  closeModal();
  renderCurrentView();
}

function updateMilestoneName(projectIndex, milestoneIndex, newName) {
  const projects = loadProjects();
  if (projects[projectIndex]?.milestones?.[milestoneIndex]) {
    projects[projectIndex].milestones[milestoneIndex].name = newName.trim() || 'Untitled Milestone';
    saveProjects(projects);
  }
}

function openMilestoneMenu(projectIndex, milestoneIndex, event) {
  event.stopPropagation();

  // Remove any existing menu
  const existingMenu = document.getElementById('milestoneContextMenu');
  if (existingMenu) existingMenu.remove();

  const projects = loadProjects();
  const milestone = projects[projectIndex]?.milestones?.[milestoneIndex];
  if (!milestone) return;

  const menu = document.createElement('div');
  menu.id = 'milestoneContextMenu';
  menu.className = 'task-context-menu';
  menu.innerHTML = `
    <button class="context-menu-item" onclick="editMilestone(${projectIndex}, ${milestoneIndex}); hideMilestoneMenu();">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/>
        <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/>
      </svg>
      Edit
    </button>
    <button class="context-menu-item" onclick="updateMilestoneProgress(${projectIndex}, ${milestoneIndex}); hideMilestoneMenu();">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M12 20V10"/>
        <path d="M18 20V4"/>
        <path d="M6 20v-4"/>
      </svg>
      Update Progress
    </button>
    <button class="context-menu-item delete" onclick="deleteMilestone(${projectIndex}, ${milestoneIndex}); hideMilestoneMenu();">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m5 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
      </svg>
      Delete
    </button>
  `;

  menu.style.left = event.clientX + 'px';
  menu.style.top = event.clientY + 'px';

  document.body.appendChild(menu);

  setTimeout(() => {
    document.addEventListener('click', hideMilestoneMenu, { once: true });
  }, 10);
}

function hideMilestoneMenu() {
  const menu = document.getElementById('milestoneContextMenu');
  if (menu) menu.remove();
}

function editMilestone(projectIndex, milestoneIndex) {
  const projects = loadProjects();
  const milestone = projects[projectIndex]?.milestones?.[milestoneIndex];
  if (!milestone) return;

  const content = `
    <form onsubmit="handleEditMilestoneSubmit(event, ${projectIndex}, ${milestoneIndex})">
      <div class="form-group">
        <label class="form-label">Milestone Name</label>
        <input type="text" name="name" class="form-input" value="${milestone.name}" required>
      </div>
      <div class="form-group">
        <label class="form-label">Total Tasks</label>
        <input type="number" name="total" class="form-input" value="${milestone.total || 0}" min="0">
      </div>
      <div class="form-group">
        <label class="form-label">Completed Tasks</label>
        <input type="number" name="completed" class="form-input" value="${milestone.completed || 0}" min="0">
      </div>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button type="submit" class="btn btn-primary">Save Changes</button>
      </div>
    </form>
  `;
  openModal('Edit Milestone', content);
}

function handleEditMilestoneSubmit(event, projectIndex, milestoneIndex) {
  event.preventDefault();
  const form = event.target;
  const formData = new FormData(form);

  const projects = loadProjects();
  if (!projects[projectIndex]?.milestones?.[milestoneIndex]) return;

  projects[projectIndex].milestones[milestoneIndex] = {
    ...projects[projectIndex].milestones[milestoneIndex],
    name: formData.get('name')?.trim() || 'Untitled',
    total: parseInt(formData.get('total') || '0'),
    completed: parseInt(formData.get('completed') || '0')
  };

  saveProjects(projects);
  closeModal();
  renderCurrentView();
}

function updateMilestoneProgress(projectIndex, milestoneIndex) {
  const projects = loadProjects();
  const milestone = projects[projectIndex]?.milestones?.[milestoneIndex];
  if (!milestone) return;

  const newCompleted = prompt(`Update completed tasks for "${milestone.name}" (current: ${milestone.completed}/${milestone.total}):`, milestone.completed);
  if (newCompleted !== null) {
    const completed = parseInt(newCompleted);
    if (!isNaN(completed) && completed >= 0) {
      projects[projectIndex].milestones[milestoneIndex].completed = Math.min(completed, milestone.total);
      saveProjects(projects);
      renderCurrentView();
    }
  }
}

function deleteMilestone(projectIndex, milestoneIndex) {
  if (!confirm('Delete this milestone?')) return;

  const projects = loadProjects();
  if (projects[projectIndex]?.milestones) {
    projects[projectIndex].milestones.splice(milestoneIndex, 1);
    saveProjects(projects);
    renderCurrentView();
  }
}

function openMilestoneDetail(projectIndex, milestoneIndex) {
  const projects = loadProjects();
  const milestone = projects[projectIndex]?.milestones?.[milestoneIndex];
  if (!milestone) return;

  const progress = milestone.total > 0 ? Math.round((milestone.completed / milestone.total) * 100) : 0;

  const content = `
    <div style="padding: 16px;">
      <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">
        <span style="font-size: 24px; color: var(--primary);">◇</span>
        <h3 style="margin: 0; font-size: 18px; font-weight: 600;">${milestone.name}</h3>
      </div>
      <div style="background: var(--surface); padding: 16px; border-radius: 10px; margin-bottom: 16px;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
          <span style="color: var(--muted-foreground);">Progress</span>
          <span style="font-weight: 600;">${progress}%</span>
        </div>
        <div style="height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
          <div style="width: ${progress}%; height: 100%; background: var(--primary); border-radius: 4px;"></div>
        </div>
        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: var(--muted-foreground);">
          <span>${milestone.completed} completed</span>
          <span>${milestone.total - milestone.completed} remaining</span>
        </div>
      </div>
      <div class="form-actions">
        <button class="btn btn-secondary" onclick="closeModal()">Close</button>
        <button class="btn btn-primary" onclick="closeModal(); editMilestone(${projectIndex}, ${milestoneIndex})">Edit</button>
      </div>
    </div>
  `;
  openModal('Milestone Details', content);
}

/* ============================================
   Update Card Functions
   ============================================ */


function handleUpdateProjectSummary(projectIndex, summary) {
  const projects = loadProjects();
  if (projects[projectIndex]) {
    projects[projectIndex].summary = summary?.trim() || '';
    saveProjects(projects);
  }
}

/* ============================================
   Sidebar Priority Dropdown Functions
   ============================================ */

function openSidebarPriorityDropdown(projectIndex, event) {
  event.stopPropagation();

  // Close any other open dropdowns
  document.querySelectorAll('.sidebar-priority-dropdown.open').forEach(d => {
    d.classList.remove('open');
  });

  const dropdown = document.getElementById(`sidebarPriorityDropdown-${projectIndex}`);
  if (dropdown) {
    dropdown.classList.add('open');

    // Close when clicking outside
    setTimeout(() => {
      document.addEventListener('click', function closeDropdown(e) {
        if (!e.target.closest('.sidebar-priority-dropdown')) {
          dropdown.classList.remove('open');
          document.removeEventListener('click', closeDropdown);
        }
      });
    }, 10);
  }
}

function closeSidebarPriorityDropdown(projectIndex) {
  const dropdown = document.getElementById(`sidebarPriorityDropdown-${projectIndex}`);
  if (dropdown) {
    dropdown.classList.remove('open');
  }
}

/* ============================================
   Enhanced AI Sidebar Functions
   ============================================ */

// Doc AI Sidebar State
let docAiSidebarOpen = false;

function toggleDocAiSidebar() {
  docAiSidebarOpen = !docAiSidebarOpen;
  const sidebar = document.getElementById('docAiSidebar');
  if (sidebar) {
    if (docAiSidebarOpen) {
      sidebar.classList.add('open');
      // Focus input
      setTimeout(() => {
        document.getElementById('docAiInput')?.focus();
      }, 300);
    } else {
      sidebar.classList.remove('open');
    }
  }
}

function handleDocAiSend() {
  if (typeof window.processAISidebarChat === 'function') {
    const editor = document.getElementById('docEditorContent');
    const docText = editor ? editor.innerText.substring(0, 1000) : '';
    const ctx = `User is editing a document. Current content preview: ${docText}. You have universal knowledge - help with anything.`;
    window.processAISidebarChat('docAiInput', 'docAiMessages', ctx);
  } else {
    // Fallback when gemini-api not loaded
    const input = document.getElementById('docAiInput');
    const container = document.getElementById('docAiMessages');
    if (input && container && input.value.trim()) {
      const userMsg = document.createElement('div');
      userMsg.className = 'ai-sidebar-message user';
      userMsg.innerHTML = `<div class="ai-message-content">${escapeHtmlForAI(input.value)}</div>`;
      container.appendChild(userMsg);
      input.value = '';
      container.scrollTop = container.scrollHeight;

      // Show loading
      const loading = document.createElement('div');
      loading.className = 'ai-sidebar-message assistant ai-loading';
      loading.innerHTML = '<div class="ai-loading-animation"><div class="ai-loading-dot"></div><div class="ai-loading-dot"></div><div class="ai-loading-dot"></div><span class="ai-loading-text">Thinking</span></div>';
      container.appendChild(loading);
    }
  }
}

// Legacy function name for backward compatibility
function handleDocAiSidebarSend() {
  handleDocAiSend();
}

function escapeHtmlForAI(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Open AI Sidebar from button
function openAISidebar(type = 'doc') {
  if (type === 'doc') {
    toggleDocAiSidebar();
  }
}

/* ============================================
   Whiteboard AI Sidebar Functions  
   ============================================ */

let whiteboardAiSidebarOpen = false;

function toggleWhiteboardAiSidebar() {
  whiteboardAiSidebarOpen = !whiteboardAiSidebarOpen;
  const sidebar = document.getElementById('whiteboardAiSidebar');
  const backdrop = document.getElementById('whiteboardAiBackdrop');

  if (sidebar) {
    if (whiteboardAiSidebarOpen) {
      // Create sidebar if not exists
      createWhiteboardAiSidebar();
      setTimeout(() => {
        document.getElementById('whiteboardAiSidebar')?.classList.add('open');
        document.getElementById('whiteboardAiBackdrop')?.classList.add('open');
        document.getElementById('whiteboardAiInput')?.focus();
      }, 10);
    } else {
      sidebar.classList.remove('open');
      if (backdrop) backdrop.classList.remove('open');
    }
  } else {
    createWhiteboardAiSidebar();
    setTimeout(() => {
      document.getElementById('whiteboardAiSidebar')?.classList.add('open');
      document.getElementById('whiteboardAiBackdrop')?.classList.add('open');
      document.getElementById('whiteboardAiInput')?.focus();
    }, 10);
    whiteboardAiSidebarOpen = true;
  }
}

function createWhiteboardAiSidebar() {
  // Remove existing
  document.getElementById('whiteboardAiSidebar')?.remove();
  document.getElementById('whiteboardAiBackdrop')?.remove();

  const backdrop = document.createElement('div');
  backdrop.id = 'whiteboardAiBackdrop';
  backdrop.className = 'ai-sidebar-backdrop';
  backdrop.onclick = () => toggleWhiteboardAiSidebar();
  document.body.appendChild(backdrop);

  const sidebar = document.createElement('div');
  sidebar.id = 'whiteboardAiSidebar';
  sidebar.className = 'ai-sidebar-overlay';
  sidebar.innerHTML = `
    <div class="ai-sidebar-header">
      <div class="ai-sidebar-brand">
        <div class="ai-sidebar-brain-icon">
          <div class="ai-brain-pulse"></div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 4.44-1.54"/>
            <path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-4.44-1.54"/>
          </svg>
        </div>
        <span class="ai-sidebar-title-text">Brain</span>
      </div>
      <button class="ai-sidebar-close-minimal" onclick="toggleWhiteboardAiSidebar()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    <div class="ai-sidebar-messages" id="whiteboardAiMessages">
      <div class="ai-welcome-message">
        <div class="ai-welcome-header">
          <div class="ai-welcome-avatar">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 4.44-1.54"/>
              <path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-4.44-1.54"/>
            </svg>
          </div>
          <div class="ai-welcome-content">
            <div class="ai-welcome-name">Brain</div>
            <div class="ai-welcome-text">Welcome back! Feel free to ask me anything about this whiteboard. How can I help?</div>
          </div>
        </div>
      </div>
    </div>
    <div class="ai-sidebar-input-minimal">
      <div class="ai-input-container">
        <input type="text" id="whiteboardAiInput" 
               placeholder="Tell AI what to do next" 
               onkeydown="if(event.key==='Enter')handleWhiteboardAiSidebarSend()"/>
        <div class="ai-input-actions">
          <button class="ai-input-action-btn" title="Attach">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 5v14M5 12h14"/>
            </svg>
          </button>
          <button class="ai-input-action-btn" title="Settings">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="1"/>
            </svg>
          </button>
          <button class="ai-send-btn" onclick="handleWhiteboardAiSidebarSend()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
            </svg>
          </button>
        </div>
      </div>
      <div class="ai-page-context">
        <div class="ai-page-context-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="7" height="7" rx="1"/>
            <rect x="14" y="3" width="7" height="7" rx="1"/>
            <rect x="14" y="14" width="7" height="7" rx="1"/>
            <rect x="3" y="14" width="7" height="7" rx="1"/>
          </svg>
        </div>
        <span class="ai-page-context-text">Whiteboard</span>
      </div>
    </div>
  `;
  document.body.appendChild(sidebar);
}

function handleWhiteboardAiSidebarSend() {
  if (typeof window.processAISidebarChat === 'function') {
    let ctx = 'User is on the whiteboard canvas for visual planning.';
    if (typeof gripProjectIndex !== 'undefined' && gripProjectIndex !== null) {
      const projects = loadProjects();
      const p = projects[gripProjectIndex];
      if (p) ctx = `Working on whiteboard for project: ${p.name}. The whiteboard has ${gripCells?.length || 0} cells.`;
    }
    window.processAISidebarChat('whiteboardAiInput', 'whiteboardAiMessages', ctx);
  }
}

// ============================================
// Doc AI Inline Command - **prompt** trigger
// ============================================
let isAiWriting = false;

function setupDocAiCommand() {
  const editor = document.getElementById('docEditorContent');
  if (!editor) return;

  editor.addEventListener('input', async function (e) {
    if (isAiWriting) return;

    // Get current text content to check for **prompt** pattern
    const selection = window.getSelection();
    if (!selection.rangeCount) return;

    const range = selection.getRangeAt(0);
    const textNode = range.startContainer;

    if (textNode.nodeType === Node.TEXT_NODE) {
      const text = textNode.textContent;
      const cursorPos = range.startOffset;

      // Check for complete **prompt** pattern (starts and ends with **)
      const beforeCursor = text.substring(0, cursorPos);
      const match = beforeCursor.match(/\*\*(.+?)\*\*$/);

      if (match && match[1] && match[1].trim().length > 0) {
        const prompt = match[1].trim();

        // Find the full match position
        const fullMatch = match[0];
        const startPos = beforeCursor.lastIndexOf(fullMatch);
        const beforeCommand = text.substring(0, startPos);
        const afterCursor = text.substring(cursorPos);

        // Remove the **prompt** command from text
        textNode.textContent = beforeCommand + afterCursor;

        // Create inline loading indicator with smooth animation
        const loadingSpan = document.createElement('span');
        loadingSpan.className = 'ai-inline-loading';
        loadingSpan.innerHTML = `
          <span class="ai-writing-indicator">
            <svg class="ai-writing-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
            </svg>
            <span class="ai-writing-text">AI is writing</span>
            <span class="ai-writing-dots"><span></span><span></span><span></span></span>
          </span>
        `;

        // Insert loading at cursor position
        const newRange = document.createRange();
        newRange.setStart(textNode, beforeCommand.length);
        newRange.collapse(true);
        newRange.insertNode(loadingSpan);

        isAiWriting = true;

        try {
          // Call AI to generate formatted document content
          if (typeof window.callGeminiAPI === 'function') {
            const systemPrompt = `You are a document writer. Generate well-structured content based on the user's request.
Format the output as HTML with proper structure:
- Use <h1> for main titles (only one per document)
- Use <h2> for section headings
- Use <h3> for subsection headings
- Use <p> for paragraphs
- Use <ul> or <ol> for lists
- Use <strong> for emphasis
- Keep the content professional and well-organized
Do not include any explanation, just output the formatted HTML content directly.`;

            const response = await window.callGeminiAPI(prompt, systemPrompt);

            // Remove loading indicator
            loadingSpan.remove();

            // Create a container for the AI-generated content
            const responseContainer = document.createElement('div');
            responseContainer.className = 'ai-generated-content';
            responseContainer.innerHTML = response;

            // Insert with smooth typewriter animation
            const insertRange = document.createRange();
            insertRange.setStart(textNode, beforeCommand.length);
            insertRange.collapse(true);

            // Animate the content appearing
            responseContainer.style.opacity = '0';
            responseContainer.style.transform = 'translateY(10px)';
            insertRange.insertNode(responseContainer);

            // Trigger reflow and animate in
            requestAnimationFrame(() => {
              responseContainer.style.transition = 'opacity 0.4s ease, transform 0.4s ease';
              responseContainer.style.opacity = '1';
              responseContainer.style.transform = 'translateY(0)';
            });

            // Move cursor to end of inserted content
            const finalRange = document.createRange();
            finalRange.setStartAfter(responseContainer);
            finalRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(finalRange);

            // Trigger auto-save
            if (typeof autoSaveDoc === 'function') {
              autoSaveDoc();
            }
          }
        } catch (error) {
          loadingSpan.remove();
          console.error('AI writing error:', error);
        }

        isAiWriting = false;
      }
    }
  });
}

// Initialize doc AI command when editor opens
const origOpenDocEditor = window.openDocEditor;
if (typeof origOpenDocEditor === 'function') {
  window.openDocEditor = function (docId) {
    origOpenDocEditor(docId);
    setTimeout(() => {
      setupDocAiCommand();
    }, 100);
  };
}

// Make functions globally available
window.toggleDocAiSidebar = toggleDocAiSidebar;
window.handleDocAiSidebarSend = handleDocAiSidebarSend;
window.openAISidebar = openAISidebar;
window.toggleWhiteboardAiSidebar = toggleWhiteboardAiSidebar;
window.handleWhiteboardAiSidebarSend = handleWhiteboardAiSidebarSend;
window.setupDocAiCommand = setupDocAiCommand;

// ============================================
// AI View - Layer Intelligence Interface
// Advanced Professional AI System
// ============================================

const aiFeatureCards = [
  {
    icon: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>`,
    title: "Write a to-do list for a personal project or task",
    prompt: "Write a to-do list for a personal project or task"
  },
  {
    icon: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="4" width="20" height="16" rx="2"/><path d="M7 15h4M15 15h2M7 11h2M13 11h4"/></svg>`,
    title: "Generate an email or reply to a job offer",
    prompt: "Generate an email reply to a job offer"
  },
  {
    icon: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>`,
    title: "Summarise this article or text for me in one paragraph",
    prompt: "Summarise this article or text for me in one paragraph"
  },
  {
    icon: `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>`,
    title: "How does AI work in a technical capacity",
    prompt: "How does AI work in a technical capacity"
  }
];

const suggestedPrompts = [];

// AI Statistics tracking
let aiStats = {
  totalQueries: parseInt(localStorage.getItem('aiTotalQueries') || '0'),
  todayQueries: parseInt(localStorage.getItem('aiTodayQueries') || '0'),
  lastQueryDate: localStorage.getItem('aiLastQueryDate') || new Date().toDateString()
};

function updateAIStats() {
  const today = new Date().toDateString();
  if (aiStats.lastQueryDate !== today) {
    aiStats.todayQueries = 0;
    aiStats.lastQueryDate = today;
  }
  aiStats.totalQueries++;
  aiStats.todayQueries++;
  localStorage.setItem('aiTotalQueries', aiStats.totalQueries.toString());
  localStorage.setItem('aiTodayQueries', aiStats.todayQueries.toString());
  localStorage.setItem('aiLastQueryDate', aiStats.lastQueryDate);
}

function renderAIView() {
  // Get user name if signed in
  const currentUser = window.LayerDB?.getCurrentUser?.();
  const userName = currentUser?.user_metadata?.display_name || currentUser?.user_metadata?.full_name || 'there';

  return `
    <div class="ai-clean-landing">
      <!-- Clean Landing Content -->
      <div class="ai-clean-center">
        <h1 class="ai-clean-greeting">
          Hi ${escapeHtml(userName === 'there' ? 'there' : userName)},
          <br/>
          <span class="ai-clean-greeting-sub">What would you like to know?</span>
        </h1>
        <p class="ai-clean-hint">Use one of the most common prompts below or use your own to begin</p>

        <!-- Prompt Cards -->
        <div class="ai-clean-cards">
          ${aiFeatureCards.map(card => `
            <button class="ai-clean-card" onclick="sendSuggestedPrompt('${card.prompt.replace(/'/g, "\\'")}')">
              <span class="ai-clean-card-text">${card.title}</span>
              <span class="ai-clean-card-icon">${card.icon}</span>
            </button>
          `).join('')}
        </div>
      </div>

      <!-- Input at bottom -->
      <div class="ai-clean-input-area">
        <div class="ai-clean-input-box">
          <input
            type="text"
            class="ai-clean-input"
            placeholder="Ask whatever you want..."
            id="aiAgentInput"
            onkeydown="handleAIInputKeydown(event)"
            autocomplete="off"
          />
          <button class="ai-clean-send-btn" onclick="sendAIAgentPrompt()" id="aiSendBtn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
              <path d="M5 12h14M12 5l7 7-7 7"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  `;
}

// Voice input placeholder
function toggleVoiceInput() {
  showToast('Voice input coming soon!', 'info');
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function handleAIInputKeydown(event) {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendAIAgentPrompt();
  }
}

function setAIPrompt(prompt) {
  const input = document.getElementById('aiAgentInput');
  if (input) {
    input.value = prompt;
    input.focus();
  }
}

function sendSuggestedPrompt(prompt) {
  const input = document.getElementById('aiAgentInput');
  if (input) {
    input.value = prompt;
    sendAIAgentPrompt();
  }
}

async function sendAIAgentPrompt() {
  const input = document.getElementById('aiAgentInput');
  if (input && input.value.trim()) {
    const userMessage = input.value.trim();
    input.value = '';

    // Switch to chat view and start conversation
    openAIChatView(userMessage);
  }
}

function showAIAddOptions() {
  showToast('Add attachments coming soon!');
}

// ============================================
// SuperAgents Chat View - ClickUp Style
// ============================================

let aiChatMessages = [];
let aiChatIsLoading = false;
let aiGeneratedContent = null; // For Essay/Report/Code panel
let aiChatHistorySidebarOpen = false;
let currentConversationId = null;

// Load saved conversations from localStorage
function loadAIChatHistory() {
  try {
    const saved = localStorage.getItem('aiChatHistory');
    return saved ? JSON.parse(saved) : [];
  } catch (e) {
    return [];
  }
}

// Save conversations to localStorage
function saveAIChatHistory(conversations) {
  try {
    localStorage.setItem('aiChatHistory', JSON.stringify(conversations));
  } catch (e) {
    console.error('Failed to save chat history:', e);
  }
}

// Save current conversation
function saveCurrentConversation() {
  if (aiChatMessages.length === 0) return;

  const conversations = loadAIChatHistory();
  const firstUserMsg = aiChatMessages.find(m => m.role === 'user');
  const title = firstUserMsg ? firstUserMsg.content.substring(0, 50) + (firstUserMsg.content.length > 50 ? '...' : '') : 'New Conversation';

  if (currentConversationId) {
    // Update existing conversation
    const index = conversations.findIndex(c => c.id === currentConversationId);
    if (index !== -1) {
      conversations[index].messages = [...aiChatMessages];
      conversations[index].updatedAt = new Date().toISOString();
    }
  } else {
    // Create new conversation
    currentConversationId = 'conv_' + Date.now();
    conversations.unshift({
      id: currentConversationId,
      title: title,
      messages: [...aiChatMessages],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });
  }

  // Keep only last 50 conversations
  saveAIChatHistory(conversations.slice(0, 50));
}

// Load a specific conversation
function loadConversation(conversationId) {
  const conversations = loadAIChatHistory();
  const conversation = conversations.find(c => c.id === conversationId);

  if (conversation) {
    aiChatMessages = [...conversation.messages];
    currentConversationId = conversationId;
    aiChatHistorySidebarOpen = false;

    const viewsContainer = document.getElementById('viewsContainer');
    if (viewsContainer) {
      viewsContainer.innerHTML = renderAIChatView();
    }
  }
}

// Delete a conversation
function deleteConversation(conversationId, event) {
  event.stopPropagation();

  const conversations = loadAIChatHistory();
  const filtered = conversations.filter(c => c.id !== conversationId);
  saveAIChatHistory(filtered);

  if (currentConversationId === conversationId) {
    currentConversationId = null;
  }

  // Re-render sidebar
  const sidebar = document.getElementById('aiHistorySidebar');
  if (sidebar) {
    sidebar.innerHTML = renderHistorySidebarContent();
  }
}

// Toggle history sidebar
function toggleAIChatHistorySidebar() {
  aiChatHistorySidebarOpen = !aiChatHistorySidebarOpen;

  const sidebar = document.getElementById('aiHistorySidebar');
  const overlay = document.getElementById('aiHistoryOverlay');

  if (sidebar && overlay) {
    if (aiChatHistorySidebarOpen) {
      sidebar.classList.add('open');
      overlay.classList.add('show');
    } else {
      sidebar.classList.remove('open');
      overlay.classList.remove('show');
    }
  }
}

// Render sidebar content
function renderHistorySidebarContent() {
  const conversations = loadAIChatHistory();

  if (conversations.length === 0) {
    return `
      <div class="ai-history-empty">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
        </svg>
        <p>No conversations yet</p>
        <span>Start a new chat to see your history here</span>
      </div>
    `;
  }

  return conversations.map(conv => {
    const date = new Date(conv.updatedAt);
    const timeAgo = getTimeAgo(date);
    const isActive = conv.id === currentConversationId;

    return `
      <div class="ai-history-item ${isActive ? 'active' : ''}" onclick="loadConversation('${conv.id}')">
        <div class="ai-history-item-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
          </svg>
        </div>
        <div class="ai-history-item-content">
          <div class="ai-history-item-title">${escapeHtml(conv.title)}</div>
          <div class="ai-history-item-meta">${conv.messages.length} messages · ${timeAgo}</div>
        </div>
        <button class="ai-history-item-delete" onclick="deleteConversation('${conv.id}', event)" title="Delete conversation">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          </svg>
        </button>
      </div>
    `;
  }).join('');
}

// Helper for time ago
function getTimeAgo(date) {
  const now = new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);

  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;
  return date.toLocaleDateString();
}

function openAIChatView(initialMessage) {
  aiChatMessages = [];
  aiGeneratedContent = null;
  currentConversationId = null; // Start fresh conversation
  aiChatHistorySidebarOpen = false;

  if (initialMessage) {
    aiChatMessages.push({
      role: 'user',
      content: initialMessage,
      timestamp: new Date()
    });
    saveCurrentConversation();
  }

  // Render the chat view
  const viewsContainer = document.getElementById('viewsContainer');
  if (viewsContainer) {
    viewsContainer.innerHTML = renderAIChatView();

    // Focus the input
    const chatInput = document.getElementById('aiChatInput');
    if (chatInput) chatInput.focus();

    // If there's an initial message, send it
    if (initialMessage) {
      processAIMessage(initialMessage);
    }
  }
}

function renderAIChatView() {
  return `
    <div class="ai-clean-chat">
      <!-- Chat Header -->
      <div class="ai-clean-chat-header">
        <button class="ai-clean-back-btn" onclick="goBackToAILanding()" title="Back">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
            <path d="M19 12H5M12 19l-7-7 7-7"/>
          </svg>
        </button>
        <span class="ai-clean-chat-title">AI Assistant</span>
      </div>

      <!-- Messages -->
      <div class="ai-clean-messages" id="aiChatMessages">
        ${renderAIChatMessages()}
        ${aiChatIsLoading ? `
          <div class="ai-clean-loading">
            <div class="ai-clean-loading-dot"></div>
            <div class="ai-clean-loading-dot"></div>
            <div class="ai-clean-loading-dot"></div>
          </div>
        ` : ''}
      </div>

      <!-- Input -->
      <div class="ai-clean-chat-input-area">
        <div class="ai-clean-input-box">
          <input
            type="text"
            class="ai-clean-input"
            id="aiChatInput"
            placeholder="Type your message..."
            onkeydown="handleAIChatInputKeydown(event)"
            ${aiChatIsLoading ? 'disabled' : ''}
          />
          <button class="ai-clean-send-btn" onclick="sendAIChatMessage()" ${aiChatIsLoading ? 'disabled' : ''}>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
              <path d="M5 12h14M12 5l7 7-7 7"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  `;
}

function renderAIChatMessages() {
  if (aiChatMessages.length === 0) {
    return `
      <div class="ai-clean-empty">
        <p>Start a conversation</p>
      </div>
    `;
  }

  return aiChatMessages.map((msg, index) => {
    if (msg.role === 'user') {
      return `
        <div class="ai-clean-msg ai-clean-msg-user">
          <div class="ai-clean-bubble-user">${escapeHtml(msg.content)}</div>
        </div>
      `;
    } else {
      return `
        <div class="ai-clean-msg ai-clean-msg-assistant">
          <div class="ai-clean-bubble-assistant">
            <div class="ai-clean-content">${formatAIResponse(msg.content)}</div>
            <div class="ai-clean-actions">
              <button class="ai-clean-action-btn" onclick="copyAIMessage(${index})" title="Copy">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                  <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                  <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                </svg>
              </button>
              <button class="ai-clean-action-btn" onclick="regenerateAIMessage(${index})" title="Regenerate">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                  <path d="M1 4v6h6"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                </svg>
              </button>
            </div>
          </div>
        </div>
      `;
    }
  }).join('');
}

function formatAIResponse(content) {
  // Convert markdown-style formatting to HTML
  let formatted = escapeHtml(content);

  // Bold text **text**
  formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

  // Italic text *text*
  formatted = formatted.replace(/\*(.*?)\*/g, '<em>$1</em>');

  // Headers with emoji (💡 Agent Ideas)
  formatted = formatted.replace(/^(💡|🎯|📋|✨|🚀)\s*(.+)$/gm, '<h3 class="ai-response-heading"><span class="ai-heading-icon">$1</span> $2</h3>');

  // Numbered lists
  formatted = formatted.replace(/^(\d+)\.\s+\*\*(.+?)\*\*\s*[-–—]\s*(.+)$/gm,
    '<div class="ai-list-item"><span class="ai-list-number">$1.</span><div><strong>$2</strong> — $3</div></div>');

  // Simple numbered lists
  formatted = formatted.replace(/^(\d+)\.\s+(.+)$/gm,
    '<div class="ai-list-item"><span class="ai-list-number">$1.</span><div>$2</div></div>');

  // Line breaks
  formatted = formatted.replace(/\n\n/g, '</p><p>');
  formatted = formatted.replace(/\n/g, '<br>');

  return `<p>${formatted}</p>`;
}

function renderFollowUps(followUps) {
  if (!followUps || followUps.length === 0) return '';

  return `
    <div class="ai-chat-followups">
      <span class="ai-chat-followups-label">Follow ups</span>
      <div class="ai-chat-followups-list">
        ${followUps.map(fu => `
          <button class="ai-chat-followup-btn" onclick="sendFollowUp('${escapeHtml(fu).replace(/'/g, "\\'")}')">
            ${escapeHtml(fu)}
          </button>
        `).join('')}
      </div>
    </div>
  `;
}

function renderGeneratedContentPanel() {
  if (!aiGeneratedContent) return '';

  return `
    <div class="ai-generated-panel">
      <div class="ai-generated-header">
        <div class="ai-generated-title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
            <polyline points="14 2 14 8 20 8"/>
          </svg>
          <span>${aiGeneratedContent.title || 'Generated Content'}</span>
        </div>
        <div class="ai-generated-actions">
          <button class="ai-generated-action-btn" onclick="copyGeneratedContent()" title="Copy all">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
            </svg>
            <span>Copy</span>
          </button>
          <button class="ai-generated-close-btn" onclick="closeGeneratedPanel()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>
      </div>
      <div class="ai-generated-content" id="aiGeneratedContent">
        ${formatGeneratedContent(aiGeneratedContent.content, aiGeneratedContent.type)}
      </div>
    </div>
  `;
}

function formatGeneratedContent(content, type) {
  if (type === 'code') {
    return `<pre class="ai-generated-code"><code>${escapeHtml(content)}</code></pre>`;
  }

  // Format as professional document
  let formatted = escapeHtml(content);

  // Headers
  formatted = formatted.replace(/^###\s+(.+)$/gm, '<h4 class="ai-doc-h4">$1</h4>');
  formatted = formatted.replace(/^##\s+(.+)$/gm, '<h3 class="ai-doc-h3">$1</h3>');
  formatted = formatted.replace(/^#\s+(.+)$/gm, '<h2 class="ai-doc-h2">$1</h2>');

  // Bold and italic
  formatted = formatted.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  formatted = formatted.replace(/\*(.+?)\*/g, '<em>$1</em>');

  // Paragraphs
  formatted = formatted.replace(/\n\n/g, '</p><p class="ai-doc-paragraph">');
  formatted = formatted.replace(/\n/g, '<br>');

  return `<div class="ai-doc-content"><p class="ai-doc-paragraph">${formatted}</p></div>`;
}

function handleAIChatInputKeydown(event) {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendAIChatMessage();
  }
}

async function sendAIChatMessage() {
  const input = document.getElementById('aiChatInput');
  if (!input || !input.value.trim() || aiChatIsLoading) return;

  const userMessage = input.value.trim();
  input.value = '';

  aiChatMessages.push({
    role: 'user',
    content: userMessage,
    timestamp: new Date()
  });
  saveCurrentConversation();

  updateChatView();
  processAIMessage(userMessage);
}

async function processAIMessage(message) {
  aiChatIsLoading = true;
  updateChatView();
  scrollChatToBottom();

  try {
    // Check if this is a content generation request
    const isGeneration = detectContentGeneration(message);

    const response = await window.callGeminiAPI(message);

    // Parse the response for structured content
    const parsedResponse = parseAIResponse(response, isGeneration);

    aiChatMessages.push({
      role: 'assistant',
      content: parsedResponse.message,
      followUps: parsedResponse.followUps,
      timestamp: new Date()
    });
    saveCurrentConversation();

    // If there's generated content, set it for the right panel
    if (parsedResponse.generatedContent) {
      aiGeneratedContent = parsedResponse.generatedContent;
    }

  } catch (error) {
    aiChatMessages.push({
      role: 'assistant',
      content: 'I apologize, but I encountered an error processing your request. Please try again.',
      timestamp: new Date()
    });
    saveCurrentConversation();
  }

  aiChatIsLoading = false;
  updateChatView();
  scrollChatToBottom();
}

function detectContentGeneration(message) {
  const generationKeywords = ['write', 'essay', 'report', 'code', 'generate', 'create', 'draft', 'compose'];
  const lowerMessage = message.toLowerCase();
  return generationKeywords.some(keyword => lowerMessage.includes(keyword));
}

function parseAIResponse(response, isGeneration) {
  // Basic parsing - in production this would be more sophisticated
  const result = {
    message: response,
    followUps: [],
    generatedContent: null
  };

  // Generate some follow-up suggestions based on context
  if (response.length > 200) {
    result.followUps = [
      'Tell me more about this',
      'Can you summarize the key points?',
      'What are the next steps?'
    ];
  }

  // If this looks like generated content (essay, report, code), add to right panel
  if (isGeneration && response.length > 500) {
    const isCode = response.includes('function') || response.includes('const ') || response.includes('import ');
    result.generatedContent = {
      title: isCode ? 'Generated Code' : 'Generated Document',
      type: isCode ? 'code' : 'document',
      content: response
    };
  }

  return result;
}

function updateChatView() {
  const viewsContainer = document.getElementById('viewsContainer');
  if (viewsContainer) {
    viewsContainer.innerHTML = renderAIChatView();
  }
}

function scrollChatToBottom() {
  const messagesContainer = document.getElementById('aiChatMessages');
  if (messagesContainer) {
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }
}

function goBackToAILanding() {
  aiChatMessages = [];
  aiGeneratedContent = null;
  aiChatIsLoading = false;

  const viewsContainer = document.getElementById('viewsContainer');
  if (viewsContainer) {
    viewsContainer.innerHTML = renderAIView();
  }
}

function copyAIMessage(index) {
  const msg = aiChatMessages[index];
  if (msg && msg.content) {
    navigator.clipboard.writeText(msg.content).then(() => {
      showToast('Message copied to clipboard!');
    }).catch(() => {
      showToast('Failed to copy message');
    });
  }
}

function copyGeneratedContent() {
  if (aiGeneratedContent && aiGeneratedContent.content) {
    navigator.clipboard.writeText(aiGeneratedContent.content).then(() => {
      showToast('Content copied to clipboard!');
    }).catch(() => {
      showToast('Failed to copy content');
    });
  }
}

function closeGeneratedPanel() {
  aiGeneratedContent = null;
  updateChatView();
}

function regenerateAIMessage(index) {
  // Find the user message before this assistant message
  if (index > 0 && aiChatMessages[index - 1].role === 'user') {
    const userMessage = aiChatMessages[index - 1].content;
    // Remove the current assistant message
    aiChatMessages.splice(index, 1);
    // Regenerate
    processAIMessage(userMessage);
  }
}

function likeAIMessage(index) {
  showToast('Thanks for your feedback! 👍');
}

function dislikeAIMessage(index) {
  showToast('Thanks for your feedback. We\'ll improve! 👎');
}

function sendFollowUp(followUp) {
  const input = document.getElementById('aiChatInput');
  if (input) {
    input.value = followUp;
    sendAIChatMessage();
  }
}

// Expose functions globally
window.renderAIView = renderAIView;
window.renderAIChatView = renderAIChatView;
window.openAIChatView = openAIChatView;
window.goBackToAILanding = goBackToAILanding;
window.sendAIAgentPrompt = sendAIAgentPrompt;
window.sendAIChatMessage = sendAIChatMessage;
window.showAIAddOptions = showAIAddOptions;
window.handleAIInputKeydown = handleAIInputKeydown;
window.handleAIChatInputKeydown = handleAIChatInputKeydown;
window.setAIPrompt = setAIPrompt;
window.sendSuggestedPrompt = sendSuggestedPrompt;
window.copyAIMessage = copyAIMessage;
window.copyGeneratedContent = copyGeneratedContent;
window.closeGeneratedPanel = closeGeneratedPanel;
window.regenerateAIMessage = regenerateAIMessage;
window.likeAIMessage = likeAIMessage;
window.dislikeAIMessage = dislikeAIMessage;
window.sendFollowUp = sendFollowUp;

// ============================================
// TIME ZONE SUPPORT
// ============================================
let selectedTimezone = localStorage.getItem('layerTimezone') || Intl.DateTimeFormat().resolvedOptions().timeZone;
let secondaryTimezone = localStorage.getItem('layerSecondaryTimezone') || null;

const COMMON_TIMEZONES = [
  { value: 'America/New_York', label: 'Eastern Time (ET)', offset: -5 },
  { value: 'America/Chicago', label: 'Central Time (CT)', offset: -6 },
  { value: 'America/Denver', label: 'Mountain Time (MT)', offset: -7 },
  { value: 'America/Los_Angeles', label: 'Pacific Time (PT)', offset: -8 },
  { value: 'America/Phoenix', label: 'Arizona (MST)', offset: -7 },
  { value: 'America/Anchorage', label: 'Alaska Time (AKT)', offset: -9 },
  { value: 'Pacific/Honolulu', label: 'Hawaii Time (HST)', offset: -10 },
  { value: 'Europe/London', label: 'London (GMT/BST)', offset: 0 },
  { value: 'Europe/Paris', label: 'Paris (CET)', offset: 1 },
  { value: 'Europe/Berlin', label: 'Berlin (CET)', offset: 1 },
  { value: 'Europe/Moscow', label: 'Moscow (MSK)', offset: 3 },
  { value: 'Asia/Dubai', label: 'Dubai (GST)', offset: 4 },
  { value: 'Asia/Kolkata', label: 'India (IST)', offset: 5.5 },
  { value: 'Asia/Bangkok', label: 'Bangkok (ICT)', offset: 7 },
  { value: 'Asia/Singapore', label: 'Singapore (SGT)', offset: 8 },
  { value: 'Asia/Tokyo', label: 'Tokyo (JST)', offset: 9 },
  { value: 'Australia/Sydney', label: 'Sydney (AEST)', offset: 10 },
  { value: 'Pacific/Auckland', label: 'Auckland (NZST)', offset: 12 },
  { value: 'UTC', label: 'UTC', offset: 0 }
];

function getCurrentTimezoneLabel() {
  const tz = COMMON_TIMEZONES.find(t => t.value === selectedTimezone);
  if (tz) return tz.label.split(' ')[0];

  // Fallback: calculate offset
  const offset = -(new Date().getTimezoneOffset() / 60);
  return `UTC${offset >= 0 ? '+' : ''}${offset}`;
}

function openTimeZoneModal() {
  const currentTz = selectedTimezone;
  const secondTz = secondaryTimezone;

  const content = `
    <div class="timezone-modal-content">
      <div class="form-group">
        <label class="form-label">Primary Time Zone</label>
        <select id="primaryTimezoneSelect" class="form-select form-select-large">
          ${COMMON_TIMEZONES.map(tz => `
            <option value="${tz.value}" ${tz.value === currentTz ? 'selected' : ''}>
              ${tz.label} (UTC${tz.offset >= 0 ? '+' : ''}${tz.offset})
            </option>
          `).join('')}
        </select>
        <p class="form-hint">Events will be displayed in this time zone</p>
      </div>
      
      <div class="form-group">
        <label class="form-label">
          <input type="checkbox" id="showSecondaryTz" ${secondTz ? 'checked' : ''} onchange="toggleSecondaryTimezone()">
          Show secondary time zone
        </label>
      </div>
      
      <div class="form-group secondary-tz-group" id="secondaryTzGroup" style="display: ${secondTz ? 'block' : 'none'};">
        <label class="form-label">Secondary Time Zone</label>
        <select id="secondaryTimezoneSelect" class="form-select form-select-large">
          ${COMMON_TIMEZONES.map(tz => `
            <option value="${tz.value}" ${tz.value === secondTz ? 'selected' : ''}>
              ${tz.label} (UTC${tz.offset >= 0 ? '+' : ''}${tz.offset})
            </option>
          `).join('')}
        </select>
        <p class="form-hint">Displayed alongside primary time zone in week/day views</p>
      </div>
      
      <div class="timezone-preview" id="timezonePreview">
        <div class="tz-preview-title">Current time:</div>
        <div class="tz-preview-times" id="tzPreviewTimes"></div>
      </div>
      
      <div class="form-actions">
        <button type="button" class="btn btn-ghost" onclick="closeModal()">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="saveTimezoneSettings()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>
          Save
        </button>
      </div>
    </div>
  `;

  openModal('Time Zone Settings', content);
  updateTimezonePreview();
}

function toggleSecondaryTimezone() {
  const show = document.getElementById('showSecondaryTz').checked;
  document.getElementById('secondaryTzGroup').style.display = show ? 'block' : 'none';
  updateTimezonePreview();
}

function updateTimezonePreview() {
  const primarySelect = document.getElementById('primaryTimezoneSelect');
  const secondarySelect = document.getElementById('secondaryTimezoneSelect');
  const showSecondary = document.getElementById('showSecondaryTz')?.checked;
  const previewEl = document.getElementById('tzPreviewTimes');

  if (!primarySelect || !previewEl) return;

  const now = new Date();
  const primaryTz = primarySelect.value;
  const primaryTime = now.toLocaleTimeString('en-US', {
    timeZone: primaryTz,
    hour: '2-digit',
    minute: '2-digit',
    hour12: true
  });

  let html = `<div class="tz-preview-item primary"><span class="tz-label">${primaryTz.split('/')[1]?.replace('_', ' ') || primaryTz}</span><span class="tz-time">${primaryTime}</span></div>`;

  if (showSecondary && secondarySelect) {
    const secondaryTz = secondarySelect.value;
    const secondaryTime = now.toLocaleTimeString('en-US', {
      timeZone: secondaryTz,
      hour: '2-digit',
      minute: '2-digit',
      hour12: true
    });
    html += `<div class="tz-preview-item secondary"><span class="tz-label">${secondaryTz.split('/')[1]?.replace('_', ' ') || secondaryTz}</span><span class="tz-time">${secondaryTime}</span></div>`;
  }

  previewEl.innerHTML = html;
}

function saveTimezoneSettings() {
  const primarySelect = document.getElementById('primaryTimezoneSelect');
  const secondarySelect = document.getElementById('secondaryTimezoneSelect');
  const showSecondary = document.getElementById('showSecondaryTz')?.checked;

  if (primarySelect) {
    selectedTimezone = primarySelect.value;
    localStorage.setItem('layerTimezone', selectedTimezone);
  }

  if (showSecondary && secondarySelect) {
    secondaryTimezone = secondarySelect.value;
    localStorage.setItem('layerSecondaryTimezone', secondaryTimezone);
  } else {
    secondaryTimezone = null;
    localStorage.removeItem('layerSecondaryTimezone');
  }

  closeModal();
  showToast('Time zone settings saved!');
  renderCurrentView();
}

function convertTimeToTimezone(time24, fromTz, toTz) {
  if (!time24) return '';
  const [hours, minutes] = time24.split(':').map(Number);
  const date = new Date();
  date.setHours(hours, minutes, 0, 0);

  return date.toLocaleTimeString('en-US', {
    timeZone: toTz,
    hour: '2-digit',
    minute: '2-digit',
    hour12: true
  });
}

// ============================================
// SMART SCHEDULING - Find Available Times
// ============================================
function openSmartScheduleModal() {
  const events = loadCalendarEvents();
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const content = `
    <div class="smart-schedule-modal">
      <div class="smart-schedule-header">
        <div class="smart-schedule-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
          </svg>
        </div>
        <div>
          <h3>Find Available Time</h3>
          <p>Discover open slots in your schedule</p>
        </div>
      </div>
      
      <div class="smart-schedule-options">
        <div class="form-group">
          <label class="form-label">Meeting Duration</label>
          <div class="duration-chips">
            <button type="button" class="duration-chip active" data-duration="30" onclick="setSmartDuration(30)">30 min</button>
            <button type="button" class="duration-chip" data-duration="60" onclick="setSmartDuration(60)">1 hour</button>
            <button type="button" class="duration-chip" data-duration="90" onclick="setSmartDuration(90)">1.5 hours</button>
            <button type="button" class="duration-chip" data-duration="120" onclick="setSmartDuration(120)">2 hours</button>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label">Date Range</label>
          <div class="date-range-inputs">
            <input type="date" id="smartStartDate" class="form-input" value="${today.toISOString().split('T')[0]}" onchange="findAvailableSlots()">
            <span class="date-separator">to</span>
            <input type="date" id="smartEndDate" class="form-input" value="${new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]}" onchange="findAvailableSlots()">
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label">Working Hours</label>
          <div class="time-range-inputs">
            <select id="smartStartHour" class="form-select" onchange="findAvailableSlots()">
              ${Array.from({ length: 24 }, (_, i) => {
    const h = i < 10 ? '0' + i : i;
    const label = i === 0 ? '12 AM' : i < 12 ? `${i} AM` : i === 12 ? '12 PM' : `${i - 12} PM`;
    return `<option value="${h}:00" ${i === 9 ? 'selected' : ''}>${label}</option>`;
  }).join('')}
            </select>
            <span class="time-separator">to</span>
            <select id="smartEndHour" class="form-select" onchange="findAvailableSlots()">
              ${Array.from({ length: 24 }, (_, i) => {
    const h = i < 10 ? '0' + i : i;
    const label = i === 0 ? '12 AM' : i < 12 ? `${i} AM` : i === 12 ? '12 PM' : `${i - 12} PM`;
    return `<option value="${h}:00" ${i === 17 ? 'selected' : ''}>${label}</option>`;
  }).join('')}
            </select>
          </div>
        </div>
      </div>
      
      <div class="available-slots-section">
        <div class="slots-header">
          <span class="slots-title">Available Time Slots</span>
          <span class="slots-count" id="slotsCount">Finding slots...</span>
        </div>
        <div class="available-slots-list" id="availableSlotsList">
          <div class="slots-loading">
            <div class="loading-spinner"></div>
            <span>Analyzing your schedule...</span>
          </div>
        </div>
      </div>
      
      <div class="form-actions">
        <button type="button" class="btn btn-ghost" onclick="closeModal()">Close</button>
      </div>
    </div>
  `;

  openModal('Smart Scheduling', content, 'modal-large');

  // Find slots after modal renders
  setTimeout(() => findAvailableSlots(), 100);
}

let smartScheduleDuration = 30;

function setSmartDuration(duration) {
  smartScheduleDuration = duration;
  document.querySelectorAll('.duration-chip').forEach(chip => {
    chip.classList.toggle('active', parseInt(chip.dataset.duration) === duration);
  });
  findAvailableSlots();
}

function findAvailableSlots() {
  const events = loadCalendarEvents();
  const startDateEl = document.getElementById('smartStartDate');
  const endDateEl = document.getElementById('smartEndDate');
  const startHourEl = document.getElementById('smartStartHour');
  const endHourEl = document.getElementById('smartEndHour');
  const slotsContainer = document.getElementById('availableSlotsList');
  const slotsCount = document.getElementById('slotsCount');

  if (!startDateEl || !endDateEl || !startHourEl || !endHourEl) return;

  const startDate = new Date(startDateEl.value);
  const endDate = new Date(endDateEl.value);
  const workStartHour = parseInt(startHourEl.value.split(':')[0]);
  const workEndHour = parseInt(endHourEl.value.split(':')[0]);
  const duration = smartScheduleDuration;

  const slots = [];
  const currentDate = new Date(startDate);

  while (currentDate <= endDate) {
    const dateStr = currentDate.toISOString().split('T')[0];
    const dayEvents = events.filter(e => e.date === dateStr && e.time);

    // Skip weekends optionally
    const dayOfWeek = currentDate.getDay();

    // Find busy time ranges
    const busyRanges = dayEvents.map(e => {
      const [startH, startM] = (e.time || '00:00').split(':').map(Number);
      const [endH, endM] = (e.endTime || e.time || '00:00').split(':').map(Number);
      return {
        start: startH * 60 + startM,
        end: e.endTime ? (endH * 60 + endM) : (startH * 60 + startM + 60)
      };
    }).sort((a, b) => a.start - b.start);

    // Find free slots
    let currentMinute = workStartHour * 60;
    const endMinute = workEndHour * 60;

    while (currentMinute + duration <= endMinute) {
      const slotEnd = currentMinute + duration;

      // Check if slot overlaps with any event
      const hasConflict = busyRanges.some(range =>
        (currentMinute < range.end && slotEnd > range.start)
      );

      if (!hasConflict) {
        const startTime = `${Math.floor(currentMinute / 60).toString().padStart(2, '0')}:${(currentMinute % 60).toString().padStart(2, '0')}`;
        const endTime = `${Math.floor(slotEnd / 60).toString().padStart(2, '0')}:${(slotEnd % 60).toString().padStart(2, '0')}`;

        slots.push({
          date: dateStr,
          startTime,
          endTime,
          dayName: currentDate.toLocaleDateString('en-US', { weekday: 'short' }),
          dayNum: currentDate.getDate(),
          monthName: currentDate.toLocaleDateString('en-US', { month: 'short' })
        });

        // Jump to next slot (don't show consecutive slots)
        currentMinute = slotEnd;
      } else {
        // Find end of conflicting event
        const conflictingEvent = busyRanges.find(range =>
          (currentMinute < range.end && currentMinute + duration > range.start)
        );
        if (conflictingEvent) {
          currentMinute = conflictingEvent.end;
        } else {
          currentMinute += 30;
        }
      }
    }

    currentDate.setDate(currentDate.getDate() + 1);
  }

  // Render slots (limit to first 20)
  const displaySlots = slots.slice(0, 20);
  slotsCount.textContent = `${slots.length} slots found`;

  if (displaySlots.length === 0) {
    slotsContainer.innerHTML = `
      <div class="no-slots-message">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <path d="M16 16s-1.5-2-4-2-4 2-4 2"/>
          <line x1="9" y1="9" x2="9.01" y2="9"/>
          <line x1="15" y1="9" x2="15.01" y2="9"/>
        </svg>
        <p>No available slots found in this date range.</p>
        <span>Try expanding the date range or adjusting working hours.</span>
      </div>
    `;
    return;
  }

  slotsContainer.innerHTML = displaySlots.map(slot => `
    <div class="available-slot-card" onclick="selectSmartSlot('${slot.date}', '${slot.startTime}', '${slot.endTime}')">
      <div class="slot-date-badge">
        <span class="slot-day-name">${slot.dayName}</span>
        <span class="slot-day-num">${slot.dayNum}</span>
        <span class="slot-month">${slot.monthName}</span>
      </div>
      <div class="slot-time-info">
        <span class="slot-time-range">${formatTime12h(slot.startTime)} - ${formatTime12h(slot.endTime)}</span>
        <span class="slot-duration">${smartScheduleDuration} min</span>
      </div>
      <button class="slot-select-btn" onclick="event.stopPropagation(); selectSmartSlot('${slot.date}', '${slot.startTime}', '${slot.endTime}')">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
        Schedule
      </button>
    </div>
  `).join('');
}

function selectSmartSlot(date, startTime, endTime) {
  closeModal();
  openAdvancedEventModal(date, startTime);

  // Pre-fill end time after modal opens
  setTimeout(() => {
    const endTimeSelect = document.querySelector('select[name="endTime"]');
    if (endTimeSelect) {
      endTimeSelect.value = endTime;
    }
  }, 100);
}

// Mobile Swipe Support for Calendar
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;

function initCalendarSwipe() {
  const container = document.querySelector('.advanced-schedule-container');
  if (!container) return;
  
  container.addEventListener('touchstart', handleTouchStart, false);
  container.addEventListener('touchend', handleTouchEnd, false);
}

function handleTouchStart(event) {
  touchStartX = event.changedTouches[0].screenX;
  touchStartY = event.changedTouches[0].screenY;
}

function handleTouchEnd(event) {
  touchEndX = event.changedTouches[0].screenX;
  touchEndY = event.changedTouches[0].screenY;
  handleSwipeGesture();
}

function handleSwipeGesture() {
  const minSwipeDistance = 50;
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  
  // Check if horizontal swipe is dominant
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > minSwipeDistance) {
    if (dx > 0) {
      // Swipe right - go to previous
      navigateSchedulePrev();
    } else {
      // Swipe left - go to next
      navigateScheduleNext();
    }
  }
}

// Enhanced goToScheduleToday - scroll to current time
function goToScheduleToday() {
  scheduleCurrentDate = new Date();
  scheduleSelectedDate = new Date();
  renderCurrentView();
  // Reinitialize swipe functionality after navigation
  setTimeout(() => {
    initCalendarSwipe();
  }, 100);
  
  // Scroll to current time in day/week view
  setTimeout(() => {
    const now = new Date();
    const currentHour = now.getHours();
    const scrollContainer = document.querySelector('.week-grid-scroll, .day-view-grid-scroll');

    if (scrollContainer) {
      // Each hour is 80px, starting from 6 AM
      const hourOffset = currentHour >= 6 ? currentHour - 6 : currentHour + 18;
      const scrollPosition = Math.max(0, (hourOffset * 80) - 100);
      scrollContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
    }
  }, 100);
}

/* ============================================
   Layer - Timeline V2 - Linear-Style Professional Rebuild
   A complete, clean implementation inspired by Linear.app
   ============================================ */

// ============================================
// Timeline V2 State
// ============================================
const TimelineV2 = {
  // View settings
  viewMode: 'week', // 'day', 'week', 'month', 'quarter'
  currentDate: new Date(),
  zoom: 1, // 0.5 - 2
  filter: 'active', // 'active', 'closed', 'all'

  // Interaction state
  isDragging: false,
  isResizing: false,
  dragTarget: null,
  dragStartX: 0,
  dragOriginalLeft: 0,
  dragOriginalWidth: 0,
  resizeDirection: null,

  // Scroll position (preserved across re-renders)
  scrollLeft: 0,
  scrollTop: 0,

  // Current project context
  projectIndex: null,

  // Cell size (base, adjusted by zoom)
  get cellWidth() { return 42 * this.zoom; },
  rowHeight: 76,

  // Date range
  startDate: null,
  endDate: null,
  dates: []
};

// ============================================
// Utility Functions
// ============================================

function tlv2_daysBetween(date1, date2) {
  const d1 = new Date(date1);
  const d2 = new Date(date2);
  d1.setHours(0, 0, 0, 0);
  d2.setHours(0, 0, 0, 0);
  return Math.round((d2 - d1) / (1000 * 60 * 60 * 24));
}

function tlv2_formatDate(date, format = 'short') {
  const d = new Date(date);
  if (format === 'short') {
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  } else if (format === 'full') {
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  }
  return d.toISOString().split('T')[0];
}

// Format a date as YYYY-MM-DD using *local* calendar values (avoids timezone day-shift)
function tlv2_formatISODateLocal(date) {
  const d = new Date(date);
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  const day = String(d.getDate()).padStart(2, '0');
  return `${y}-${m}-${day}`;
}

// Parse YYYY-MM-DD as a local date (not UTC)
function tlv2_parseISODateLocal(dateStr) {
  if (!dateStr) return null;
  const parts = String(dateStr).split('T')[0].split('-');
  if (parts.length !== 3) return new Date(dateStr);
  const y = parseInt(parts[0], 10);
  const m = parseInt(parts[1], 10) - 1;
  const d = parseInt(parts[2], 10);
  const out = new Date(y, m, d);
  out.setHours(0, 0, 0, 0);
  return out;
}

function tlv2_shiftISODateLocal(dateStr, daysDelta) {
  const d = tlv2_parseISODateLocal(dateStr);
  if (!d) return dateStr;
  d.setDate(d.getDate() + daysDelta);
  return tlv2_formatISODateLocal(d);
}

function tlv2_getColumnColor(title) {
  const t = (title || '').toLowerCase();
  if (t.includes('done') || t.includes('complete')) return '#22c55e';
  if (t.includes('progress') || t.includes('doing') || t.includes('active')) return '#3b82f6';
  if (t.includes('review') || t.includes('test')) return '#8b5cf6';
  if (t.includes('blocked') || t.includes('stuck')) return '#ef4444';
  if (t.includes('todo') || t.includes('backlog')) return '#71717a';
  return '#52525b';
}

// Predefined color palette for column bars
const TLV2_COLORS = [
  { name: 'Gray', value: '#71717a' },
  { name: 'Red', value: '#ef4444' },
  { name: 'Orange', value: '#f97316' },
  { name: 'Amber', value: '#f59e0b' },
  { name: 'Yellow', value: '#eab308' },
  { name: 'Lime', value: '#84cc16' },
  { name: 'Green', value: '#22c55e' },
  { name: 'Emerald', value: '#10b981' },
  { name: 'Teal', value: '#14b8a6' },
  { name: 'Cyan', value: '#06b6d4' },
  { name: 'Sky', value: '#0ea5e9' },
  { name: 'Blue', value: '#3b82f6' },
  { name: 'Indigo', value: '#6366f1' },
  { name: 'Violet', value: '#8b5cf6' },
  { name: 'Purple', value: '#a855f7' },
  { name: 'Fuchsia', value: '#d946ef' },
  { name: 'Pink', value: '#ec4899' },
  { name: 'Rose', value: '#f43f5e' },
];

// ============================================
// Date Range Calculation
// ============================================

function tlv2_calculateDateRange(project) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let minDate = new Date(today);
  let maxDate = new Date(today);

  // Calculate padding based on view mode
  const paddings = {
    'day': { before: 3, after: 14 },
    'week': { before: 7, after: 28 },
    'month': { before: 14, after: 60 },
    'quarter': { before: 30, after: 120 }
  };

  const padding = paddings[TimelineV2.viewMode] || paddings.week;

  minDate.setDate(minDate.getDate() - padding.before);
  maxDate.setDate(maxDate.getDate() + padding.after);

  // Extend range based on task dates
  if (project && project.columns) {
    project.columns.forEach(col => {
      // Check column-level dates
      if (col.timelineStart) {
        const colStart = new Date(col.timelineStart);
        if (colStart < minDate) minDate = new Date(colStart);
      }
      if (col.timelineEnd) {
        const colEnd = new Date(col.timelineEnd);
        if (colEnd > maxDate) maxDate = new Date(colEnd);
      }

      // Check task dates
      (col.tasks || []).forEach(task => {
        if (task.startDate) {
          const start = new Date(task.startDate);
          if (start < minDate) minDate = new Date(start);
        }
        if (task.dueDate || task.endDate) {
          const end = new Date(task.dueDate || task.endDate);
          if (end > maxDate) maxDate = new Date(end);
        }
      });
    });
  }

  // Add padding
  minDate.setDate(minDate.getDate() - 5);
  maxDate.setDate(maxDate.getDate() + 10);

  // Generate dates array
  const dates = [];
  const current = new Date(minDate);
  while (current <= maxDate) {
    dates.push(new Date(current));
    current.setDate(current.getDate() + 1);
  }

  TimelineV2.startDate = minDate;
  TimelineV2.endDate = maxDate;
  TimelineV2.dates = dates;

  return { startDate: minDate, endDate: maxDate, dates };
}

// ============================================
// Main Render Function
// ============================================

function renderTimelineV2(projectIndex, container) {
  TimelineV2.projectIndex = projectIndex;

  // Preserve scroll position
  const prevWrapper = document.getElementById('tlv2GanttWrapper');
  if (prevWrapper) {
    TimelineV2.scrollLeft = prevWrapper.scrollLeft;
    TimelineV2.scrollTop = prevWrapper.scrollTop;
  }

  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  // Calculate date range
  const { dates, startDate } = tlv2_calculateDateRange(project);

  // Build column data
  const columns = (project.columns || []).map((col, idx) => {
    const tasks = col.tasks || [];
    let minDate = col.timelineStart ? new Date(col.timelineStart) : null;
    let maxDate = col.timelineEnd ? new Date(col.timelineEnd) : null;

    // Expand range based on task dates
    tasks.forEach(t => {
      const start = t.startDate ? new Date(t.startDate) : null;
      const end = t.endDate || t.dueDate ? new Date(t.endDate || t.dueDate) : start;

      if (start && (!minDate || start < minDate)) minDate = new Date(start);
      if (end && (!maxDate || end > maxDate)) maxDate = new Date(end);
    });

    return {
      id: `col-${idx}`,
      index: idx,
      title: col.title,
      color: col.color || tlv2_getColumnColor(col.title),
      taskCount: tasks.length,
      completedCount: tasks.filter(t => t.done).length,
      minDate,
      maxDate,
      hasDates: !!(minDate && maxDate),
      dependsOn: col.dependsOn || []
    };
  });

  // Calculate stats
  const allTasks = project.columns.flatMap(c => c.tasks || []);
  const stats = {
    total: allTasks.length,
    completed: allTasks.filter(t => t.done).length,
    inProgress: project.columns.filter(c => c.title.toLowerCase().includes('progress')).flatMap(c => c.tasks || []).length
  };

  const gridWidth = dates.length * TimelineV2.cellWidth;

  container.innerHTML = `
    <div class="timeline-linear" id="tlv2Container">
      <!-- Header -->
      <div class="tl-header">
        <div class="tl-header-left">
          <div class="tl-title">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
              <path d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"/>
            </svg>
            Timeline
          </div>
        </div>
        
        <div class="tl-header-right">
          <div class="tl-view-tabs">
            ${['day', 'week', 'month', 'quarter'].map(mode => `
              <button class="tl-view-tab ${TimelineV2.viewMode === mode ? 'active' : ''}" 
                      onclick="tlv2_setViewMode('${mode}')">${mode.charAt(0).toUpperCase() + mode.slice(1)}</button>
            `).join('')}
          </div>
          
          <div class="tl-nav">
            <button class="tl-today-btn" onclick="tlv2_goToToday()">Today</button>
          </div>
          
          <div class="tl-zoom-controls">
            <button class="tl-zoom-btn" onclick="tlv2_zoom(-0.25)" title="Zoom out">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/></svg>
            </button>
            <span class="tl-zoom-level">${Math.round(TimelineV2.zoom * 100)}%</span>
            <button class="tl-zoom-btn" onclick="tlv2_zoom(0.25)" title="Zoom in">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
            </button>
          </div>
          
        </div>
      </div>
      
      <!-- Stats Bar -->
      <div class="tl-stats-bar">
        <div class="tl-stat-item">
          <span class="tl-stat-value">${stats.total}</span>
          <span class="tl-stat-label">tasks</span>
        </div>
        <div class="tl-stat-divider"></div>
        <div class="tl-stat-item">
          <span class="tl-stat-value" style="color: #22c55e;">${stats.completed}</span>
          <span class="tl-stat-label">done</span>
        </div>
        <div class="tl-stat-divider"></div>
        <div class="tl-stat-item">
          <span class="tl-stat-value">${stats.total > 0 ? Math.round((stats.completed / stats.total) * 100) : 0}%</span>
          <span class="tl-stat-label">complete</span>
        </div>
      </div>
      
      <!-- Body -->
      <div class="tl-body">
        <!-- Left Panel -->
        <div class="tl-left-panel tl-left-panel-clickup">
          <div class="tl-left-header">
            <span class="tl-left-title">Tasks</span>
            <span class="tl-task-count-badge">${stats.total}</span>
          </div>
          <div class="tl-task-list" id="tlv2TaskList">
            ${tlv2_renderLeftPanel(columns)}
          </div>
        </div>
        
        <!-- Right Panel -->
        <div class="tl-right-panel">
          <!-- Date Header -->
          <div class="tl-date-header">
            <div class="tl-date-header-scroll" id="tlv2DateHeader">
              ${tlv2_renderMonthRow(dates)}
              ${tlv2_renderDayRow(dates)}
            </div>
          </div>
          
          <!-- Gantt Grid -->
          <div class="tl-gantt-wrapper" id="tlv2GanttWrapper" onscroll="tlv2_syncScroll(this)">
            <div class="tl-gantt-grid" id="tlv2GanttGrid" style="width: ${gridWidth}px; min-height: ${columns.length * TimelineV2.rowHeight}px;">
              ${tlv2_renderGanttRows(columns, dates, startDate)}
              ${tlv2_renderTodayLine(dates, startDate)}
              
              <!-- Dependencies SVG -->
              <svg class="tl-dependencies-svg" id="tlv2DepsSvg" 
                   style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible;">
              </svg>
            </div>
          </div>
        </div>
      </div>
      
    </div>
    
    <!-- Premium Kanban Board Section Under Timeline -->
    <div class="tl-kanban-section">
      <div class="tl-kanban-header">
        <div class="tl-kanban-title-group">
          <div class="tl-kanban-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="3" width="7" height="7" rx="1"/>
              <rect x="14" y="3" width="7" height="7" rx="1"/>
              <rect x="3" y="14" width="7" height="7" rx="1"/>
              <rect x="14" y="14" width="7" height="7" rx="1"/>
            </svg>
          </div>
          <h3 class="tl-kanban-title">Task Board</h3>
          <span class="tl-kanban-badge">${project.columns.reduce((acc, col) => acc + (col.tasks || []).length, 0)} tasks</span>
        </div>
        <div class="tl-kanban-actions">
          <button class="tl-kanban-add-col-btn" onclick="handleAddColumn(${projectIndex})">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 5v14M5 12h14"/>
            </svg>
            Add Column
          </button>
        </div>
      </div>
      
      <div class="tl-kanban-board">
        ${project.columns.map((column, colIndex) => {
    const tasks = column.tasks || [];
    const completedCount = tasks.filter(t => t.done).length;
    const totalCount = tasks.length;
    const progressPercent = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;
    const columnColor = column.color || tlv2_getColumnColor(column.title);

    return `
          <div class="tl-kanban-column" data-col-index="${colIndex}">
            <div class="tl-kanban-col-header" style="--col-accent: ${columnColor};">
              <div class="tl-kanban-col-indicator" style="background: ${columnColor};"></div>
              <h4 class="tl-kanban-col-title" contenteditable="true" onblur="handleRenameColumn(${projectIndex}, ${colIndex}, this.textContent)">${column.title}</h4>
              <div class="tl-kanban-col-meta">
                <span class="tl-kanban-col-count">${completedCount}/${totalCount}</span>
                <div class="tl-kanban-col-progress">
                  <div class="tl-kanban-col-progress-fill" style="width: ${progressPercent}%; background: ${columnColor};"></div>
                </div>
              </div>
              <button class="tl-kanban-col-menu" onclick="handleDeleteColumn(${projectIndex}, ${colIndex})" title="Delete column">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
              </button>
            </div>
            
            <div class="tl-kanban-col-tasks" data-col-index="${colIndex}">
              ${tasks.map((task, taskIndex) => `
                <div class="tl-kanban-task ${task.done ? 'completed' : ''}" draggable="true" data-task-index="${taskIndex}">
                  <label class="tl-kanban-task-check">
                    <input type="checkbox" ${task.done ? 'checked' : ''} onchange="handleToggleProjectTask(${projectIndex}, ${colIndex}, ${taskIndex}, event)">
                    <span class="tl-kanban-checkmark" style="--check-color: ${columnColor};">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                        <path d="M20 6L9 17l-5-5"/>
                      </svg>
                    </span>
                  </label>
                  <span class="tl-kanban-task-title" contenteditable="true" onblur="handleUpdateTaskTitle(${projectIndex}, ${colIndex}, ${taskIndex}, this.textContent)">${task.title}</span>
                  ${task.priority ? `<span class="tl-kanban-task-priority tl-priority-${task.priority}">${task.priority}</span>` : ''}
                  <button class="tl-kanban-task-delete" onclick="handleDeleteProjectTask(${projectIndex}, ${colIndex}, ${taskIndex}, event)" title="Delete task">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                  </button>
                </div>
              `).join('')}
            </div>
            
            <button class="tl-kanban-add-task" onclick="handleAddTaskToColumn(${projectIndex}, ${colIndex}, event)">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14M5 12h14"/>
              </svg>
              <span>Add task</span>
            </button>
          </div>
        `}).join('')}
      </div>
    </div>
  `;

  // Setup interactions
  tlv2_setupInteractions();

  // Restore scroll
  requestAnimationFrame(() => {
    const wrapper = document.getElementById('tlv2GanttWrapper');
    const header = document.getElementById('tlv2DateHeader');
    if (wrapper) {
      wrapper.scrollLeft = TimelineV2.scrollLeft;
      wrapper.scrollTop = TimelineV2.scrollTop;
    }
    if (header) {
      header.scrollLeft = TimelineV2.scrollLeft;
    }
  });

  // Dependencies rendering removed
}

// ============================================
// Left Panel Rendering
// ============================================

function tlv2_renderLeftPanel(columns) {
  if (columns.length === 0) {
    return `
      <div style="padding: 32px 16px; text-align: center; color: var(--muted-foreground);">
        <p style="font-size: 13px;">No columns yet</p>
      </div>
    `;
  }

  // Ultra-minimalistic design - just name + count
  return columns.map(col => {
    return `
      <div class="tl-column-row" data-column-index="${col.index}">
        <div class="tl-column-indicator" style="background: ${col.color};"></div>
        <div class="tl-column-info">
          <span class="tl-column-name">${col.title}</span>
          <span class="tl-column-count">${col.taskCount}</span>
        </div>
      </div>
    `;
  }).join('');
}

// ============================================
// Date Header Rendering
// ============================================

function tlv2_renderMonthRow(dates) {
  const monthGroups = [];
  let currentMonth = null;
  let count = 0;

  dates.forEach((date, idx) => {
    const monthKey = `${date.getFullYear()}-${date.getMonth()}`;
    if (monthKey !== currentMonth) {
      if (currentMonth !== null) {
        monthGroups.push({ month: currentMonth, count, date: dates[idx - count] });
      }
      currentMonth = monthKey;
      count = 1;
    } else {
      count++;
    }
  });

  // Push last group
  if (count > 0) {
    monthGroups.push({ month: currentMonth, count, date: dates[dates.length - count] });
  }

  return `
    <div class="tl-month-row">
      ${monthGroups.map(g => {
    const monthName = g.date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
    const width = g.count * TimelineV2.cellWidth;
    return `<div class="tl-month-cell" style="min-width: ${width}px; width: ${width}px;">${monthName}</div>`;
  }).join('')}
    </div>
  `;
}

function tlv2_renderDayRow(dates) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  return `
    <div class="tl-day-row">
      ${dates.map(date => {
    const isToday = date.toDateString() === today.toDateString();
    const isWeekend = date.getDay() === 0 || date.getDay() === 6;
    const dayName = date.toLocaleDateString('en-US', { weekday: 'short' }).charAt(0);
    const dayNum = date.getDate();

    return `
          <div class="tl-date-col ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" 
               style="min-width: ${TimelineV2.cellWidth}px; width: ${TimelineV2.cellWidth}px;">
            ${isToday ? `<div class="tl-date-num">${dayNum}</div>` : `
              <span class="tl-date-day">${dayName}</span>
              <span class="tl-date-num">${dayNum}</span>
            `}
          </div>
        `;
  }).join('')}
    </div>
  `;
}

// ============================================
// Gantt Grid Rendering
// ============================================

function tlv2_renderGanttRows(columns, dates, startDate) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  return columns.map((col, rowIdx) => {
    // Background cells
    const cells = dates.map(date => {
      const isToday = date.toDateString() === today.toDateString();
      const isWeekend = date.getDay() === 0 || date.getDay() === 6;
      return `<div class="tl-gantt-cell ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" 
                   style="min-width: ${TimelineV2.cellWidth}px;"></div>`;
    }).join('');

    // Bar
    let barHtml = '';
    const progress = col.taskCount > 0 ? Math.round((col.completedCount / col.taskCount) * 100) : 0;

    if (col.hasDates) {
      const startOffset = tlv2_daysBetween(startDate, col.minDate);
      const duration = Math.max(1, tlv2_daysBetween(col.minDate, col.maxDate) + 1);
      const left = Math.max(0, startOffset * TimelineV2.cellWidth);
      const width = Math.max(TimelineV2.cellWidth, duration * TimelineV2.cellWidth - 4);

      barHtml = `
        <div class="tl-task-bar column-bar" 
             data-column-index="${col.index}"
             data-start-date="${col.minDate.toISOString().split('T')[0]}"
             data-end-date="${col.maxDate.toISOString().split('T')[0]}"
             style="left: ${left}px; width: ${width}px; background: linear-gradient(180deg, ${col.color}30 0%, ${col.color}15 100%); border-color: ${col.color}50;"
             onmousedown="tlv2_startDrag(event, ${col.index})"
             ondblclick="tlv2_editColumn(${col.index})"
             oncontextmenu="tlv2_showContextMenu(event, ${col.index})">
          <div class="tl-column-bar-actions">
            <button class="tl-bar-quick-btn" onclick="event.stopPropagation(); tlv2_openColorPicker(event, ${col.index})" title="Change color">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 2a10 10 0 0 1 0 20"/></svg>
            </button>
            <button class="tl-bar-quick-btn" onclick="event.stopPropagation(); tlv2_toggleMilestone(${col.index})" title="Toggle milestone">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L22 12L12 22L2 12Z"/></svg>
            </button>
          </div>
          <span class="tl-bar-icon">${tlv2_getColumnEmoji(col.title)}</span>
          <span class="tl-bar-label" style="color: ${col.color};">${col.title}</span>
          <div class="tl-bar-resize left" onmousedown="tlv2_startResize(event, ${col.index}, 'left')"></div>
          <div class="tl-bar-resize right" onmousedown="tlv2_startResize(event, ${col.index}, 'right')"></div>
        </div>
      `;
    } else {
      // No dates - show dashed placeholder bar at today
      const todayOffset = tlv2_daysBetween(startDate, today);
      const left = Math.max(0, todayOffset * TimelineV2.cellWidth);
      const width = 7 * TimelineV2.cellWidth - 4;

      barHtml = `
        <div class="tl-task-bar column-bar no-dates" 
             data-column-index="${col.index}"
             style="left: ${left}px; width: ${width}px; border-color: ${col.color}50;"
             onmousedown="tlv2_startDrag(event, ${col.index})"
             ondblclick="tlv2_editColumn(${col.index})">
          <span class="tl-bar-icon">${tlv2_getColumnEmoji(col.title)}</span>
          <span class="tl-bar-label" style="color: ${col.color}; opacity: 0.7;">${col.title} (click to set dates)</span>
          <div class="tl-bar-resize left" onmousedown="tlv2_startResize(event, ${col.index}, 'left')"></div>
          <div class="tl-bar-resize right" onmousedown="tlv2_startResize(event, ${col.index}, 'right')"></div>
        </div>
      `;
    }

    return `
      <div class="tl-gantt-row" data-column-index="${col.index}" style="height: ${TimelineV2.rowHeight}px;">
        ${cells}
        ${barHtml}
      </div>
    `;
  }).join('');
}

function tlv2_getColumnEmoji(title) {
  // Returns empty string - no emojis used in timeline
  return '';
}

// ============================================
// Today Line
// ============================================

function tlv2_renderTodayLine(dates, startDate) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const offset = tlv2_daysBetween(startDate, today);
  if (offset < 0 || offset >= dates.length) return '';

  const left = offset * TimelineV2.cellWidth + TimelineV2.cellWidth / 2;

  return `<div class="tl-today-line" style="left: ${left}px;"></div>`;
}

// Dependencies Rendering - REMOVED (feature cleaned)

// ============================================
// Interactions
// ============================================

function tlv2_setupInteractions() {
  // Prevent duplicate listeners across re-renders
  if (TimelineV2._listenersAttached) return;
  TimelineV2._listenersAttached = true;

  document.addEventListener('mousemove', tlv2_handleMouseMove);
  document.addEventListener('mouseup', tlv2_handleMouseUp);
  document.addEventListener('keydown', tlv2_handleKeydown);
}

function tlv2_startDrag(event, columnIndex) {
  if (event.target.classList.contains('tl-bar-resize')) return;
  event.preventDefault();

  const bar = event.currentTarget;

  TimelineV2.isDragging = true;
  TimelineV2.dragTarget = bar;
  TimelineV2.dragColumnIndex = columnIndex;
  TimelineV2.dragStartX = event.clientX;
  TimelineV2.dragOriginalLeft = parseInt(bar.style.left) || 0;
  TimelineV2.dragOriginalWidth = parseInt(bar.style.width) || 100;

  bar.classList.add('dragging');
  document.body.style.cursor = 'grabbing';
  document.body.style.userSelect = 'none';
}

function tlv2_startResize(event, columnIndex, direction) {
  event.preventDefault();
  event.stopPropagation();

  const bar = event.target.closest('.tl-task-bar');
  if (!bar) return;

  TimelineV2.isResizing = true;
  TimelineV2.resizeDirection = direction;
  TimelineV2.dragTarget = bar;
  TimelineV2.dragColumnIndex = columnIndex;
  TimelineV2.dragStartX = event.clientX;
  TimelineV2.dragOriginalLeft = parseInt(bar.style.left) || 0;
  TimelineV2.dragOriginalWidth = parseInt(bar.style.width) || 100;

  bar.classList.add('resizing');
  document.body.style.cursor = 'ew-resize';
  document.body.style.userSelect = 'none';
}

function tlv2_handleMouseMove(event) {
  if (!TimelineV2.isDragging && !TimelineV2.isResizing) return;

  const deltaX = event.clientX - TimelineV2.dragStartX;
  const daysDelta = Math.round(deltaX / TimelineV2.cellWidth);

  // Minimum width is 1 day (1 cell)
  const minWidth = TimelineV2.cellWidth;

  if (TimelineV2.isDragging) {
    const newLeft = TimelineV2.dragOriginalLeft + (daysDelta * TimelineV2.cellWidth);
    TimelineV2.dragTarget.style.left = `${Math.max(0, newLeft)}px`;
  } else if (TimelineV2.isResizing) {
    if (TimelineV2.resizeDirection === 'right') {
      // Resize from right: adjust width, keep left fixed
      const newWidth = TimelineV2.dragOriginalWidth + (daysDelta * TimelineV2.cellWidth);
      TimelineV2.dragTarget.style.width = `${Math.max(minWidth, newWidth)}px`;
    } else {
      // Resize from left: adjust both left and width
      const potentialWidth = TimelineV2.dragOriginalWidth - (daysDelta * TimelineV2.cellWidth);

      if (potentialWidth >= minWidth) {
        // Normal resize - move left edge, adjust width
        const newLeft = TimelineV2.dragOriginalLeft + (daysDelta * TimelineV2.cellWidth);
        TimelineV2.dragTarget.style.left = `${Math.max(0, newLeft)}px`;
        TimelineV2.dragTarget.style.width = `${potentialWidth}px`;
      } else {
        // Would be too small - clamp to minimum width
        const maxDelta = TimelineV2.dragOriginalWidth - minWidth;
        const newLeft = TimelineV2.dragOriginalLeft + maxDelta;
        TimelineV2.dragTarget.style.left = `${Math.max(0, newLeft)}px`;
        TimelineV2.dragTarget.style.width = `${minWidth}px`;
      }
    }
  }
}

function tlv2_handleMouseUp(event) {
  if (!TimelineV2.isDragging && !TimelineV2.isResizing) return;

  const deltaX = event.clientX - TimelineV2.dragStartX;
  const daysDelta = Math.round(deltaX / TimelineV2.cellWidth);

  if (TimelineV2.dragTarget) {
    TimelineV2.dragTarget.classList.remove('dragging', 'resizing');
  }

  document.body.style.cursor = '';
  document.body.style.userSelect = '';

  // Save changes if moved
  if (daysDelta !== 0) {
    if (TimelineV2.isDragging) {
      tlv2_updateColumnDates(TimelineV2.dragColumnIndex, daysDelta, 'move');
    } else if (TimelineV2.isResizing) {
      tlv2_updateColumnDates(TimelineV2.dragColumnIndex, daysDelta, TimelineV2.resizeDirection);
    }
  }

  // Reset state
  TimelineV2.isDragging = false;
  TimelineV2.isResizing = false;
  TimelineV2.dragTarget = null;
  TimelineV2.resizeDirection = null;
}

function tlv2_updateColumnDates(columnIndex, daysDelta, mode) {
  const projects = loadProjects();
  const project = projects[TimelineV2.projectIndex];
  if (!project || !project.columns[columnIndex]) return;

  const column = project.columns[columnIndex];

  // Always compute the new dates from the bar's *actual* visual position/size.
  // This prevents the bar from snapping back on re-render when tasks already have dates.
  const bar = TimelineV2.dragTarget;
  if (!bar) return;

  const currentLeft = parseInt(bar.style.left) || 0;
  const currentWidth = parseInt(bar.style.width) || TimelineV2.cellWidth;
  const startDayOffset = Math.max(0, Math.round(currentLeft / TimelineV2.cellWidth));
  const durationDays = Math.max(1, Math.round(currentWidth / TimelineV2.cellWidth));

  const newStartDate = new Date(TimelineV2.startDate);
  newStartDate.setDate(newStartDate.getDate() + startDayOffset);
  const newEndDate = new Date(newStartDate);
  newEndDate.setDate(newEndDate.getDate() + durationDays - 1);

  column.timelineStart = tlv2_formatISODateLocal(newStartDate);
  column.timelineEnd = tlv2_formatISODateLocal(newEndDate);

  // IMPORTANT: Persist the change into tasks too, otherwise task dates will override
  // the bar's range on the next render.
  (column.tasks || []).forEach(task => {
    const hasStart = !!task.startDate;
    const endField = task.dueDate ? 'dueDate' : (task.endDate ? 'endDate' : null);

    if (mode === 'move') {
      if (hasStart) task.startDate = tlv2_shiftISODateLocal(task.startDate, daysDelta);
      if (endField) task[endField] = tlv2_shiftISODateLocal(task[endField], daysDelta);
      return;
    }

    if (mode === 'left') {
      // Adjust only the start edge
      if (hasStart) {
        task.startDate = tlv2_shiftISODateLocal(task.startDate, daysDelta);
      } else if (endField) {
        // If a task only has an end date, give it a start date so it can shrink/grow correctly
        task.startDate = tlv2_shiftISODateLocal(task[endField], daysDelta);
      }
    }

    if (mode === 'right') {
      // Adjust only the end edge
      if (endField) {
        task[endField] = tlv2_shiftISODateLocal(task[endField], daysDelta);
      } else if (hasStart) {
        task.endDate = tlv2_shiftISODateLocal(task.startDate, daysDelta);
      }
    }

    // Keep end >= start when both exist
    const start = tlv2_parseISODateLocal(task.startDate);
    const endVal = endField ? task[endField] : task.endDate;
    const end = tlv2_parseISODateLocal(endVal);
    if (start && end && end < start) {
      const clamped = tlv2_formatISODateLocal(start);
      if (endField) task[endField] = clamped;
      else task.endDate = clamped;
    }
  });

  // Save locally and then immediately sync the project columns to DB.
  saveProjects(projects);
  if (window.LayerDB && window.LayerDB.isAuthenticated() && project.id) {
    window.LayerDB
      .updateProject(project.id, { columns: project.columns })
      .catch(err => console.error('Failed to sync timeline changes to database:', err));
  }

  // Re-render
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineV2(TimelineV2.projectIndex, container);

  if (typeof showToast === 'function') {
    const msg = mode === 'move' ? 'Timeline moved' : 'Timeline resized';
    showToast(msg);
  }
}

// ============================================
// Navigation & Controls
// ============================================

function tlv2_setViewMode(mode) {
  TimelineV2.viewMode = mode;
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineV2(TimelineV2.projectIndex, container);
}

// Filter tabs removed

function tlv2_navigate(direction) {
  const days = { 'day': 7, 'week': 14, 'month': 30, 'quarter': 90 };
  const offset = (days[TimelineV2.viewMode] || 14) * direction;

  TimelineV2.currentDate.setDate(TimelineV2.currentDate.getDate() + offset);

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineV2(TimelineV2.projectIndex, container);
}

function tlv2_goToToday() {
  TimelineV2.currentDate = new Date();
  TimelineV2.scrollLeft = 0;

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineV2(TimelineV2.projectIndex, container);

  // Scroll to today
  requestAnimationFrame(() => {
    const todayLine = document.querySelector('.tl-today-line');
    const wrapper = document.getElementById('tlv2GanttWrapper');
    if (todayLine && wrapper) {
      const left = parseInt(todayLine.style.left) || 0;
      wrapper.scrollLeft = Math.max(0, left - wrapper.clientWidth / 2);
    }
  });
}

function tlv2_zoom(delta) {
  TimelineV2.zoom = Math.max(0.5, Math.min(2, TimelineV2.zoom + delta));

  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineV2(TimelineV2.projectIndex, container);
}

function tlv2_syncScroll(wrapper) {
  const header = document.getElementById('tlv2DateHeader');
  if (header) {
    header.scrollLeft = wrapper.scrollLeft;
  }
  TimelineV2.scrollLeft = wrapper.scrollLeft;
  TimelineV2.scrollTop = wrapper.scrollTop;
}

function tlv2_handleKeydown(event) {
  if (!document.getElementById('tlv2Container')) return;
  if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

  switch (event.key.toLowerCase()) {
    case 't':
      tlv2_goToToday();
      event.preventDefault();
      break;
    case 'arrowleft':
      tlv2_navigate(-1);
      event.preventDefault();
      break;
    case 'arrowright':
      tlv2_navigate(1);
      event.preventDefault();
      break;
    case '=':
    case '+':
      tlv2_zoom(0.25);
      event.preventDefault();
      break;
    case '-':
      tlv2_zoom(-0.25);
      event.preventDefault();
      break;
  }
}

// ============================================
// Actions
// ============================================

function tlv2_addTask() {
  if (typeof openTimelineAddTask === 'function') {
    openTimelineAddTask(TimelineV2.projectIndex);
  } else if (typeof showToast === 'function') {
    showToast('Add task feature');
  }
}

function tlv2_editColumn(columnIndex) {
  if (typeof openEditColumnModal === 'function') {
    openEditColumnModal(columnIndex, TimelineV2.projectIndex);
  }
}

function tlv2_editDates(columnIndex) {
  if (typeof editColumnDates === 'function') {
    editColumnDates(columnIndex, TimelineV2.projectIndex);
  }
}

function tlv2_toggleMilestone(columnIndex) {
  const projectIndex = TimelineV2.projectIndex;
  const project = Store.projects[projectIndex];
  if (!project || !project.columns[columnIndex]) return;

  const column = project.columns[columnIndex];
  column.isMilestone = !column.isMilestone;

  Store.saveProjects();
  tlv2_render();

  const status = column.isMilestone ? 'marked as milestone' : 'unmarked as milestone';
  if (typeof showToast === 'function') {
    showToast(`"${column.title}" ${status}`, 'success');
  }
}

// Context menu removed - use double-click to edit

// ============================================
// Color Picker
// ============================================

function tlv2_openColorPicker(event, columnIndex) {
  event.preventDefault();
  event.stopPropagation();

  // Remove any existing picker
  tlv2_closeColorPicker();

  const projects = loadProjects();
  const project = projects[TimelineV2.projectIndex];
  if (!project || !project.columns[columnIndex]) return;

  const column = project.columns[columnIndex];
  const currentColor = column.color || tlv2_getColumnColor(column.title);

  // Create color picker popover
  const picker = document.createElement('div');
  picker.id = 'tlv2ColorPicker';
  picker.className = 'tlv2-color-picker';
  picker.innerHTML = `
    <div class="tlv2-color-picker-header">
      <span class="tlv2-color-picker-title">Column Color</span>
      <button class="tlv2-color-picker-close" onclick="tlv2_closeColorPicker()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    <div class="tlv2-color-grid">
      ${TLV2_COLORS.map(c => `
        <button class="tlv2-color-swatch ${c.value === currentColor ? 'active' : ''}" 
                style="background-color: ${c.value};" 
                title="${c.name}"
                onclick="tlv2_setColumnColor(${columnIndex}, '${c.value}')">
          ${c.value === currentColor ? '<svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" width="12" height="12"><path d="M20 6L9 17l-5-5"/></svg>' : ''}
        </button>
      `).join('')}
    </div>
    <div class="tlv2-color-custom">
      <label class="tlv2-color-custom-label">Custom</label>
      <input type="color" class="tlv2-color-custom-input" value="${currentColor}" 
             onchange="tlv2_setColumnColor(${columnIndex}, this.value)">
    </div>
  `;

  // Position the picker near the click
  document.body.appendChild(picker);

  const rect = event.target.getBoundingClientRect();
  const pickerRect = picker.getBoundingClientRect();

  let left = rect.left;
  let top = rect.bottom + 8;

  // Keep within viewport
  if (left + pickerRect.width > window.innerWidth - 16) {
    left = window.innerWidth - pickerRect.width - 16;
  }
  if (top + pickerRect.height > window.innerHeight - 16) {
    top = rect.top - pickerRect.height - 8;
  }

  picker.style.left = `${Math.max(16, left)}px`;
  picker.style.top = `${Math.max(16, top)}px`;

  // Close on outside click
  setTimeout(() => {
    document.addEventListener('click', tlv2_handleColorPickerOutsideClick);
  }, 10);
}

function tlv2_handleColorPickerOutsideClick(event) {
  const picker = document.getElementById('tlv2ColorPicker');
  if (picker && !picker.contains(event.target)) {
    tlv2_closeColorPicker();
  }
}

function tlv2_closeColorPicker() {
  const picker = document.getElementById('tlv2ColorPicker');
  if (picker) picker.remove();
  document.removeEventListener('click', tlv2_handleColorPickerOutsideClick);
}

function tlv2_setColumnColor(columnIndex, color) {
  const projects = loadProjects();
  const project = projects[TimelineV2.projectIndex];
  if (!project || !project.columns[columnIndex]) return;

  project.columns[columnIndex].color = color;
  saveProjects(projects);

  tlv2_closeColorPicker();

  // Re-render timeline
  const container = document.querySelector('.pd-content-scroll');
  if (container) renderTimelineV2(TimelineV2.projectIndex, container);

  if (typeof showToast === 'function') {
    showToast('Column color updated');
  }
}

// ============================================
// TIMELINE V6 - ADVANCED PREMIUM FEATURES
// Swimlanes, Critical Path, Mini Calendar,
// Task Inspector, Workload Heatmap, Baseline
// ============================================

// Advanced Timeline State
if (typeof advancedTimelineState === 'undefined') {
  var advancedTimelineState = {
    swimlanesEnabled: false,
    swimlaneGroupBy: 'priority', // 'priority', 'assignee', 'status'
    criticalPathEnabled: false,
    showWorkload: false,
    showBaseline: false,
    miniCalendarOpen: false,
    inspectorTaskId: null,
    keyboardShortcutsOpen: false,
    collapsedSwimlanes: {},
    baselineData: {} // Stores original dates for baseline comparison
  };
}

// ============================================
// Advanced Toolbar Rendering
// ============================================
function renderAdvancedToolbar(projectIndex) {
  const state = advancedTimelineState;

  return `
    <div class="tl-advanced-toolbar">
      <!-- Swimlanes Toggle -->
      <button class="tl-adv-btn ${state.swimlanesEnabled ? 'active' : ''}" 
              onclick="toggleSwimlanes(${projectIndex})" 
              title="Group tasks into swimlanes">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="6" rx="1"/>
          <rect x="3" y="11" width="18" height="6" rx="1"/>
        </svg>
        Swimlanes
        ${state.swimlanesEnabled ? `<span class="btn-badge">${capitalizeStatus(state.swimlaneGroupBy)}</span>` : ''}
      </button>
      
      <!-- Critical Path -->
      <button class="tl-adv-btn ${state.criticalPathEnabled ? 'active' : ''}" 
              onclick="toggleCriticalPath(${projectIndex})"
              title="Highlight the critical path">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
        </svg>
        Critical Path
      </button>
      
      <div class="tl-adv-separator"></div>
      
      <!-- Workload View -->
      <button class="tl-adv-btn ${state.showWorkload ? 'active' : ''}" 
              onclick="toggleWorkloadView(${projectIndex})"
              title="Show resource workload heatmap">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
          <circle cx="9" cy="7" r="4"/>
          <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
          <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
        </svg>
        Workload
      </button>
      
      <!-- Baseline -->
      <button class="tl-adv-btn ${state.showBaseline ? 'active' : ''}" 
              onclick="toggleBaselineView(${projectIndex})"
              title="Compare with baseline schedule">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="22 7 13.5 15.5 8.5 10.5 2 17"/>
          <polyline points="16 7 22 7 22 13"/>
        </svg>
        Baseline
      </button>
      
      <div class="tl-adv-separator"></div>
      
      <!-- Mini Calendar -->
      <button class="tl-adv-btn" onclick="openMiniCalendar(event, ${projectIndex})" title="Quick date navigation">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="4" width="18" height="18" rx="2"/>
          <line x1="16" y1="2" x2="16" y2="6"/>
          <line x1="8" y1="2" x2="8" y2="6"/>
          <line x1="3" y1="10" x2="21" y2="10"/>
        </svg>
        Navigate
      </button>
      
      <!-- Keyboard Shortcuts -->
      <button class="tl-adv-btn" onclick="showKeyboardShortcuts()" title="Show keyboard shortcuts">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="2" y="6" width="20" height="12" rx="2"/>
          <line x1="6" y1="10" x2="6" y2="10"/>
          <line x1="10" y1="10" x2="10" y2="10"/>
          <line x1="14" y1="10" x2="14" y2="10"/>
          <line x1="18" y1="10" x2="18" y2="10"/>
          <line x1="8" y1="14" x2="16" y2="14"/>
        </svg>
        ?
      </button>
      
      ${state.criticalPathEnabled ? `
        <div class="tl-critical-path-legend">
          Critical path tasks
        </div>
      ` : ''}
    </div>
  `;
}

// ============================================
// Swimlanes Functionality
// ============================================
function toggleSwimlanes(projectIndex) {
  advancedTimelineState.swimlanesEnabled = !advancedTimelineState.swimlanesEnabled;

  if (advancedTimelineState.swimlanesEnabled) {
    openSwimlanesGroupByMenu(event, projectIndex);
  } else {
    refreshAdvancedTimeline(projectIndex);
  }
}

function openSwimlanesGroupByMenu(event, projectIndex) {
  event.stopPropagation();

  // Close existing menus
  closeAllDropdowns();

  const menu = document.createElement('div');
  menu.id = 'swimlanesGroupMenu';
  menu.className = 'tl-zoom-dropdown show';
  menu.style.cssText = `
    position: fixed;
    left: ${event.clientX}px;
    top: ${event.clientY + 10}px;
    min-width: 150px;
  `;

  menu.innerHTML = `
    <button class="tl-zoom-preset ${advancedTimelineState.swimlaneGroupBy === 'priority' ? 'active' : ''}" 
            onclick="setSwimlanesGroupBy('priority', ${projectIndex})">
      By Priority
    </button>
    <button class="tl-zoom-preset ${advancedTimelineState.swimlaneGroupBy === 'assignee' ? 'active' : ''}" 
            onclick="setSwimlanesGroupBy('assignee', ${projectIndex})">
      By Assignee
    </button>
    <button class="tl-zoom-preset ${advancedTimelineState.swimlaneGroupBy === 'status' ? 'active' : ''}" 
            onclick="setSwimlanesGroupBy('status', ${projectIndex})">
      By Status
    </button>
  `;

  document.body.appendChild(menu);

  setTimeout(() => {
    document.addEventListener('click', closeSwimlaneMenu);
  }, 10);
}

function closeSwimlaneMenu() {
  const menu = document.getElementById('swimlanesGroupMenu');
  if (menu) menu.remove();
  document.removeEventListener('click', closeSwimlaneMenu);
}

function setSwimlanesGroupBy(groupBy, projectIndex) {
  advancedTimelineState.swimlaneGroupBy = groupBy;
  advancedTimelineState.swimlanesEnabled = true;
  closeSwimlaneMenu();
  refreshAdvancedTimeline(projectIndex);
}

function renderSwimlanes(columns, projectIndex, dates, startDate) {
  const groupBy = advancedTimelineState.swimlaneGroupBy;
  const allTasks = [];

  columns.forEach(col => {
    col.tasks.forEach(task => {
      allTasks.push({
        ...task,
        columnTitle: col.title,
        columnColor: col.color
      });
    });
  });

  // Group tasks
  const groups = {};
  allTasks.forEach(task => {
    let key;
    switch (groupBy) {
      case 'priority':
        key = task.priority || 'none';
        break;
      case 'assignee':
        key = task.assignee || 'Unassigned';
        break;
      case 'status':
        key = task.columnTitle || 'Unknown';
        break;
      default:
        key = 'all';
    }

    if (!groups[key]) groups[key] = [];
    groups[key].push(task);
  });

  // Sort group keys
  let sortedKeys = Object.keys(groups);
  if (groupBy === 'priority') {
    const priorityOrder = ['high', 'medium', 'low', 'none'];
    sortedKeys.sort((a, b) => priorityOrder.indexOf(a) - priorityOrder.indexOf(b));
  }

  const cellWidth = 48 * timelineState.zoom;
  let html = '';

  sortedKeys.forEach(key => {
    const tasks = groups[key];
    const isCollapsed = advancedTimelineState.collapsedSwimlanes[key];
    const completedCount = tasks.filter(t => t.done).length;

    let iconClass = '';
    let iconContent = '';

    if (groupBy === 'priority') {
      iconClass = `priority-${key}`;
      iconContent = key === 'high' ? '!!!' : key === 'medium' ? '!!' : '!';
    } else if (groupBy === 'assignee') {
      iconClass = 'assignee';
      iconContent = key.charAt(0).toUpperCase();
    } else {
      iconClass = 'assignee';
      iconContent = key.charAt(0).toUpperCase();
    }

    html += `
      <div class="tl-swimlane ${isCollapsed ? 'collapsed' : ''}" data-swimlane="${key}">
        <div class="tl-swimlane-header">
          <div class="tl-swimlane-icon ${iconClass}">${iconContent}</div>
          <div class="tl-swimlane-info">
            <div class="tl-swimlane-title">${capitalizeStatus(key)}</div>
            <div class="tl-swimlane-meta">${tasks.length} task${tasks.length !== 1 ? 's' : ''}</div>
          </div>
          <div class="tl-swimlane-stats">
            <div class="tl-swimlane-stat">
              <span class="tl-swimlane-stat-value">${completedCount}</span>
              <span class="tl-swimlane-stat-label">Done</span>
            </div>
            <div class="tl-swimlane-stat">
              <span class="tl-swimlane-stat-value">${tasks.length - completedCount}</span>
              <span class="tl-swimlane-stat-label">Open</span>
            </div>
          </div>
          <button class="tl-swimlane-expand" onclick="toggleSwimlaneCollapse('${key}', ${projectIndex})">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
          </button>
        </div>
        <div class="tl-swimlane-body">
          <div class="tl-left-panel" style="width: 200px;">
            ${tasks.map(task => `
              <div class="tl-task-item" onclick="showTaskInspector('${task.id}', ${projectIndex}, event)" style="height: 44px;">
                <div class="tl-task-status">
                  <svg class="tl-task-icon ${task.done ? 'complete' : ''}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    ${task.done ? '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>' : '<circle cx="12" cy="12" r="10"/>'}
                  </svg>
                </div>
                <div class="tl-task-content">
                  <div class="tl-task-title ${task.done ? 'completed' : ''}">${task.title}</div>
                </div>
              </div>
            `).join('')}
          </div>
          <div class="tl-gantt-wrapper" style="flex: 1;">
            <div class="tl-gantt-grid" style="width: ${dates.length * cellWidth}px;">
              ${renderSwimlaneTaskBars(tasks, dates, startDate, projectIndex)}
            </div>
          </div>
        </div>
      </div>
    `;
  });

  return html;
}

function renderSwimlaneTaskBars(tasks, dates, startDate, projectIndex) {
  const cellWidth = 48 * timelineState.zoom;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let html = '';

  tasks.forEach((task, idx) => {
    const cells = dates.map(date => {
      const isToday = date.toDateString() === today.toDateString();
      const isWeekend = date.getDay() === 0 || date.getDay() === 6;
      return `<div class="tl-gantt-cell ${isToday ? 'today' : ''} ${isWeekend ? 'weekend' : ''}" style="min-width: ${cellWidth}px; height: 44px;"></div>`;
    }).join('');

    let barHtml = '';
    if (task.startDate) {
      const taskStart = new Date(task.startDate);
      const taskEnd = task.dueDate ? new Date(task.dueDate) : taskStart;
      const startOffset = daysBetween(startDate, taskStart);
      const duration = Math.max(1, daysBetween(taskStart, taskEnd) + 1);
      const left = Math.max(0, startOffset * cellWidth);
      const width = Math.max(cellWidth - 4, duration * cellWidth - 4);

      const isOverdue = taskEnd < today && !task.done;
      const isCritical = advancedTimelineState.criticalPathEnabled && isTaskOnCriticalPath(task);

      barHtml = `
        <div class="tl-task-bar tl-task-bar-clickup tl-task-bar-child ${task.done ? 'completed' : ''} ${isOverdue ? 'overdue' : ''} ${isCritical ? 'critical-path' : ''}"
             style="left: ${left}px; width: ${width}px; top: ${idx * 44 + 9}px; background: linear-gradient(180deg, ${task.columnColor || '#6366f1'} 0%, ${adjustColor(task.columnColor || '#6366f1', -15)} 100%);"
             onclick="showTaskInspector('${task.id}', ${projectIndex}, event)">
          <span class="tl-bar-label">${task.title}</span>
        </div>
      `;
    }

    html += `<div class="tl-gantt-row tl-gantt-row-clickup" style="height: 36px; position: relative;">${cells}${barHtml}</div>`;
  });

  return html;
}

function toggleSwimlaneCollapse(key, projectIndex) {
  advancedTimelineState.collapsedSwimlanes[key] = !advancedTimelineState.collapsedSwimlanes[key];
  refreshAdvancedTimeline(projectIndex);
}

// ============================================
// Critical Path Functionality
// ============================================
function toggleCriticalPath(projectIndex) {
  advancedTimelineState.criticalPathEnabled = !advancedTimelineState.criticalPathEnabled;
  refreshAdvancedTimeline(projectIndex);

  if (advancedTimelineState.criticalPathEnabled) {
    showToast('Critical path highlighted - longest dependency chain shown');
  }
}

function isTaskOnCriticalPath(task) {
  // Simple critical path logic - tasks with dependencies that are on the longest chain
  // In a real implementation, this would use topological sorting
  if (!task.dependencies || task.dependencies.length === 0) return false;

  // For now, highlight tasks with dependencies
  return true;
}

function calculateCriticalPath(columns) {
  const allTasks = [];
  columns.forEach(col => {
    col.tasks.forEach(task => {
      allTasks.push({
        ...task,
        column: col.title
      });
    });
  });

  // Find tasks with longest dependency chains
  const criticalTasks = new Set();

  allTasks.forEach(task => {
    if (task.dependencies && task.dependencies.length > 0) {
      criticalTasks.add(task.id);
      task.dependencies.forEach(depId => criticalTasks.add(depId));
    }
  });

  return Array.from(criticalTasks);
}

// ============================================
// Workload View
// ============================================
function toggleWorkloadView(projectIndex) {
  advancedTimelineState.showWorkload = !advancedTimelineState.showWorkload;
  refreshAdvancedTimeline(projectIndex);
}

function renderWorkloadView(columns, dates, projectIndex) {
  // Collect all assignees
  const assignees = {};
  columns.forEach(col => {
    col.tasks.forEach(task => {
      const name = task.assignee || 'Unassigned';
      if (!assignees[name]) {
        assignees[name] = { name, tasks: [] };
      }
      assignees[name].tasks.push(task);
    });
  });

  const cellWidth = 48 * timelineState.zoom;

  let html = `
    <div class="tl-workload-container">
      <div class="tl-workload-legend">
        <span class="tl-workload-legend-title">Workload Capacity (8h/day):</span>
        <div class="tl-workload-legend-items">
          <div class="tl-workload-legend-item">
            <div class="tl-workload-legend-color light"></div>
            <span>Light (1-3h)</span>
          </div>
          <div class="tl-workload-legend-item">
            <div class="tl-workload-legend-color medium"></div>
            <span>Medium (4-6h)</span>
          </div>
          <div class="tl-workload-legend-item">
            <div class="tl-workload-legend-color heavy"></div>
            <span>Heavy (7-8h)</span>
          </div>
          <div class="tl-workload-legend-item">
            <div class="tl-workload-legend-color overloaded"></div>
            <span>Overloaded (>8h)</span>
          </div>
        </div>
      </div>
      <div class="tl-workload-rows">
  `;

  Object.values(assignees).forEach(assignee => {
    const avatarColor = getAvatarColor(assignee.name);

    html += `
      <div class="tl-workload-row">
        <div class="tl-workload-assignee">
          <div class="tl-workload-avatar" style="background: linear-gradient(135deg, ${avatarColor} 0%, ${adjustColor(avatarColor, -20)} 100%);">
            ${assignee.name.charAt(0).toUpperCase()}
          </div>
          <div class="tl-workload-name">
            <div class="tl-workload-name-text">${assignee.name}</div>
            <div class="tl-workload-capacity">${assignee.tasks.length} tasks</div>
          </div>
        </div>
        <div class="tl-workload-cells">
    `;

    dates.forEach(date => {
      // Calculate hours for this date
      const hours = assignee.tasks.filter(task => {
        if (!task.startDate) return false;
        const start = new Date(task.startDate);
        const end = task.dueDate ? new Date(task.dueDate) : start;
        return date >= start && date <= end;
      }).length * 2; // Assume 2 hours per task per day

      const level = hours === 0 ? 0 : hours <= 2 ? 1 : hours <= 4 ? 2 : hours <= 6 ? 3 : hours <= 8 ? 4 : hours <= 10 ? 5 : 6;
      const isOverloaded = hours > 8;

      html += `
        <div class="tl-workload-cell level-${level} ${isOverloaded ? 'overloaded' : ''}" 
             style="width: ${cellWidth}px;" 
             data-hours="${hours}h"
             title="${assignee.name}: ${hours}h on ${date.toLocaleDateString()}">
        </div>
      `;
    });

    html += `
        </div>
      </div>
    `;
  });

  html += `
      </div>
    </div>
  `;

  return html;
}

// ============================================
// Baseline Comparison
// ============================================
function toggleBaselineView(projectIndex) {
  advancedTimelineState.showBaseline = !advancedTimelineState.showBaseline;

  if (advancedTimelineState.showBaseline && Object.keys(advancedTimelineState.baselineData).length === 0) {
    // Save current dates as baseline
    saveBaseline(projectIndex);
    showToast('Baseline saved! Future changes will be compared against this snapshot.');
  }

  refreshAdvancedTimeline(projectIndex);
}

function saveBaseline(projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  const baseline = {};
  project.columns.forEach((col, colIdx) => {
    col.tasks.forEach((task, taskIdx) => {
      if (task.startDate || task.dueDate) {
        baseline[task.id] = {
          startDate: task.startDate,
          dueDate: task.dueDate
        };
      }
    });
  });

  advancedTimelineState.baselineData = baseline;

  // Also save to project
  project.baselineData = baseline;
  project.baselineSavedAt = new Date().toISOString();
  saveProjects(projects);
}

function renderBaselineBar(task, startDate) {
  const baseline = advancedTimelineState.baselineData[task.id];
  if (!baseline) return '';

  const cellWidth = 48 * timelineState.zoom;
  const baseStart = baseline.startDate ? new Date(baseline.startDate) : null;
  const baseEnd = baseline.dueDate ? new Date(baseline.dueDate) : baseStart;

  if (!baseStart) return '';

  const startOffset = daysBetween(startDate, baseStart);
  const duration = Math.max(1, daysBetween(baseStart, baseEnd) + 1);
  const left = Math.max(0, startOffset * cellWidth);
  const width = Math.max(cellWidth - 4, duration * cellWidth - 4);

  // Calculate variance
  const currentStart = task.startDate ? new Date(task.startDate) : null;
  let variance = 0;
  let varianceClass = '';

  if (currentStart && baseStart) {
    variance = daysBetween(baseStart, currentStart);
    varianceClass = variance < 0 ? 'ahead' : variance > 0 ? 'behind' : '';
  }

  return `
    <div class="tl-baseline-bar" style="left: ${left}px; width: ${width}px;"></div>
    ${variance !== 0 ? `
      <div class="tl-baseline-indicator ${varianceClass}">
        ${variance < 0 ? `${Math.abs(variance)}d ahead` : `${variance}d behind`}
      </div>
    ` : ''}
  `;
}

// ============================================
// Mini Calendar Navigator
// ============================================
function openMiniCalendar(event, projectIndex) {
  event.stopPropagation();

  const existing = document.getElementById('tlMiniCalendar');
  if (existing) {
    existing.remove();
    return;
  }

  const today = new Date();
  const currentMonth = timelineState.currentDate || today;

  const calendar = document.createElement('div');
  calendar.id = 'tlMiniCalendar';
  calendar.className = 'tl-mini-calendar show';
  calendar.style.cssText = `
    left: ${event.clientX - 150}px;
    top: ${event.clientY + 20}px;
  `;

  calendar.innerHTML = renderMiniCalendarContent(currentMonth, projectIndex);
  document.body.appendChild(calendar);

  setTimeout(() => {
    document.addEventListener('click', closeMiniCalendar);
  }, 10);
}

function renderMiniCalendarContent(displayMonth, projectIndex) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const year = displayMonth.getFullYear();
  const month = displayMonth.getMonth();

  const firstDay = new Date(year, month, 1);
  const lastDay = new Date(year, month + 1, 0);
  const startDay = firstDay.getDay();

  const monthName = displayMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  const dayLabels = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];

  let daysHtml = dayLabels.map(d => `<div class="tl-mini-calendar-day-label">${d}</div>`).join('');

  // Previous month days
  const prevMonth = new Date(year, month, 0);
  for (let i = startDay - 1; i >= 0; i--) {
    const day = prevMonth.getDate() - i;
    daysHtml += `<div class="tl-mini-calendar-day other-month">${day}</div>`;
  }

  // Current month days
  for (let day = 1; day <= lastDay.getDate(); day++) {
    const date = new Date(year, month, day);
    const isToday = date.toDateString() === today.toDateString();

    daysHtml += `
      <div class="tl-mini-calendar-day ${isToday ? 'today' : ''}" 
           onclick="navigateToDate(${year}, ${month}, ${day}, ${projectIndex})">
        ${day}
      </div>
    `;
  }

  // Next month days
  const remainingCells = 42 - (startDay + lastDay.getDate());
  for (let day = 1; day <= remainingCells; day++) {
    daysHtml += `<div class="tl-mini-calendar-day other-month">${day}</div>`;
  }

  return `
    <div class="tl-mini-calendar-header">
      <span class="tl-mini-calendar-title">${monthName}</span>
      <div class="tl-mini-calendar-nav">
        <button onclick="navigateMiniCalendar(-1, ${projectIndex})">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <button onclick="navigateMiniCalendar(1, ${projectIndex})">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>
        </button>
      </div>
    </div>
    <div class="tl-mini-calendar-days">
      ${daysHtml}
    </div>
    <div class="tl-mini-calendar-shortcuts">
      <button class="tl-mini-calendar-shortcut" onclick="navigateToToday(${projectIndex})">Today</button>
      <button class="tl-mini-calendar-shortcut" onclick="navigateToThisWeek(${projectIndex})">This Week</button>
      <button class="tl-mini-calendar-shortcut" onclick="navigateToNextMonth(${projectIndex})">Next Month</button>
    </div>
  `;
}

function closeMiniCalendar(event) {
  const calendar = document.getElementById('tlMiniCalendar');
  if (calendar && !calendar.contains(event?.target)) {
    calendar.remove();
    document.removeEventListener('click', closeMiniCalendar);
  }
}

function navigateMiniCalendar(direction, projectIndex) {
  event.stopPropagation();
  const current = timelineState.currentDate || new Date();
  const newMonth = new Date(current.getFullYear(), current.getMonth() + direction, 1);
  timelineState.currentDate = newMonth;

  const calendar = document.getElementById('tlMiniCalendar');
  if (calendar) {
    calendar.innerHTML = renderMiniCalendarContent(newMonth, projectIndex);
  }
}

function navigateToDate(year, month, day, projectIndex) {
  const targetDate = new Date(year, month, day);
  timelineState.currentDate = targetDate;
  closeMiniCalendar();
  refreshAdvancedTimeline(projectIndex);

  // Scroll to the date in the gantt
  setTimeout(() => {
    goToTimelineDate(targetDate, projectIndex);
  }, 100);
}

function navigateToToday(projectIndex) {
  navigateToDate(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), projectIndex);
}

function navigateToThisWeek(projectIndex) {
  const today = new Date();
  const dayOfWeek = today.getDay();
  const monday = new Date(today);
  monday.setDate(today.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));
  navigateToDate(monday.getFullYear(), monday.getMonth(), monday.getDate(), projectIndex);
}

function navigateToNextMonth(projectIndex) {
  const next = new Date();
  next.setMonth(next.getMonth() + 1);
  next.setDate(1);
  navigateToDate(next.getFullYear(), next.getMonth(), next.getDate(), projectIndex);
}

function goToTimelineDate(targetDate, projectIndex) {
  const wrapper = document.getElementById('tlGanttWrapper');
  if (!wrapper) return;

  const cellWidth = 48 * timelineState.zoom;
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  // Calculate approximate scroll position
  const allTasks = [];
  project.columns.forEach(col => {
    col.tasks.forEach(task => {
      if (task.startDate) allTasks.push(task);
    });
  });

  if (allTasks.length === 0) return;

  const startDates = allTasks.map(t => new Date(t.startDate));
  const minDate = new Date(Math.min(...startDates));
  const offset = daysBetween(minDate, targetDate);

  wrapper.scrollLeft = Math.max(0, offset * cellWidth - wrapper.clientWidth / 2);
}

// ============================================
// Task Inspector
// ============================================
function showTaskInspector(taskId, projectIndex, event) {
  event.stopPropagation();

  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  let task = null;
  let columnTitle = '';

  project.columns.forEach(col => {
    col.tasks.forEach(t => {
      if (t.id === taskId) {
        task = t;
        columnTitle = col.title;
      }
    });
  });

  if (!task) return;

  const existing = document.getElementById('tlTaskInspector');
  if (existing) existing.remove();

  const inspector = document.createElement('div');
  inspector.id = 'tlTaskInspector';
  inspector.className = 'tl-task-inspector';

  // Position near the click but within viewport
  let left = event.clientX + 20;
  let top = event.clientY - 100;

  if (left + 360 > window.innerWidth) left = event.clientX - 380;
  if (top < 20) top = 20;
  if (top + 480 > window.innerHeight) top = window.innerHeight - 500;

  inspector.style.cssText = `left: ${left}px; top: ${top}px;`;

  const statusClass = task.done ? 'done' : columnTitle.toLowerCase().includes('progress') ? 'in-progress' : 'todo';
  const statusIcon = task.done
    ? '<polyline points="22 4 12 14.01 9 11.01"/><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>'
    : '<circle cx="12" cy="12" r="10"/>';

  const dueDate = task.dueDate ? new Date(task.dueDate) : null;
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const isOverdue = dueDate && dueDate < today && !task.done;
  const isDueSoon = dueDate && !isOverdue && daysBetween(today, dueDate) <= 3;

  inspector.innerHTML = `
    <div class="tl-inspector-header">
      <div class="tl-inspector-status ${statusClass}">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${statusIcon}</svg>
      </div>
      <div class="tl-inspector-title-wrap">
        <div class="tl-inspector-title">${task.title}</div>
        <div class="tl-inspector-subtitle">${columnTitle} • ${task.id}</div>
      </div>
      <button class="tl-inspector-close" onclick="closeTaskInspector()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>
      </button>
    </div>
    
    <div class="tl-inspector-body">
      <div class="tl-inspector-section">
        <div class="tl-inspector-section-title">Details</div>
        
        <div class="tl-inspector-row">
          <div class="tl-inspector-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/></svg>
          </div>
          <div class="tl-inspector-row-content">
            <div class="tl-inspector-label">Due Date</div>
            <div class="tl-inspector-value ${isOverdue ? 'overdue' : isDueSoon ? 'due-soon' : ''}">
              ${dueDate ? formatDate(task.dueDate) : 'No due date'}
              ${isOverdue ? ' (Overdue)' : isDueSoon ? ' (Due soon)' : ''}
            </div>
          </div>
        </div>
        
        ${task.assignee ? `
        <div class="tl-inspector-row">
          <div class="tl-inspector-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
          </div>
          <div class="tl-inspector-row-content">
            <div class="tl-inspector-label">Assignee</div>
            <div class="tl-inspector-value">${task.assignee}</div>
          </div>
        </div>
        ` : ''}
        
        ${task.priority ? `
        <div class="tl-inspector-row">
          <div class="tl-inspector-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
          </div>
          <div class="tl-inspector-row-content">
            <div class="tl-inspector-label">Priority</div>
            <div class="tl-inspector-value">${capitalizeStatus(task.priority)}</div>
          </div>
        </div>
        ` : ''}
        
        ${task.startDate ? `
        <div class="tl-inspector-row">
          <div class="tl-inspector-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>
          </div>
          <div class="tl-inspector-row-content">
            <div class="tl-inspector-label">Duration</div>
            <div class="tl-inspector-value">
              ${formatDate(task.startDate)} → ${task.dueDate ? formatDate(task.dueDate) : 'TBD'}
              <span style="color: var(--muted-foreground); margin-left: 8px;">
                (${task.dueDate ? daysBetween(new Date(task.startDate), new Date(task.dueDate)) + 1 : '?'} days)
              </span>
            </div>
          </div>
        </div>
        ` : ''}
      </div>
      
      ${task.description ? `
      <div class="tl-inspector-section">
        <div class="tl-inspector-section-title">Description</div>
        <p style="font-size: 13px; color: var(--foreground); line-height: 1.5;">${task.description}</p>
      </div>
      ` : ''}
    </div>
    
    <div class="tl-inspector-actions">
      <button class="tl-inspector-action" onclick="closeTaskInspector(); openTimelineTaskEdit('${task.id}', ${projectIndex})">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
        Edit
      </button>
      <button class="tl-inspector-action primary" onclick="closeTaskInspector(); toggleTaskComplete('${task.id}', ${projectIndex})">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
        ${task.done ? 'Mark Incomplete' : 'Complete'}
      </button>
    </div>
  `;

  document.body.appendChild(inspector);

  requestAnimationFrame(() => {
    inspector.classList.add('show');
  });

  setTimeout(() => {
    document.addEventListener('click', handleInspectorOutsideClick);
  }, 10);
}

function handleInspectorOutsideClick(event) {
  const inspector = document.getElementById('tlTaskInspector');
  if (inspector && !inspector.contains(event.target)) {
    closeTaskInspector();
  }
}

function closeTaskInspector() {
  const inspector = document.getElementById('tlTaskInspector');
  if (inspector) {
    inspector.classList.remove('show');
    setTimeout(() => inspector.remove(), 200);
  }
  document.removeEventListener('click', handleInspectorOutsideClick);
}

async function toggleTaskComplete(taskId, projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return;

  project.columns.forEach((col, colIdx) => {
    col.tasks.forEach((task, taskIdx) => {
      if (task.id === taskId) {
        task.done = !task.done;
      }
    });
  });

  saveProjects(projects);

  // Sync to DB if authenticated
  if (window.LayerDB && window.LayerDB.isAuthenticated() && project.id) {
    try {
      await window.LayerDB.updateProject(project.id, { columns: project.columns });
    } catch (error) {
      console.error('Failed to sync task complete to database:', error);
    }
  }

  refreshAdvancedTimeline(projectIndex);
  showToast(projects[projectIndex].columns.flatMap(c => c.tasks).find(t => t.id === taskId)?.done ? 'Task completed!' : 'Task reopened');
}

// ============================================
// Keyboard Shortcuts
// ============================================
function showKeyboardShortcuts() {
  const overlay = document.createElement('div');
  overlay.id = 'tlShortcutsOverlay';
  overlay.className = 'tl-shortcuts-overlay';

  overlay.innerHTML = `
    <div class="tl-shortcuts-panel">
      <div class="tl-shortcuts-header">
        <span class="tl-shortcuts-title">Keyboard Shortcuts</span>
        <button class="tl-shortcuts-close" onclick="closeKeyboardShortcuts()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>
        </button>
      </div>
      
      <div class="tl-shortcuts-group">
        <div class="tl-shortcuts-group-title">Navigation</div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Go to today</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">T</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Previous period</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">←</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Next period</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">→</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Scroll up</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">↑</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Scroll down</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">↓</span></div>
        </div>
      </div>
      
      <div class="tl-shortcuts-group">
        <div class="tl-shortcuts-group-title">Zoom</div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Zoom in</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">+</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Zoom out</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">-</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Fit to screen</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">F</span></div>
        </div>
      </div>
      
      <div class="tl-shortcuts-group">
        <div class="tl-shortcuts-group-title">Views</div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Day view</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">D</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Week view</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">W</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Month view</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">M</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Toggle swimlanes</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">S</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Toggle critical path</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">C</span></div>
        </div>
      </div>
      
      <div class="tl-shortcuts-group">
        <div class="tl-shortcuts-group-title">Actions</div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Add new task</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">N</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Show shortcuts</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">?</span></div>
        </div>
        <div class="tl-shortcut-item">
          <span class="tl-shortcut-desc">Close modal / Cancel</span>
          <div class="tl-shortcut-keys"><span class="tl-shortcut-key">Esc</span></div>
        </div>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  requestAnimationFrame(() => {
    overlay.classList.add('show');
  });

  document.addEventListener('keydown', handleShortcutsEsc);
}

function handleShortcutsEsc(event) {
  if (event.key === 'Escape') {
    closeKeyboardShortcuts();
  }
}

function closeKeyboardShortcuts() {
  const overlay = document.getElementById('tlShortcutsOverlay');
  if (overlay) {
    overlay.classList.remove('show');
    setTimeout(() => overlay.remove(), 250);
  }
  document.removeEventListener('keydown', handleShortcutsEsc);
}

// Enhanced keyboard handler for timeline
function setupAdvancedTimelineKeyboard(projectIndex) {
  document.addEventListener('keydown', function (event) {
    // Don't trigger if user is typing in an input
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

    const key = event.key.toLowerCase();

    switch (key) {
      case 't':
        goToTimelineToday(projectIndex);
        break;
      case 'arrowleft':
        navigateTimeline(-1, projectIndex);
        break;
      case 'arrowright':
        navigateTimeline(1, projectIndex);
        break;
      case '+':
      case '=':
        zoomTimelineSmart(1, projectIndex);
        break;
      case '-':
        zoomTimelineSmart(-1, projectIndex);
        break;
      case 'f':
        autofitTimeline(projectIndex);
        break;
      case 'd':
        setTimelineViewMode('day', projectIndex);
        break;
      case 'w':
        setTimelineViewMode('week', projectIndex);
        break;
      case 'm':
        setTimelineViewMode('month', projectIndex);
        break;
      case 's':
        toggleSwimlanes(projectIndex);
        break;
      case 'c':
        toggleCriticalPath(projectIndex);
        break;
      case 'n':
        openTimelineAddTask(projectIndex);
        break;
      case '?':
        showKeyboardShortcuts();
        break;
    }
  });
}

// ============================================
// Refresh Helper
// ============================================
function refreshAdvancedTimeline(projectIndex) {
  const container = document.querySelector('.pd-content-scroll');
  if (container && typeof renderTimelineView === 'function') {
    renderTimelineView(projectIndex, container);
  }
}

// ============================================
// Close all dropdowns helper
// ============================================
function closeAllDropdowns() {
  const dropdowns = document.querySelectorAll('.tl-zoom-dropdown.show, #swimlanesGroupMenu, #tlMiniCalendar');
  dropdowns.forEach(d => d.remove());
}

// ============================================
// Integration - Replace old timeline render
// ============================================

// Override the old renderTimelineView if it exists
if (typeof window !== 'undefined') {
  window.renderTimelineViewV2 = renderTimelineV2;
  window.renderAdvancedToolbar = renderAdvancedToolbar;
}

console.log('Timeline V2 loaded successfully');
console.log('Timeline V6 Advanced Features loaded successfully');

// ============================================
// PREMIUM BAR CONTEXT MENU & MILESTONE SYSTEM
// ============================================

// Emoji icons pool for bar decoration
const barEmojiIcons = ['🌐', '⚙️', '⭐', '⚡', '🎯', '📊', '🚀', '💡', '🔧', '📁', '✨', '🎨', '📌', '🔥', '💎'];

function getBarEmoji(title) {
  // Generate consistent emoji based on title hash
  if (!title) return '📌';
  let hash = 0;
  for (let i = 0; i < title.length; i++) {
    hash = ((hash << 5) - hash) + title.charCodeAt(i);
    hash |= 0;
  }
  return barEmojiIcons[Math.abs(hash) % barEmojiIcons.length];
}

// Context menu state
let barContextMenuState = {
  visible: false,
  targetId: null,
  targetType: null, // 'column' or 'task'
  projectIndex: null,
  clickX: 0,
  clickY: 0,
  clickDate: null
};

// Show bar context menu on click
function showBarContextMenu(event, id, type, projectIndex) {
  event.preventDefault();
  event.stopPropagation();

  // Close any existing menu
  hideBarContextMenu();

  // Store context state
  barContextMenuState.visible = true;
  barContextMenuState.targetId = id;
  barContextMenuState.targetType = type;
  barContextMenuState.projectIndex = projectIndex;
  barContextMenuState.clickX = event.clientX;
  barContextMenuState.clickY = event.clientY;

  // Calculate clicked date position on bar
  const bar = event.currentTarget;
  const rect = bar.getBoundingClientRect();
  const clickOffsetX = event.clientX - rect.left;
  const barWidth = rect.width;
  const startDate = new Date(bar.dataset.startDate);
  const endDate = new Date(bar.dataset.endDate);

  if (startDate && endDate && !isNaN(startDate) && !isNaN(endDate)) {
    const totalDays = daysBetween(startDate, endDate) + 1;
    const dayOffset = Math.floor((clickOffsetX / barWidth) * totalDays);
    const clickedDate = new Date(startDate);
    clickedDate.setDate(clickedDate.getDate() + dayOffset);
    barContextMenuState.clickDate = clickedDate.toISOString().split('T')[0];
  } else {
    barContextMenuState.clickDate = new Date().toISOString().split('T')[0];
  }

  // Create context menu
  const menu = document.createElement('div');
  menu.id = 'tlBarContextMenu';
  menu.className = 'tl-bar-context-menu';
  menu.innerHTML = `
    <button class="tl-bar-context-menu-item" onclick="createMilestoneFromMenu()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
      </svg>
      Create milestone
    </button>
    <button class="tl-bar-context-menu-item" onclick="addMarkerFromMenu()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 2v20M2 12h20"/>
      </svg>
      Add marker
    </button>
    <div class="tl-bar-context-menu-separator"></div>
    <button class="tl-bar-context-menu-item" onclick="editBarDates()">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="4" width="18" height="18" rx="2"/><path d="M16 2v4M8 2v4M3 10h18"/>
      </svg>
      Edit dates
    </button>
  `;

  // Position menu
  menu.style.left = `${event.clientX}px`;
  menu.style.top = `${event.clientY}px`;

  document.body.appendChild(menu);

  // Adjust position if menu goes off screen
  const menuRect = menu.getBoundingClientRect();
  if (menuRect.right > window.innerWidth) {
    menu.style.left = `${window.innerWidth - menuRect.width - 10}px`;
  }
  if (menuRect.bottom > window.innerHeight) {
    menu.style.top = `${window.innerHeight - menuRect.height - 10}px`;
  }

  // Add click outside listener
  setTimeout(() => {
    document.addEventListener('click', hideBarContextMenuOnClick);
    document.addEventListener('contextmenu', hideBarContextMenuOnClick);
  }, 10);
}

function hideBarContextMenu() {
  const menu = document.getElementById('tlBarContextMenu');
  if (menu) {
    menu.remove();
  }
  barContextMenuState.visible = false;
  document.removeEventListener('click', hideBarContextMenuOnClick);
  document.removeEventListener('contextmenu', hideBarContextMenuOnClick);
}

function hideBarContextMenuOnClick(event) {
  const menu = document.getElementById('tlBarContextMenu');
  if (menu && !menu.contains(event.target)) {
    hideBarContextMenu();
  }
}

// Milestone menu functions removed
function createMilestoneFromMenu() { }
function addMarkerFromMenu() { }

// Edit bar dates
function editBarDates() {
  hideBarContextMenu();
  const { targetId, targetType, projectIndex } = barContextMenuState;

  if (targetType === 'column') {
    // Find column index
    const projects = loadProjects();
    const project = projects[projectIndex];
    if (project) {
      const colIndex = project.columns.findIndex(c => c.id === targetId);
      if (colIndex !== -1) {
        openEditColumnModal(colIndex, projectIndex);
      }
    }
  } else {
    openTimelineTaskEdit(targetId, projectIndex);
  }
}

// Remaining milestone functions removed
function showMilestoneNameInput() { }
function closeMilestoneInput() { }
function confirmMilestoneCreation() { }
function showMilestoneContextMenu() { }
function renameMilestone() { }
function deleteMilestone() { }
function renderCustomMilestonesOnBar() { return ''; }

// ============================================
// Advanced Bookmark System
// ============================================

const BOOKMARKS_STORAGE_KEY = 'layerBookmarks';

// Initialize bookmarks storage
function initializeBookmarks() {
  if (!localStorage.getItem(BOOKMARKS_STORAGE_KEY)) {
    localStorage.setItem(BOOKMARKS_STORAGE_KEY, JSON.stringify([]));
  }
}

// Get all bookmarks
function getAllBookmarks() {
  try {
    return JSON.parse(localStorage.getItem(BOOKMARKS_STORAGE_KEY)) || [];
  } catch (error) {
    console.error('Error loading bookmarks:', error);
    return [];
  }
}

// Save bookmarks
function saveBookmarks(bookmarks) {
  try {
    localStorage.setItem(BOOKMARKS_STORAGE_KEY, JSON.stringify(bookmarks));
    return true;
  } catch (error) {
    console.error('Error saving bookmarks:', error);
    return false;
  }
}

// Add bookmark
function addBookmark(itemId, itemType, title, spaceId, metadata = {}) {
  const bookmarks = getAllBookmarks();
  const existingBookmark = bookmarks.find(b => b.itemId === itemId && b.itemType === itemType);

  if (existingBookmark) {
    showToast('Already bookmarked!', 'warning');
    return false;
  }

  const newBookmark = {
    id: generateId(),
    itemId,
    itemType,
    title,
    spaceId,
    createdAt: new Date().toISOString(),
    metadata,
    tags: [],
    notes: ''
  };

  bookmarks.push(newBookmark);

  if (saveBookmarks(bookmarks)) {
    showToast('Added to bookmarks!', 'success');
    return true;
  }

  return false;
}

// Remove bookmark
function removeBookmark(itemId, itemType) {
  const bookmarks = getAllBookmarks();
  const filteredBookmarks = bookmarks.filter(b => !(b.itemId === itemId && b.itemType === itemType));

  if (saveBookmarks(filteredBookmarks)) {
    showToast('Removed from bookmarks', 'success');
    // Refresh the current view if we're on a space view
    const currentView = document.querySelector('[data-view].active');
    if (currentView && currentView.dataset.view === 'activity') {
      const activeSpace = document.querySelector('.custom-space-item.active');
      if (activeSpace) {
        openSpaceView(activeSpace.dataset.spaceId);
      }
    }
    return true;
  }

  return false;
}

// Get bookmarks for a specific space
function getSpaceBookmarks(spaceId) {
  const bookmarks = getAllBookmarks();
  return bookmarks.filter(bookmark => bookmark.spaceId === spaceId);
}

// Get bookmarked items for space view
function getBookmarkedItemsForSpace(spaceId) {
  const bookmarks = getSpaceBookmarks(spaceId);
  const docs = loadDocs().filter(d => String(d.spaceId) === String(spaceId));
  const excels = loadExcels().filter(e => String(e.spaceId) === String(spaceId));

  return bookmarks.map(bookmark => {
    if (bookmark.itemType === 'doc') {
      const doc = docs.find(d => d.id === bookmark.itemId);
      return doc ? { ...doc, type: 'doc', bookmarkId: bookmark.id } : null;
    } else if (bookmark.itemType === 'excel') {
      const excel = excels.find(e => e.id === bookmark.itemId);
      return excel ? { ...excel, type: 'excel', bookmarkId: bookmark.id } : null;
    }
    return null;
  }).filter(Boolean);
}

// Open bookmark manager modal
function openBookmarkManager(spaceId) {
  const bookmarks = spaceId ? getSpaceBookmarks(spaceId) : getAllBookmarks();
  const space = spaceId ? getSpaceById(spaceId) : null;

  const content = `
    <div class="bookmark-manager">
      <div class="bookmark-header">
        <h3>${space ? `Bookmarks in ${space.name}` : 'All Bookmarks'}</h3>
        <div class="bookmark-actions">
          <button class="btn btn-secondary" onclick="exportBookmarks()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="7 10 12 15 17 10"/>
              <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Export
          </button>
          <button class="btn btn-primary" onclick="openAddBookmarkModal('${spaceId || ''}')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/><path d="M12 8v8M8 12h8"/>
            </svg>
            Add Bookmark
          </button>
        </div>
      </div>
      
      <div class="bookmark-filters">
        <div class="filter-group">
          <label>Type:</label>
          <select onchange="filterBookmarks('type', this.value)">
            <option value="all">All Types</option>
            <option value="doc">Documents</option>
            <option value="excel">Spreadsheets</option>
            <option value="web">Web Links</option>
          </select>
        </div>
        <div class="filter-group">
          <label>Sort:</label>
          <select onchange="sortBookmarks(this.value)">
            <option value="newest">Newest First</option>
            <option value="oldest">Oldest First</option>
            <option value="title">Title A-Z</option>
          </select>
        </div>
      </div>
      
      <div class="bookmark-list" id="bookmarkList">
        ${renderBookmarkList(bookmarks)}
      </div>
    </div>
  `;

  openModal('Bookmark Manager', content, 'large');
}

// Render bookmark list
function renderBookmarkList(bookmarks) {
  if (bookmarks.length === 0) {
    return `
      <div class="empty-state">
        <div class="empty-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
          </svg>
        </div>
        <h3>No bookmarks yet</h3>
        <p>Start bookmarking items to organize your favorite content</p>
        <button class="btn btn-primary" onclick="openAddBookmarkModal()">Add Bookmark</button>
      </div>
    `;
  }

  return bookmarks.map(bookmark => `
    <div class="bookmark-item-card" data-bookmark-id="${bookmark.id}">
      <div class="bookmark-item-header">
        <div class="bookmark-item-icon">
          ${getBookmarkIcon(bookmark.itemType)}
        </div>
        <div class="bookmark-item-info">
          <h4 class="bookmark-title" onclick="openBookmarkItem('${bookmark.itemId}', '${bookmark.itemType}')">${bookmark.title}</h4>
          <div class="bookmark-meta">
            <span class="bookmark-type">${formatBookmarkType(bookmark.itemType)}</span>
            <span class="bookmark-date">${formatDate(bookmark.createdAt)}</span>
          </div>
        </div>
        <div class="bookmark-item-actions">
          <button class="btn btn-icon" onclick="editBookmark('${bookmark.id}')" title="Edit">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
              <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
          </button>
          <button class="btn btn-icon btn-danger" onclick="removeBookmarkById('${bookmark.id}')" title="Remove">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>
      </div>
      ${bookmark.notes ? `<div class="bookmark-notes">${bookmark.notes}</div>` : ''}
      ${bookmark.tags && bookmark.tags.length > 0 ? `
        <div class="bookmark-tags">
          ${bookmark.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
        </div>
      ` : ''}
    </div>
  `).join('');
}

// Helper functions for bookmarks
function getBookmarkIcon(type) {
  switch (type) {
    case 'doc':
      return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
        <polyline points="14 2 14 8 20 8"/>
      </svg>`;
    case 'excel':
      return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="3" width="18" height="18" rx="2"/>
        <line x1="3" y1="9" x2="21" y2="9"/>
        <line x1="9" y1="3" x2="9" y2="21"/>
      </svg>`;
    case 'web':
      return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"/>
        <line x1="2" y1="12" x2="22" y2="12"/>
        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
      </svg>`;
    default:
      return `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
      </svg>`;
  }
}

function formatBookmarkType(type) {
  const types = {
    'doc': 'Document',
    'excel': 'Spreadsheet',
    'web': 'Web Link'
  };
  return types[type] || type;
}

function openBookmarkItem(itemId, itemType) {
  switch (itemType) {
    case 'doc':
      openDocEditor(itemId);
      break;
    case 'excel':
      openExcelEditor(itemId);
      break;
    case 'web':
      // Handle web links
      const bookmarks = getAllBookmarks();
      const bookmark = bookmarks.find(b => b.itemId === itemId && b.itemType === itemType);
      if (bookmark && bookmark.metadata && bookmark.metadata.url) {
        window.open(bookmark.metadata.url, '_blank');
      }
      break;
  }
  closeModal();
}

function removeBookmarkById(bookmarkId) {
  const bookmarks = getAllBookmarks();
  const filteredBookmarks = bookmarks.filter(b => b.id !== bookmarkId);

  if (saveBookmarks(filteredBookmarks)) {
    showToast('Bookmark removed', 'success');
    // Refresh the bookmark list
    const bookmarkList = document.getElementById('bookmarkList');
    if (bookmarkList) {
      bookmarkList.innerHTML = renderBookmarkList(filteredBookmarks);
    }
  }
}

function editBookmark(bookmarkId) {
  const bookmarks = getAllBookmarks();
  const bookmark = bookmarks.find(b => b.id === bookmarkId);

  if (!bookmark) return;

  const content = `
    <div class="edit-bookmark-form">
      <div class="form-group">
        <label>Title</label>
        <input type="text" id="editBookmarkTitle" value="${escapeHtml(bookmark.title)}" />
      </div>
      <div class="form-group">
        <label>Notes</label>
        <textarea id="editBookmarkNotes" placeholder="Add notes...">${escapeHtml(bookmark.notes || '')}</textarea>
      </div>
      <div class="form-group">
        <label>Tags (comma separated)</label>
        <input type="text" id="editBookmarkTags" value="${bookmark.tags ? bookmark.tags.join(', ') : ''}" placeholder="work, important, review" />
      </div>
      <div class="form-actions">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveEditedBookmark('${bookmarkId}')">Save Changes</button>
      </div>
    </div>
  `;

  openModal('Edit Bookmark', content);
}

function saveEditedBookmark(bookmarkId) {
  const title = document.getElementById('editBookmarkTitle').value.trim();
  const notes = document.getElementById('editBookmarkNotes').value.trim();
  const tags = document.getElementById('editBookmarkTags').value
    .split(',')
    .map(tag => tag.trim())
    .filter(tag => tag.length > 0);

  if (!title) {
    showToast('Title is required', 'error');
    return;
  }

  const bookmarks = getAllBookmarks();
  const bookmarkIndex = bookmarks.findIndex(b => b.id === bookmarkId);

  if (bookmarkIndex !== -1) {
    bookmarks[bookmarkIndex] = {
      ...bookmarks[bookmarkIndex],
      title,
      notes,
      tags
    };

    if (saveBookmarks(bookmarks)) {
      showToast('Bookmark updated', 'success');
      closeModal();
      // Refresh bookmark manager if open
      const modalTitle = document.querySelector('.modal-title');
      if (modalTitle && modalTitle.textContent === 'Bookmark Manager') {
        const bookmarkList = document.getElementById('bookmarkList');
        if (bookmarkList) {
          bookmarkList.innerHTML = renderBookmarkList(bookmarks);
        }
      }
    }
  }
}

function openAddBookmarkModal(spaceId = '') {
  const content = `
    <div class="add-bookmark-form">
      <div class="form-tabs">
        <button class="form-tab active" onclick="switchBookmarkTab('existing')">Existing Item</button>
        <button class="form-tab" onclick="switchBookmarkTab('web')">Web Link</button>
      </div>
      
      <div class="form-tab-content active" id="existing-tab">
        <div class="form-group">
          <label>Select Item</label>
          <select id="bookmarkItemType">
            <option value="">Choose item type...</option>
            <option value="doc">Document</option>
            <option value="excel">Spreadsheet</option>
          </select>
        </div>
        <div class="form-group" id="itemSelectionGroup" style="display: none;">
          <label>Select Specific Item</label>
          <select id="bookmarkItemId">
            <option value="">Loading...</option>
          </select>
        </div>
      </div>
      
      <div class="form-tab-content" id="web-tab">
        <div class="form-group">
          <label>URL</label>
          <input type="url" id="bookmarkUrl" placeholder="https://example.com" />
        </div>
        <div class="form-group">
          <label>Title</label>
          <input type="text" id="bookmarkWebTitle" placeholder="Website title" />
        </div>
      </div>
      
      <div class="form-group">
        <label>Notes (optional)</label>
        <textarea id="bookmarkNotes" placeholder="Add notes about this bookmark..."></textarea>
      </div>
      
      <div class="form-group">
        <label>Tags (comma separated)</label>
        <input type="text" id="bookmarkTags" placeholder="work, important, review" />
      </div>
      
      <div class="form-actions">
        <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveNewBookmark('${spaceId}')">Add Bookmark</button>
      </div>
    </div>
  `;

  openModal('Add Bookmark', content);

  // Set up event listeners
  document.getElementById('bookmarkItemType').addEventListener('change', function () {
    const itemSelectionGroup = document.getElementById('itemSelectionGroup');
    const itemIdSelect = document.getElementById('bookmarkItemId');

    if (this.value) {
      itemSelectionGroup.style.display = 'block';
      populateItemSelection(this.value, itemIdSelect);
    } else {
      itemSelectionGroup.style.display = 'none';
    }
  });
}

function switchBookmarkTab(tabName) {
  // Hide all tabs
  document.querySelectorAll('.form-tab-content').forEach(tab => {
    tab.classList.remove('active');
  });
  document.querySelectorAll('.form-tab').forEach(tab => {
    tab.classList.remove('active');
  });

  // Show selected tab
  document.getElementById(`${tabName}-tab`).classList.add('active');
  event.target.classList.add('active');
}

function populateItemSelection(itemType, selectElement) {
  let items = [];

  if (itemType === 'doc') {
    items = loadDocs();
  } else if (itemType === 'excel') {
    items = loadExcels();
  }

  selectElement.innerHTML = '<option value="">Select an item...</option>' +
    items.map(item => `<option value="${item.id}">${escapeHtml(item.title)}</option>`).join('');
}

function saveNewBookmark(spaceId) {
  const activeTab = document.querySelector('.form-tab-content.active').id;

  if (activeTab === 'existing-tab') {
    const itemType = document.getElementById('bookmarkItemType').value;
    const itemId = document.getElementById('bookmarkItemId').value;
    const notes = document.getElementById('bookmarkNotes').value.trim();
    const tags = document.getElementById('bookmarkTags').value
      .split(',')
      .map(tag => tag.trim())
      .filter(tag => tag.length > 0);

    if (!itemType || !itemId) {
      showToast('Please select an item', 'error');
      return;
    }

    const items = itemType === 'doc' ? loadDocs() : loadExcels();
    const item = items.find(i => i.id === itemId);

    if (item) {
      if (addBookmark(itemId, itemType, item.title, spaceId || item.spaceId, { notes, tags })) {
        closeModal();
      }
    }
  } else {
    // Web link bookmark
    const url = document.getElementById('bookmarkUrl').value.trim();
    const title = document.getElementById('bookmarkWebTitle').value.trim();
    const notes = document.getElementById('bookmarkNotes').value.trim();
    const tags = document.getElementById('bookmarkTags').value
      .split(',')
      .map(tag => tag.trim())
      .filter(tag => tag.length > 0);

    if (!url || !title) {
      showToast('URL and title are required', 'error');
      return;
    }

    const bookmarkId = 'web-' + generateId();
    const bookmarks = getAllBookmarks();

    const newBookmark = {
      id: bookmarkId,
      itemId: bookmarkId,
      itemType: 'web',
      title,
      spaceId: spaceId || 'global',
      createdAt: new Date().toISOString(),
      metadata: { url, notes, tags },
      tags,
      notes
    };

    bookmarks.push(newBookmark);

    if (saveBookmarks(bookmarks)) {
      showToast('Web link bookmarked!', 'success');
      closeModal();
    }
  }
}

// Utility functions
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// User data helper functions
function getCurrentUserName() {
  // ONLY use saved profile name from database, never Google metadata
  if (window.LayerDB && window.LayerDB.isAuthenticated()) {
    try {
      const profile = window.LayerDB.getProfile();
      if (profile && profile.name) {
        console.log('getCurrentUserName: Using saved profile name (IGNORING Google):', profile.name);
        return profile.name;
      }
    } catch (error) {
      console.warn('getCurrentUserName: Failed to get profile, trying fallback');
    }
    
    // If no profile, use email split (NEVER use Google metadata)
    const user = window.LayerDB.getCurrentUser();
    if (user && user.email) {
      const emailName = user.email.split('@')[0];
      console.log('getCurrentUserName: Using email split (NOT Google name):', emailName);
      return emailName;
    }
  }
  
  // Final fallback - only use localStorage as last resort
  const savedName = localStorage.getItem('userDisplayName');
  if (savedName && savedName !== 'User') {
    console.log('getCurrentUserName: Using localStorage fallback:', savedName);
    return savedName;
  }
  
  console.log('getCurrentUserName: Using default "User"');
  return 'User';
}

function getCurrentUserInitials() {
  const name = getCurrentUserName();
  if (!name || name === 'User') return 'U';

  // Get first letter of first name, and first letter of last name if available
  const parts = name.trim().split(' ');
  if (parts.length >= 2) {
    return (parts[0][0] + parts[1][0]).toUpperCase();
  }
  return name.charAt(0).toUpperCase();
}

function formatDate(dateString) {
  const date = new Date(dateString);
  return date.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
}

function exportBookmarks() {
  const bookmarks = getAllBookmarks();
  const dataStr = JSON.stringify(bookmarks, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(dataBlob);

  const link = document.createElement('a');
  link.href = url;
  link.download = `layer-bookmarks-${new Date().toISOString().split('T')[0]}.json`;
  link.click();

  URL.revokeObjectURL(url);
  showToast('Bookmarks exported!', 'success');
}

// Initialize bookmarks on app load
initializeBookmarks();

// Update the space view rendering to use the new bookmark system
function getBookmarkedItemsForSpaceView(spaceId) {
  return getBookmarkedItemsForSpace(spaceId);
}

// Helper function to check if current user is project owner (creator/leader)
function isProjectOwner(projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) return false;

  // Primary check: Use the isOwner flag from DB if available (most reliable)
  if (typeof project.isOwner !== 'undefined') {
    console.log('✓ Using isOwner flag from DB:', project.isOwner);
    return project.isOwner;
  }

  const currentUserEmail = window.LayerDB?.getCurrentUser()?.email || getCurrentUserEmail();
  const currentUserId = window.LayerDB?.getCurrentUser()?.id;
  const currentUserName = window.LayerDB?.getCurrentUser()?.user_metadata?.name || getCurrentUserName();

  console.log('Checking project ownership:', {
    projectIndex,
    projectLeader: project.leader,
    projectUserId: project.userId || project.user_id,
    projectUserEmail: project.userEmail,
    currentUserEmail,
    currentUserId,
    currentUserName
  });

  // Secondary check: User ID match
  const projectUserId = project.userId || project.user_id;
  if (projectUserId && currentUserId && projectUserId === currentUserId) {
    console.log('✓ User is project creator (by ID)');
    return true;
  }

  // Tertiary check: User email match
  if (project.userEmail === currentUserEmail) {
    console.log('✓ User is project creator (by email)');
    return true;
  }

  // Fallback check: Leader name match (for backward compatibility)
  if (project.leader === currentUserName) {
    console.log('✓ User is project leader (by name)');
    return true;
  }

  console.log('✗ User is not project owner');
  return false;
}

// Make isProjectOwner globally available
window.isProjectOwner = isProjectOwner;

// Helper function to check if current user is the project leader specifically
function isProjectLeader(project) {
  if (!project) return false;

  const currentUser = window.LayerDB?.getCurrentUser();
  if (!currentUser) return false;

  // Check if current user ID matches project creator ID
  return project.user_id === currentUser.id;
}

// Helper function to get project leader name for display
function getProjectLeaderName(project) {
  if (!project) return 'Unknown';

  // Use leader field if set
  if (project.leader) return project.leader;

  // Fallback to user email
  if (project.userEmail) return project.userEmail;

  return 'Project Creator';
}

// Helper function to get project leader display name (for properties panel)
function getProjectLeaderDisplayName(project) {
  if (!project) return 'Unknown';
  if (project.leader) return project.leader;
  if (project.userEmail) return project.userEmail.split('@')[0];
  return 'Project Creator';
}

// Helper function to get project leader initials (for avatar)
function getProjectLeaderInitials(project) {
  const name = getProjectLeaderDisplayName(project);
  if (!name) return '?';
  const parts = name.split(/[\s@]/);
  if (parts.length >= 2) {
    return (parts[0].charAt(0) + parts[1].charAt(0)).toUpperCase();
  }
  return name.slice(0, 2).toUpperCase();
}

// Make functions globally available
window.getProjectLeaderName = getProjectLeaderName;
window.getProjectLeaderDisplayName = getProjectLeaderDisplayName;
window.getProjectLeaderInitials = getProjectLeaderInitials;

// Context menu functions for member avatars
window.showMemberContextMenu = function (event, memberName, projectIndex, memberIndex) {
  event.preventDefault();

  // Remove any existing context menus
  const existingMenus = document.querySelectorAll('.context-menu');
  existingMenus.forEach(menu => menu.remove());

  // Check if current user is project owner
  const isOwner = isProjectOwner(projectIndex);

  // Don't show context menu if user is not owner (no admin actions available)
  if (!isOwner) {
    showNotification('Only project creator can manage team members', 'info');
    return;
  }

  // Load projects and check if user is already leader
  const projects = loadProjects();
  const project = projects[projectIndex];
  const isLeader = project?.leader === memberName;

  // Don't allow actions on the project creator
  const currentUser = window.LayerDB?.getCurrentUser();
  const memberIsOwner = (project.user_id && memberName === (currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0])) ||
    (project.userEmail === memberName) ||
    (project.leader === memberName && project.user_id === currentUser?.id);

  if (memberIsOwner) {
    showNotification('Cannot perform actions on project creator', 'info');
    return;
  }

  // Create context menu
  const contextMenu = document.createElement('div');
  contextMenu.className = 'context-menu';

  // Extract email from member name if it contains @
  const displayName = memberName === 'You' ? getCurrentUserName() : memberName;
  const email = memberName.includes('@') ? memberName : null;

  contextMenu.innerHTML = `
    <div class="context-menu-header">
      <div class="context-menu-user-name">${displayName}</div>
      ${email ? `<div class="context-menu-user-email">${email}</div>` : ''}
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item ${isLeader ? 'disabled' : ''}" onclick="makeLeader('${memberName}', ${projectIndex}, ${memberIndex})">
      <i class="fas fa-crown" style="width: 16px; text-align: center;"></i>
      <span>${isLeader ? 'Already Leader' : 'Make Leader'}</span>
    </div>
    <div class="context-menu-item danger" onclick="kickFromProject('${memberName}', ${projectIndex}, ${memberIndex})">
      <i class="fas fa-user-minus" style="width: 16px; text-align: center;"></i>
      <span>Remove from Project</span>
    </div>
  `;

  document.body.appendChild(contextMenu);

  // Position the context menu
  const rect = contextMenu.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  contextMenu.style.top = `${event.clientY}px`;
  contextMenu.style.left = `${event.clientX}px`;

  if (rect.right > viewportWidth) {
    contextMenu.style.left = `${event.clientX - contextMenu.offsetWidth}px`;
  }

  if (rect.bottom > viewportHeight) {
    contextMenu.style.top = `${event.clientY - contextMenu.offsetHeight}px`;
  }

  // Close context menu when clicking outside
  setTimeout(() => {
    document.addEventListener('click', function closeContextMenu() {
      const contextMenu = document.querySelector('.context-menu');
      if (contextMenu) {
        contextMenu.remove();
      }
      document.removeEventListener('click', closeContextMenu);
    });
  }, 100);
};

window.makeLeader = async function (memberName, projectIndex, memberIndex) {
  // Check if current user is project owner before allowing leader assignment
  if (!isProjectOwner(projectIndex)) {
    showNotification('Only the project creator can assign new leaders', 'error');
    return;
  }

  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) {
    console.error('Project not found:', projectIndex);
    return;
  }

  // Update project leader
  project.leader = memberName;

  // Save to localStorage
  saveProjects(projects);

  // Update database if authenticated
  if (window.LayerDB && window.LayerDB.isAuthenticated() && project.id) {
    try {
      await window.LayerDB.updateProject(project.id, {
        leader: memberName  // Sync leader change
      });
      console.log(' Project leader updated in database');
    } catch (error) {
      console.error(' Failed to update project leader in database:', error);
      showNotification('Leader updated locally but failed to sync to server', 'error');
      return;
    }
  }

  // Update UI - refresh team members display for immediate feedback
  if (currentView === 'project-detail') {
    refreshTeamMembersDisplay(projectIndex);
  } else {
    renderCurrentView();
  }

  // Show notification
  showNotification(`${memberName} is now the project leader`, 'success');

  // Close context menu
  const contextMenu = document.querySelector('.context-menu');
  if (contextMenu) {
    contextMenu.remove();
  }
};

window.kickFromProject = async function (memberName, projectIndex, memberIndex) {
  // Check if current user is project owner before allowing member removal
  if (!isProjectOwner(projectIndex)) {
    showNotification('Only project creator can remove members', 'error');
    return;
  }

  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) {
    console.error('Project not found at index:', projectIndex);
    return;
  }

  // Don't allow kicking the project creator
  const currentUser = window.LayerDB?.getCurrentUser();
  const memberIsOwner = (project.userId && memberName === (currentUser?.user_metadata?.name || currentUser?.email?.split('@')[0])) ||
    (project.userEmail === memberName) ||
    (project.leader === memberName);

  if (memberIsOwner) {
    showNotification('Cannot remove project creator from the project', 'error');
    return;
  }

  if (confirm(`Remove ${memberName} from the project?`)) {
    try {
      // Check if using new project_members system
      if (window.LayerDB && window.LayerDB.isAuthenticated() && project.id) {
        // Try to find the user ID from the member's email/name
        // First check if we have project_members data with user IDs
        if (project.projectMembers && Array.isArray(project.projectMembers)) {
          const memberRecord = project.projectMembers.find(m =>
            m.email === memberName || m.name === memberName || m.memberId === memberName
          );

          if (memberRecord && memberRecord.memberId) {
            await window.LayerDB.removeProjectMember(project.id, memberRecord.memberId);
            console.log('✓ Member removed via project_members table');
          } else {
            // Fallback to legacy team_members approach
            await window.LayerDB.removeTeamMemberFromProject(project.id, memberName);
            console.log('✓ Member removed via legacy team_members array');
          }
        } else {
          // Fallback to legacy team_members approach
          await window.LayerDB.removeTeamMemberFromProject(project.id, memberName);
          console.log('✓ Member removed via legacy team_members array');
        }

        // Refresh projects from DB to get updated data
        if (typeof refreshProjects === 'function') {
          await refreshProjects();
        }
      }

      // Update UI - refresh team members display for immediate feedback
      if (currentView === 'project-detail') {
        refreshTeamMembersDisplay(projectIndex);
      } else {
        renderCurrentView();
      }

      // Show notification
      showNotification(`${memberName} has been removed from the project`, 'warning');

      // Close context menu
      const contextMenu = document.querySelector('.context-menu');
      if (contextMenu) {
        contextMenu.remove();
      }

    } catch (error) {
      console.error('Error removing member from project:', error);
      showNotification(error.message || 'Failed to remove member', 'error');
    }
  }
};

window.leaveProject = async function (projectIndex) {
  const projects = loadProjects();
  const project = projects[projectIndex];
  if (!project) {
    console.error('Project not found at index:', projectIndex);
    return;
  }

  // Check if user is owner - they can't leave, must delete or transfer
  if (isProjectOwner(projectIndex)) {
    showNotification('Project owners cannot leave. Transfer ownership or delete the project instead.', 'error');
    return;
  }

  // Confirm before leaving
  if (!confirm(`Are you sure you want to leave the project "${project.name}"? You'll lose access to all project data.`)) {
    return;
  }

  try {
    if (window.LayerDB && window.LayerDB.isAuthenticated() && project.id) {
      // Use the new leaveProject function which handles project_members
      await window.LayerDB.leaveProject(project.id);
      console.log('✓ User left project via project_members table');

      // Refresh projects from DB to get updated data
      if (typeof refreshProjects === 'function') {
        await refreshProjects();
      }
    }

    // Show notification
    showNotification(`You have left the project "${project.name}"`, 'info');

    // Navigate back to projects view
    currentView = 'activity';
    selectedProjectIndex = null;
    renderCurrentView();

  } catch (error) {
    console.error('Error leaving project:', error);
    showNotification(error.message || 'Failed to leave project. Please try again.', 'error');
  }
};

// Helper function to show notifications
window.showNotification = function (message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.textContent = message;
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    border-radius: 8px;
    color: white;
    font-size: 14px;
    font-weight: 500;
    z-index: 10000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    backdrop-filter: blur(10px);
    animation: slideInRight 0.3s ease;
  `;

  // Set background color based on type
  switch (type) {
    case 'success':
      notification.style.background = 'linear-gradient(135deg, #10b981, #059669)';
      break;
    case 'warning':
      notification.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
      break;
    case 'error':
      notification.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
      break;
    default:
      notification.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
  }

  document.body.appendChild(notification);

  // Remove after 3 seconds
  setTimeout(() => {
    notification.style.animation = 'slideOutRight 0.3s ease';
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 300);
  }, 3000);
};

// Add CSS for notifications
const notificationStyles = `
  @keyframes slideInRight {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes slideOutRight {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
  }
`;

const styleSheet = document.createElement('style');
styleSheet.textContent = notificationStyles;
document.head.appendChild(styleSheet);

// Close context menu when clicking elsewhere
document.addEventListener('click', function (e) {
  const contextMenu = document.querySelector('.context-menu');
  if (contextMenu && !contextMenu.contains(e.target)) {
    contextMenu.remove();
  }
});

// ============================================
// Chat Realtime Cleanup
// ============================================

// Cleanup all chat subscriptions on page unload
window.addEventListener('beforeunload', () => {
  if (typeof cleanupAllChatSubscriptions === 'function') {
    cleanupAllChatSubscriptions();
  }
});

// Request notification permissions when user opens Team view
function requestNotificationPermission() {
  if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission().then(permission => {
      if (permission === 'granted') {
        console.log('✓ Notification permission granted');
      }
    });
  }
}
// ============================================
// Gantt Guide Logic
// ============================================

function dismissGanttGuide(event) {
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  // Save to localStorage
  localStorage.setItem('layer_hasSeenGanttGuide', 'true');

  // Remove from DOM with animation
  const bubble = document.querySelector('.gantt-guide-bubble');
  if (bubble) {
    bubble.style.opacity = '0';
    bubble.style.transform = 'translate(-50%, -10px)';
    bubble.style.transition = 'all 0.2s ease';

    setTimeout(() => {
      bubble.remove();
    }, 200);
  }
}

// ============================================
// Guide Bubble Logic (Generic)
// ============================================

function dismissGuide(event, storageKey) {
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  if (storageKey) {
    localStorage.setItem(storageKey, 'true');
  }

  // Remove from DOM with animation
  let bubble;
  if (event && event.target) {
    bubble = event.target.closest('.guide-bubble');
  }

  // Fallback: remove all if no specific bubble found (for programmatic calls without event)
  if (!bubble) {
    const bubbles = document.querySelectorAll('.guide-bubble');
    bubbles.forEach(b => {
      b.style.opacity = '0';
      setTimeout(() => b.remove(), 200);
    });
    return;
  }

  if (bubble) {
    bubble.style.opacity = '0';
    bubble.style.transform = 'translate(-50%, -10px)';
    bubble.style.transition = 'all 0.2s ease';

    setTimeout(() => {
      bubble.remove();
    }, 200);
  }
}

// ============================================
// Shared Content Widget Functions
// ============================================

// Global variable to store shared content
let sharedContentCache = {
  docs: [],
  excels: [],
  lastLoaded: null,
  previousDocs: [],
  previousExcels: []
};

// Load and render shared content in dashboard widget
let sharedContentErrorCount = 0;
const MAX_SHARED_CONTENT_ERRORS = 5;

async function loadSharedContentWidget() {
  const widgetContainer = document.getElementById('sharedContentWidget');
  if (!widgetContainer) {
    console.log('🔄 Shared content widget container not found');
    return;
  }

  try {
    // Load shared content from database
    let sharedDocs = [];
    let sharedExcels = [];

    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      console.log('🔄 Loading from database...');
      console.log('🔄 Current user:', window.LayerDB.getCurrentUser?.()?.email || 'Unknown');
      sharedDocs = await window.LayerDB.loadSharedDocs();
      sharedExcels = await window.LayerDB.loadSharedExcels();
      console.log('🔄 Loaded shared docs:', sharedDocs.length, 'shared excels:', sharedExcels.length);
      console.log('🔄 Shared docs details:', sharedDocs.map(d => ({ id: d.id, title: d.title, sharedWith: d.sharedWith })));
      console.log('🔄 Shared excels details:', sharedExcels.map(e => ({ id: e.id, title: e.title, sharedWith: e.sharedWith })));

      // Fetch user information for shared content
      const allShared = [...sharedDocs, ...sharedExcels];
      const userIds = [...new Set(allShared.map(item => item.sharedBy).filter(Boolean))];

      if (userIds.length > 0) {
        console.log('🔄 Fetching user info for', userIds.length, 'users');
        const userPromises = userIds.map(userId => window.LayerDB.getProfileById(userId));
        const userProfiles = await Promise.all(userPromises);

        // Create a map of user ID to user profile
        const userMap = {};
        userProfiles.forEach((profile, index) => {
          if (profile) {
            userMap[userIds[index]] = profile;
          }
        });

        // Attach user info to shared items
        sharedDocs = sharedDocs.map(doc => ({
          ...doc,
          sharedByUser: userMap[doc.sharedBy] || null
        }));

        sharedExcels = sharedExcels.map(excel => ({
          ...excel,
          sharedByUser: userMap[excel.sharedBy] || null
        }));
      }

      // Reset error count on successful load
      sharedContentErrorCount = 0;
    } else {
      // Fallback to localStorage
      console.log('🔄 Using localStorage fallback...');
      const allDocs = loadDocs();
      const allExcels = loadExcels();
      const currentUserEmail = localStorage.getItem('userEmail') || '';
      console.log('🔄 Current user email from localStorage:', currentUserEmail);

      sharedDocs = allDocs.filter(doc =>
        doc.shared_with && doc.shared_with.some(user => user.email === currentUserEmail)
      );
      sharedExcels = allExcels.filter(excel =>
        excel.shared_with && excel.shared_with.some(user => user.email === currentUserEmail)
      );
      console.log('🔄 Found shared docs in localStorage:', sharedDocs.length);
      console.log('🔄 Found shared excels in localStorage:', sharedExcels.length);
    }

    // Always render the widget, even if no content
    console.log('🔄 Rendering shared content widget...');
    renderSharedContentWidget(sharedDocs, sharedExcels);

  } catch (error) {
    sharedContentErrorCount++;
    console.error(`❌ Error loading shared content (${sharedContentErrorCount}/${MAX_SHARED_CONTENT_ERRORS}):`, error);

    // Stop polling if too many errors occur
    if (sharedContentErrorCount >= MAX_SHARED_CONTENT_ERRORS) {
      console.error('🛑 Too many errors loading shared content. Stopping polling.');
      stopSharedContentPolling();
    }

    widgetContainer.innerHTML = `
      <div style="text-align: center; padding: 20px; color: var(--destructive); font-size: 13px;">
        <div style="margin-bottom: 8px;">Failed to load shared content</div>
        <button onclick="loadSharedContentWidget()" style="padding: 6px 12px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; font-size: 12px;">
          Try Again
        </button>
        ${sharedContentErrorCount >= MAX_SHARED_CONTENT_ERRORS ? '<div style="margin-top: 8px; font-size: 11px;">Auto-refresh disabled due to repeated errors</div>' : ''}
      </div>
    `;
  }
}

// Render shared content in widget
function renderSharedContentWidget(sharedDocs, sharedExcels) {
  const widgetContainer = document.getElementById('sharedContentWidget');
  if (!widgetContainer) return;

  const allShared = [...sharedDocs, ...sharedExcels];

  console.log('🔄 Rendering widget with', allShared.length, 'items');

  if (allShared.length === 0) {
    widgetContainer.innerHTML = `
      <div style="text-align: center; padding: 20px; color: var(--muted-foreground); font-size: 13px;">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:32px;height:32px;margin-bottom:8px;opacity:0.5;">
          <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
        </svg>
        <div>No shared content yet</div>
        <div style="font-size: 11px; margin-top: 4px;">When someone shares content with you, it will appear here</div>
        <button onclick="loadSharedContentWidget()" style="
          margin-top: 12px;
          padding: 6px 12px; 
          background: var(--surface); 
          border: 1px solid var(--border); 
          border-radius: 6px; 
          font-size: 12px; 
          color: var(--foreground);
          cursor: pointer;
        ">🔄 Refresh</button>
      </div>
    `;
    return;
  }

  // Sort by updated date (newest first)
  allShared.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));

  const contentHtml = allShared.slice(0, 5).map(item => {
    const isDoc = item.title && item.title.endsWith('.doc') || !item.title || !item.title.includes('.excel');

    const icon = isDoc ?
      `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
        <polyline points="14 2 14 8 20 8"/>
      </svg>` :
      `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;">
        <path d="M3 3h18v18H3zM3 9h18M9 21V9"/>
      </svg>`;

    const typeLabel = isDoc ? 'Document' : 'Spreadsheet';
    const timeAgo = getTimeAgo(new Date(item.updatedAt));

    // Create user avatar HTML
    const userAvatar = item.sharedByUser ? `
      <div style="display: flex; align-items: center; gap: 6px; flex-shrink: 0;">
        ${item.sharedByUser.avatar_url ?
        `<img src="${item.sharedByUser.avatar_url}" alt="${item.sharedByUser.name || item.sharedByUser.email}" 
               style="width: 28px; height: 28px; border-radius: 50%; object-fit: cover; border: 1px solid var(--border);">` :
        `<div style="width: 28px; height: 28px; border-radius: 50%; background: var(--muted); display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 500; color: var(--muted-foreground); border: 1px solid var(--border);">
            ${(item.sharedByUser.name || item.sharedByUser.email || 'U').charAt(0).toUpperCase()}
          </div>`
      }
      </div>
    ` : '';

    return `
      <div class="shared-content-item" onclick="openSharedContent('${isDoc ? 'doc' : 'excel'}', '${item.id}')" style="
        display: flex; 
        align-items: center; 
        gap: 12px; 
        padding: 12px; 
        border-radius: 8px; 
        cursor: pointer; 
        transition: all 0.2s;
        border: 1px solid transparent;
      " onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border)'" 
         onmouseout="this.style.background='transparent'; this.style.borderColor='transparent'">
        <div style="color: var(--muted-foreground); flex-shrink: 0;">${icon}</div>
        <div style="flex: 1; min-width: 0;">
          <div style="font-size: 13px; font-weight: 500; color: var(--foreground); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
            ${item.title}
          </div>
          <div style="font-size: 11px; color: var(--muted-foreground); margin-top: 2px; display: flex; align-items: center; justify-content: space-between;">
            <span>${typeLabel} • ${timeAgo}</span>
            ${userAvatar}
          </div>
        </div>
      </div>
    `;
  }).join('');

  widgetContainer.innerHTML = `
    <div style="max-height: 280px; overflow-y: auto;">
      ${contentHtml}
    </div>
    ${allShared.length > 5 ? `
      <div style="text-align: center; padding-top: 8px; border-top: 1px solid var(--border); margin-top: 8px;">
        <button onclick="showAllSharedContent()" style="padding: 6px 12px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; font-size: 12px; color: var(--foreground);">
          View All ${allShared.length} Items
        </button>
      </div>
    ` : ''}
  `;

  console.log('✅ Widget rendered successfully');
}

// Manual test function - call this to immediately update the widget
window.testSharedWidget = function () {
  console.log('🧪 Testing shared widget update...');
  loadSharedContentWidget();
};

// Debug function to test sharing system
window.debugSharedContent = async function () {
  console.log('🔍 Debugging shared content...');

  // Check current user
  const currentUser = window.LayerDB?.getCurrentUser?.();
  console.log('🔍 Current user:', currentUser);

  // Check authentication
  const isAuthenticated = window.LayerDB?.isAuthenticated?.();
  console.log('🔍 Is authenticated:', isAuthenticated);

  // Load all docs to see what's available
  if (window.LayerDB && isAuthenticated) {
    try {
      const { data: allDocs } = await window.supabaseClient
        .from('docs')
        .select('*')
        .limit(5);

      console.log('🔍 Sample docs in database:', allDocs);

      const { data: allExcels } = await window.supabaseClient
        .from('excels')
        .select('*')
        .limit(5);

      console.log('🔍 Sample excels in database:', allExcels);

      // Test loading shared content
      const sharedDocs = await window.LayerDB.loadSharedDocs();
      const sharedExcels = await window.LayerDB.loadSharedExcels();

      console.log('🔍 Shared docs found:', sharedDocs);
      console.log('🔍 Shared excels found:', sharedExcels);

    } catch (error) {
      console.error('🔍 Debug error:', error);
    }
  }
};

// Open shared content (doc or excel)
async function openSharedContent(type, id) {
  console.log('🔄 Opening shared content:', type, id);

  if (type === 'doc') {
    // Load the shared doc from database first so it's available locally
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      try {
        const { data, error } = await supabaseClient
          .from('docs')
          .select('*')
          .eq('id', id)
          .maybeSingle();

        if (data && !error) {
          // Store in local docs cache so openDocEditor can find it
          const docs = loadDocs();
          const existingIndex = docs.findIndex(d => d.id === id);
          const docObj = {
            id: data.id,
            title: data.title,
            content: data.content,
            spaceId: data.space_id,
            isFavorite: data.is_favorite,
            sharedWith: data.shared_with,
            sharedBy: data.user_id,
            createdAt: data.created_at,
            updatedAt: data.updated_at
          };
          if (existingIndex !== -1) {
            docs[existingIndex] = docObj;
          } else {
            docs.push(docObj);
          }
          saveDocs(docs);
        }
      } catch (e) {
        console.error('Failed to load shared doc from DB:', e);
      }
    }
    currentDocId = id;
    openDocEditor(id);
  } else if (type === 'excel') {
    // Load the shared excel from database first
    if (window.LayerDB && window.LayerDB.isAuthenticated()) {
      try {
        const { data, error } = await supabaseClient
          .from('excels')
          .select('*')
          .eq('id', id)
          .maybeSingle();

        if (data && !error) {
          const excels = loadExcels();
          const existingIndex = excels.findIndex(e => e.id === id);
          const excelObj = {
            id: data.id,
            title: data.title,
            data: data.data,
            spaceId: data.space_id,
            isFavorite: data.is_favorite,
            sharedWith: data.shared_with,
            sharedBy: data.user_id,
            createdAt: data.created_at,
            updatedAt: data.updated_at
          };
          if (existingIndex !== -1) {
            excels[existingIndex] = excelObj;
          } else {
            excels.push(excelObj);
          }
          saveExcels(excels);
        }
      } catch (e) {
        console.error('Failed to load shared excel from DB:', e);
      }
    }
    currentExcelId = id;
    openExcelEditor(id);
  }
}

// Refresh shared content
async function refreshSharedContent() {
  console.log('🔄 Refreshing shared content...');
  await loadSharedContentWidget();
}

// Show all shared content (could open a modal or navigate to a dedicated view)
function showAllSharedContent() {
  // For now, just refresh the widget - this could be expanded to show a full page view
  showToast('Showing all shared content - feature coming soon!', 'info');
}

// Helper function to get time ago string
function getTimeAgo(date) {
  const seconds = Math.floor((new Date() - date) / 1000);

  if (seconds < 60) return 'just now';
  if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
  if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
  if (seconds < 604800) return Math.floor(seconds / 86400) + 'd ago';
  return Math.floor(seconds / 604800) + 'w ago';
}

// Global variable for polling interval
let sharedContentPollingInterval = null;

// Initialize shared content widget when dashboard is loaded
function initializeSharedContentWidget() {
  // Clear any existing polling
  if (sharedContentPollingInterval) {
    clearInterval(sharedContentPollingInterval);
  }

  console.log('🔄 Initializing shared content widget...');

  // Load immediately
  loadSharedContentWidget();

  // Set up realtime subscription for instant updates
  if (window.LayerRealtime) {
    console.log('🔄 Setting up realtime subscription for shared content...');

    // Register callbacks for shared content updates
    window.LayerRealtime.registerRealtimeCallbacks({
      onSharedContentUpdated: (payload) => {
        console.log('🔄 Realtime shared content update received:', payload);
        // Immediately refresh the widget when content is shared/unshared
        loadSharedContentWidget();
      },
      onDocShared: (payload) => {
        console.log('🔄 Realtime doc sharing update:', payload);
        loadSharedContentWidget();
      },
      onExcelShared: (payload) => {
        console.log('🔄 Realtime excel sharing update:', payload);
        loadSharedContentWidget();
      }
    });

    // Subscribe to shared content changes
    window.LayerRealtime.subscribeToSharedContent((payload) => {
      console.log('🔄 Shared content changed via realtime:', payload);
      loadSharedContentWidget();
    });
  } else {
    console.warn('⚠️ LayerRealtime not available, falling back to polling');

    // Fallback to polling every 30 seconds for real-time updates
    sharedContentPollingInterval = setInterval(() => {
      console.log('🔄 Auto-polling shared content...');
      loadSharedContentWidget();
    }, 30000);

    console.log('✅ Shared content polling started (every 30 seconds)');
  }
}

// Stop polling when navigating away from dashboard
function stopSharedContentPolling() {
  if (sharedContentPollingInterval) {
    clearInterval(sharedContentPollingInterval);
    sharedContentPollingInterval = null;
    console.log('⏹️ Stopped shared content polling');
  }
}